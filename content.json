{"meta":{"title":"清风明月博客","subtitle":"瞧那片蓝天白云多美好呀","description":"欢迎你的到来","author":"清风明月","url":"https://Visen123.github.io"},"pages":[],"posts":[{"title":"安卓kotlinJetPack实现摄像头并录制视频","slug":"categories/Android/安卓kotlinJetPack实现摄像头并录制视频","date":"2024-07-16T07:32:08.000Z","updated":"2024-07-16T07:51:22.475Z","comments":true,"path":"2024/07/16/categories/Android/安卓kotlinJetPack实现摄像头并录制视频/","link":"","permalink":"https://visen123.github.io/2024/07/16/categories/Android/%E5%AE%89%E5%8D%93kotlinJetPack%E5%AE%9E%E7%8E%B0%E6%91%84%E5%83%8F%E5%A4%B4%E5%B9%B6%E5%BD%95%E5%88%B6%E8%A7%86%E9%A2%91/","excerpt":"","text":"为了在 Jetpack Compose 环境下开发一个使用后置摄像头采集视频，并在帧差异检测的基础上自动录制的 Android 应用，我们可以使用 CameraX 和 ViewModel，同时结合 FTP 上传功能。 下面这个完整示例展示了如何使用 Jetpack Compose 和 CameraX 编写这个应用。 添加依赖在 build.gradle 中添加所需的依赖： dependencies &#123; implementation &quot;androidx.compose.ui:ui:1.3.0&quot; implementation &quot;androidx.compose.material:material:1.3.0&quot; implementation &quot;androidx.lifecycle:lifecycle-viewmodel-compose:2.5.1&quot; implementation &quot;androidx.camera:camera-camera2:1.1.0&quot; implementation &quot;androidx.camera:camera-lifecycle:1.1.0&quot; implementation &quot;androidx.camera:camera-video:1.0.0-alpha28&quot; implementation &quot;androidx.camera:camera-view:1.1.0&quot; implementation &#39;commons-net:commons-net:3.6&#39; implementation &#39;androidx.activity:activity-compose:1.3.1&#39; &#125; 权限配置在 AndroidManifest.xml 中添加所需的权限： &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; 创建 ViewModel我们需要一个 ViewModel 来管理摄像头的操作、视频帧分析和录像控制。创建 CameraViewModel.kt： import android.content.Context import android.net.Uri import android.os.Handler import android.os.Looper import android.util.Log import androidx.camera.core.* import androidx.camera.lifecycle.ProcessCameraProvider import androidx.camera.video.* import androidx.compose.runtime.mutableStateOf import androidx.compose.runtime.remember import androidx.core.content.ContextCompat import androidx.lifecycle.ViewModel import androidx.lifecycle.viewModelScope import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.launch import java.io.File import java.text.SimpleDateFormat import java.util.* import java.util.concurrent.ExecutorService import java.util.concurrent.Executors class CameraViewModel : ViewModel() &#123; var isRecording = mutableStateOf(false) var previewUri = mutableStateOf&lt;Uri?&gt;(null) private var videoCapture: VideoCapture&lt;Recorder&gt;? = null private var recording: Recording? = null private lateinit var cameraExecutor: ExecutorService fun startCamera(context: Context, previewView: PreviewView) &#123; val cameraProviderFuture = ProcessCameraProvider.getInstance(context) cameraProviderFuture.addListener(&#123; val cameraProvider = cameraProviderFuture.get() val preview = Preview.Builder().build().also &#123; it.setSurfaceProvider(previewView.surfaceProvider) &#125; val recorder = Recorder.Builder() .setQualitySelector(QualitySelector.from(Quality.HIGHEST)) .build() videoCapture = VideoCapture.withOutput(recorder) val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA try &#123; cameraProvider.unbindAll() cameraProvider.bindToLifecycle( context as androidx.lifecycle.LifecycleOwner, cameraSelector, preview, videoCapture ) &#125; catch (exc: Exception) &#123; Log.e(&quot;CameraViewModel&quot;, &quot;Use case binding failed&quot;, exc) &#125; detectMotionAndRecord(context) // Start detecting motion and recording &#125;, ContextCompat.getMainExecutor(context)) cameraExecutor = Executors.newSingleThreadExecutor() &#125; private fun detectMotionAndRecord(context: Context) &#123; var prevFrame: ImageProxy? = null val handler = Handler(Looper.getMainLooper()) val delayMillis = 100L val captureRunnable = object : Runnable &#123; override fun run() &#123; if (isRecording.value) &#123; recording?.stop() isRecording.value = false &#125; // Capture frame videoCapture?.takePicture(cameraExecutor, ContextCompat.getMainExecutor(context), object : ImageCapture.OnImageCapturedCallback() &#123; override fun onCaptureSuccess(image: ImageProxy) &#123; if (prevFrame == null) &#123; prevFrame = image &#125; else &#123; // Compare frames val isDifferent = compareFrames(prevFrame!!, image) prevFrame?.close() prevFrame = image if (isDifferent) &#123; if (!isRecording.value) &#123; startRecording(context) isRecording.value = true &#125; &#125; else &#123; if (System.currentTimeMillis() - recordingStartTime &gt; 5000) &#123; recording?.stop() isRecording.value = false &#125; &#125; &#125; handler.postDelayed(this, delayMillis) &#125; override fun onError(exception: ImageCaptureException) &#123; Log.e(&quot;CameraViewModel&quot;, &quot;Image capture failed&quot;, exception) &#125; &#125;) &#125; &#125; handler.post(captureRunnable) &#125; private var recordingStartTime = 0L private fun compareFrames(frame1: ImageProxy, frame2: ImageProxy): Boolean &#123; // Implement frame comparison logic (e.g., by comparing pixel values) return true // example return, implement actual comparison &#125; private fun startRecording(context: Context) &#123; val fileName = SimpleDateFormat(&quot;yyyyMMdd_HHmmss&quot;, Locale.US) .format(System.currentTimeMillis()) + &quot;.mp4&quot; val file = File(context.externalMediaDirs.first(), fileName) val outputOptions = VideoCapture.OutputFileOptions.Builder(file).build() recordingStartTime = System.currentTimeMillis() videoCapture?.startRecording( outputOptions, ContextCompat.getMainExecutor(context), object : VideoCapture.OnVideoSavedCallback &#123; override fun onVideoSaved(outputFileResults: VideoCapture.OutputFileResults) &#123; val savedUri = Uri.fromFile(file) previewUri.value = savedUri uploadToFTP(file) &#125; override fun onError(videoCaptureError: Int, message: String, cause: Throwable?) &#123; Log.e(&quot;CameraViewModel&quot;, &quot;Video capture failed: $message&quot;, cause) &#125; &#125;) &#125; private fun uploadToFTP(file: File) &#123; viewModelScope.launch(Dispatchers.IO) &#123; FTPUpload.uploadFile( file.path, &quot;192.168.10.100&quot;, 21, &quot;yyy&quot;, &quot;xxx&quot; ) &#125; &#125; &#125; 创建UI在MainActivity.kt中设置UI： import android.Manifest import android.os.Bundle import androidx.activity.ComponentActivity import androidx.activity.compose.setContent import androidx.activity.result.contract.ActivityResultContracts import androidx.activity.viewModels import androidx.compose.foundation.layout.* import androidx.compose.material.* import androidx.compose.runtime.collectAsState import androidx.compose.runtime.remember import androidx.compose.ui.Modifier import androidx.compose.ui.unit.dp import androidx.core.content.ContextCompat import com.google.accompanist.permissions.ExperimentalPermissionsApi import com.google.accompanist.permissions.rememberMultiplePermissionsState import com.google.accompanist.permissions.shouldShowRationale import java.util.* class MainActivity : ComponentActivity() &#123; private val cameraViewModel: CameraViewModel by viewModels() override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContent &#123; JetpackComposeCameraTheme &#123; Surface(modifier = Modifier.fillMaxSize()) &#123; val context = remember &#123; this &#125; val permissionState = rememberMultiplePermissionsState( permissions = listOf( Manifest.permission.CAMERA, Manifest.permission.RECORD_AUDIO, Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_EXTERNAL_STORAGE ) ) if (permissionState.allPermissionsGranted) &#123; CameraPreview(cameraViewModel) &#125; else &#123; Column( Modifier .fillMaxSize() .padding(16.dp) ) &#123; Text(&quot;Permissions need to be granted to use the camera&quot;) Spacer(modifier = Modifier.height(8.dp)) if (permissionState.shouldShowRationale) &#123; Text(&quot;Please allow the permissions.&quot;) &#125; else &#123; OutlinedButton(onClick = &#123; permissionState.launchMultiplePermissionRequest() &#125;) &#123; Text(&quot;Allow&quot;) &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; @Composable fun CameraPreview(cameraViewModel: CameraViewModel) &#123; val context = LocalContext.current val isRecording = cameraViewModel.isRecording.collectAsState() Column(modifier = Modifier.fillMaxSize()) &#123; Box(modifier = Modifier .weight(1f) .fillMaxSize()) &#123; AndroidView( factory = &#123; ctx -&gt; val previewView = PreviewView(ctx) cameraViewModel.startCamera(ctx, previewView) previewView &#125;, modifier = Modifier.fillMaxSize() ) &#125; Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.Center) &#123; Button(onClick = &#123; /* Trigger cameraViewModel logic here */ &#125;, modifier = Modifier.padding(16.dp)) &#123; Text(&quot;Start Recording&quot;) &#125; Button(onClick = &#123; /* Trigger cameraViewModel logic here */ &#125;, modifier = Modifier.padding(16.dp)) &#123; Text(&quot;Stop Recording&quot;) &#125; &#125; &#125; &#125; 实现FTP上传功能创建FTPUpload.kt以实现FTP上传功能： import org.apache.commons.net.ftp.FTP import org.apache.commons.net.ftp.FTPClient import java.io.File import java.io.FileInputStream import java.io.IOException object FTPUpload &#123; fun uploadFile(filePath: String, server: String, port: Int, user: String, pass: String) &#123; val ftpClient = FTPClient() try &#123; ftpClient.connect(server, port) ftpClient.login(user, pass) ftpClient.enterLocalPassiveMode() ftpClient.setFileType(FTP.BINARY_FILE_TYPE) val dateFolder = SimpleDateFormat(&quot;yyyyMMdd&quot;, Locale.US).format(System.currentTimeMillis()) ftpClient.makeDirectory(dateFolder) ftpClient.changeWorkingDirectory(dateFolder) val firstRemoteFile = File(filePath).name val inputStream = FileInputStream(filePath) println(&quot;Start uploading first file&quot;) val done = ftpClient.storeFile(firstRemoteFile, inputStream) inputStream.close() if (done) &#123; println(&quot;File is uploaded successfully.&quot;) &#125; &#125; catch (ex: IOException) &#123; ex.printStackTrace() &#125; finally &#123; try &#123; if (ftpClient.isConnected) &#123; ftpClient.logout() ftpClient.disconnect() &#125; &#125; catch (ex: IOException) &#123; ex.printStackTrace() &#125; &#125; &#125; &#125; 通过这些代码片段，可以使用Jetpack Compose开发一个能够通过手机后置主摄像头录制视频、检测画面差异、实时预览并将视频上传至FTP服务器的Android应用。","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"Android 常用框架集合","slug":"categories/Android/Android常用框架集合","date":"2024-06-16T06:30:40.000Z","updated":"2024-07-16T08:25:27.130Z","comments":true,"path":"2024/06/16/categories/Android/Android常用框架集合/","link":"","permalink":"https://visen123.github.io/2024/06/16/categories/Android/Android%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%E9%9B%86%E5%90%88/","excerpt":"","text":"Jetpack(MVVM)MVVMHabit 于谷歌最新AAC架构，MVVM设计模式的一套快速开发库。binding-collection-adapter 数据绑定框架将集合绑定到列表视图。data-binding-recyclerview Recyclerview数据绑定框架。FlowBinding 受RxBinding启发， Kotlin Flow 绑定 API 和未捆绑的 UI 小部件。ViewBindingKTX 最全面的 ViewBinding 工具，支持 Kotlin 和 Java 用法。 网络Retrofit 适用于Android和Java的类型安全的HTTP客户端（API）。OkHttp 针对Java和Kotlin精心打造的HTTP客户端(API)。Volley Volley是一个HTTP库，可以使Android应用程序的联网更加轻松，它可以更快地联网(文章)。AsyncHttpClient 该框架已过时（API）。 图片Glide 一个快速高效的Android图片加载库（API）。glide-transformations 一个Android转换库，为Glide提供了各种图像转换。Picasso 强大的Android图片下载和缓存库。picasso-transformations 一个Android转换库，为Picasso提供了各种图像转换。Fresco 一个功能强大的系统，可在Android应用程序中显示图像（API）。fresco-processors 一个Android图像处理器库，为Fresco提供了各种图像转换。coil 由 Kotlin 协程支持的 Android 图像加载。Universal-Image-Loader 该框架已过时。Android-gif-drawable Gif 加载框架。CircleImageView 圆角ImageView。PhotoView ImageView的实现，支持通过各种触摸手势进行缩放。uCrop 一款优雅的图片裁剪框架。Luban 最接近微信的图片压缩框架。Compressor 一个轻巧而强大的android图像压缩库。Android-gpuimage 图像滤镜框架。 视频播放Ijkplayer 是Bilibili发布的基于 FFplay 的轻量级 Android/iOS 视频播放器。实现了跨平台功能，API 易于集成。饺子（节操）视频播放器 节操视频播放器是一个让开发者可以三两行代码就能集成到应用中的视频播放框架。GSYVideoPlayer 基于IJKPlayer（兼容系统MediaPlayer与EXOPlayer2），实现了多功能的视频播放器。ExoPlayer 一个开源的，App等级的媒体API。PLDroidPlayer 七牛推出的一款免费的适用于 Android 平台的播放器 SDK。MD360Player4Android 这是一个精简库，可为Android渲染360度全景视频。DanmakuFlameMaster 开源弹幕引擎·烈焰弹幕使 ～。PreviewSeekBar 适用于显示视频预览的SeekBar。 轮播图。Banner 一个可以自定义的轮播容器，不侵入UI。MZBannerView 图片轮播控件,支持多种模式切换：普通ViewPager使用，普通Banner使用，仿魅族Banner使用。ViewPagerHelper 能够帮你快速实现导航栏轮播图（适配AndroidX）。BGABanner 引导界面滑动导航 + 大于等于1页时无限轮播 + 各种切换动画轮播效果。UltraViewPager 是ViewPager扩展，它封装了多个功能，主要是为多页切换方案提供统一的解决方案。Roll3DImageView 一个实现图片3D翻转的自定义view,包含四种3D翻转的效果以及一种2D平移效果。MagicViewPager 单页显示3个Item的ViewPager炫酷切换效果，适用于Banner等。BulletinView 万能的公告栏轮播 View，也可用于商品个性垂直轮播展示。 RecyclerView框架BRVAH 一个强大的RecyclerAdapter框架（API）。Recyclerview-animators 允许开发人员轻松创建带有动画的RecyclerView。Epoxy 用于在RecyclerView中构建复杂的屏幕。MultiType 使创建多种类型的RecyclerView变得更加容易和灵活。TreeRecyclerView 基于RecycleView封装的树形列表。sticky-headers-recyclerview 基于RecycleView的粘性头回收视图。StickyHeaders 适用于RecyclerView的适配器和LayoutManager，可实现粘性标头定位(支持AndroidX)。StickyHeaders 轻松将粘性页眉添加到您的RecyclerView(支持AndroidX)。vlayout 功能强大的LayoutManager扩展。GravitySnapHelper 将RecyclerView捕捉到边缘。 骨架屏Skeleton 该库提供了一种简单的方法来显示骨架加载视图。ShimmerRecyclerView 具有闪烁视图的自定义回收器视图，指示正在加载视图。Spruce-android 一个轻量级动画库，可帮助编排屏幕上的动画。 动画Material-Animations 安卓转场动画演示。AndroidViewAnimations 安卓视图动画合集。Transitions-Everywhere 一款教你正确使用Transitions API（Android 转场动画API）。 图表库MPAndroidChart 一款功能强大且易于使用的Android图表库（文章、文章）。hellocharts Android的图表/图形库，多种图表类型均支持缩放，滚动和动画。WilliamChart 可在Android应用程序中快速开发有吸引力且有见地的图表。KChartView 股票k线图。android-kline Android版K线图和分时图。XCL-Charts 国人出品， 图表控件，种类很多。Android-Charts 国人实现的图表控件。SmartTable 一款android自动生成表格框架。AdaptiveTableLayout 可以读取，编辑和写入CSV文件的库。TableView 用于显示复杂的数据结构并呈现由行，列和单元格组成的表格数据。RX系列RxJava 事件驱动的基于异步数据流的编程模式（API）。RxAndroid 一款Android客户端组件间异步通信的框架（API）。RxBinding 一款提供UI组件事件响应能力的框架(文章、文章)。RxKotlin Kotlin 的 RxJava 绑定。Agera 谷歌开发的安卓反应式编程框架。 事件总线otto 事件总线框架，不推荐使用，而推荐使用RxJava和 RxAndroid。EventBus 适用于Android和Java的发布/订阅事件总线（API）。 图片选择器PictureSelector 适用于Android或图片选择器的图片选择器库（API）。EasyPhotos 有拼图/文字贴纸/贴图/图片缩放/水印/图片编辑功能的图片选择器库。Matisse 知乎开源的图片选择器。BGAPhotoPicker Android 图片选择、预览、九宫格图片控件、拖拽排序九宫格图片控件。Android-FilePicker 图片 / 文件选择器。 弹框material-dialogs 流畅且可扩展的对话框API。Android-AlertView 仿iOS的AlertViewController。FlycoDialog 强大的Android对话框库内置常用Dialog。 二维码Scankit 华为二维码扫描服务（文章）。BGAQRCode-Android QRCode 扫描二维码、扫描条形码、支持微博微信 QQ 二维码扫描样式。 热修复、插件化、组件化Bugly 微信Android热补丁解决方案(官网)。Sophix 阿里移动热修复(官网)。Robust 无差别兼容Android2.3-10版本，无需重启补丁实时生效，补丁修补成功率高达99.9%。RePlugin 灵活、稳定、易用的 Android 插件框架(官网)。Shadow 零反射全动态Android插件框架。Qigsaw 是基于Android App Bundles实现的 Android 动态组件化方案，它不需要重新安装实时动态分发插件。VirtualXposed 在非ROOT环境下运行Xposed模块的实现（支持5.0~10.0)。Atlas 淘宝推出的组件化开发框架。 选择器Android-PickerView 一款仿iOS的PickerView控件，有时间选择器和选项选择器（API）。DropDownMenu 下拉式菜单的筛选器。 权限处理PermissionX 一个开源的 Android 库，可以非常轻松地处理运行时权限(文章)。AndPermission Android 平台的权限管理器。HiPermission 一个简单易用的漂亮权限申请库。RxPermissions 一款基于RxJava完成权限申请的框架。 TextView框架SuperTextView 一个强大的TextView框架（文章）。html-textview 显示简单的HTML。SlantedTextView 倾斜的标签TextView。labelview 贴纸效果，如：淘宝商品侧贴折扣。ExpandableTextView 自定义可以动态展开/收缩显示长文本的TextView（文章）。Titanic 可以显示水位上升下降的TextView。TextLayoutBuilder 一个Android库，可让您更轻松地构建文本布局。 数据库框架Realm 一款移动端数据库框架（文档）。greenDAO 一款高效、快速的SQLite型数据库（文档）。sugar 用超级简单的方法处理Android数据库。 WebView框架VasSonic 专注于提升H5首屏加载速度。JsBridge java和javascript桥，灵感来自微信webview jsbridge。AgentWeb 基于Android WebView的功能强大的库。 字体Android-Iconics 在应用中使用任何可绘制的图标字体或矢量。Calligraphy 一款自定义字体框架。android-typeface-helper Android字体助手。FontsManager 字体管理器，方便快速的为应用内所有组件更换字体。 换肤Android-skin-support 换肤框架。Skinnable 东方证券Android换肤Project。 刷新加载框架SmartRefreshLayout 强大的智能下拉刷新框架。 高斯模糊，毛玻璃Blurry 好用的简易模糊库。Android-stackblur 可以基于渐变或半径对位图执行模糊效果，并返回结果。Blurkit-android 一个非常易于使用和高性能的，可在Android中渲染实时模糊效果。BlurView 类似于Android的基础View的动态iOS样模糊。 Log框架Logger 简单，漂亮，强大的Android日志工具。Timber 一个小的，可扩展的日志工具。 测试框架mockito Java编写的Mocking单元测试框架。robotium Android UI 测试。robolectric Android单元测试框架。 UI框架ViewPagerIndicator 指示器小部件。AndroidSwipeLayout 侧滑删除，功能强大的swipe布局。FlycoTabLayout 具有3个样式的TabLayout。FlycoLabelView 一个简单的Android标签控件。StickyListHeaders 可轻松将吸顶布局集成到ListView。ShapeOfView 为任何android视图赋予自定义形状。ArcLayout 圆弧形弧布局，借助Arc Layout探索材料设计的新样式和方法。MagicMirror 提供多种常用形状，基于蒙版图的任意形状及常用滤镜的自定义ImageView。ArcLayout 超酷的弧形布局菜单。EasyFlipView 快速简便的翻转视图，通过它可以创建带有信用卡，扑克牌等两面的视图。android-flip 可以实现类似Flipboard一样的翻页效果。AndroidSlidingUpPanel 拖动的View，能在当前Activity上扶起一个可拖动的Panel。Grav 粒子动画效果，可让您基于点制作多个动画。Viewbadger 为其他View添加角标等。FanLayoutManager 风扇扇叶旋转效果列表。android-viewbadger 能够快速的为Android 视图加入“勋章”能力的框架。BadgeView 支持自由定制外观、拖拽消除。InfiniteCycleViewPager 具有双向定位和交互效果，可以水平和垂直滚动。StickyHeaderListView 打造炫酷列表之-标题渐变、吸附悬浮、筛选分类、动态头部等。StikkyHeader 可让您将标题粘贴到ListView并轻松对其应用动画。SwitchButton 一个美观，轻巧，易于定制的Android开关小部件。SpringIndicator 使用bezier实现粘连效果的页面指示。NumberProgressBar 个简约性感的数字进度条。Spotlight 可以点亮教程或演练等的项目，引导。SwipeStack 自定义且易于使用的可滑动视图堆栈。CardSwipeLayout 模仿探探卡片滑动效果的布局。TicketView 圆角和扇贝形角的android中实现TicketView。CalendarView 个优雅、万能自定义UI、支持周视图、自定义周起始、性能高效的日历控件，支持热插拔实现的UI定制。SecurityKeyboard 东方证券安全键盘。orientui 东方证券Android的UI组件库。MultipleStatusView 一个支持多种状态的自定义View,可以方便的切换到：加载中视图、错误视图、空数据视图、网络异常视图、内容视图。StatusLayoutManager 切换不同的数据状态布局，包含加载中、空数据和出错状态，可自定义状态布局。Android-AlertView 仿iOS的AlertViewController。其他QMUI 提高 Android UI 开发效率的 UI 库(官网)。android-ui 精选的Android UI / UX库的精选列表。ImmersionBar android 4.4以上沉浸式实现。StatusBarUtil 设置状态栏的工具库。Richeditor-android 一个美丽的富文本编辑器。AndroidAutoSize 今日头条屏幕适配方案终极版，一个极低成本的 Android 屏幕适配方案。XhsEmoticonsKeyboard 最良心的开源表情键盘解决方案。Recovery 崩溃恢复框架。CustomActivityOnCrash 崩溃处理。SuperCleanMaster 一键清理 开源版，包括内存加速，缓存清理，自启管理，软件管理等。FileDownloader 文件下载引擎。tess-two Android 图片文字识别。ExplosionField 爆炸性粉尘效果。WaveLoading 波浪状加载效果。ShortcutBadger Android 应用角库（文章）。AndroidPdfViewer PDF阅读器。Logger 一款让log日志优雅显示的框架。dagger 一款通过依赖注入降低程序间耦合的开发框架。Apktool 一款反编译apk的工具。DiskLruCache 一款提供磁盘文件缓存管理能力的框架。conceal 一款facebook提供的加密本地大文件的框架。Keyframes 一个用于将基于Adobe AE形状的动画转换为数据格式并在Android和iOS设备上播放的库。JKeyboardPanelSwitch Android键盘面板冲突 布局闪动处理方案。WaveView 显示波效果的视图。Vorolay VoronoiView是一个视图（ViewGroup），允许您在Voronoi图区域内添加和显示视图。TextDrawable 这个轻量级的库提供带有字母/文本的图像。autofittextview ，它会自动调整文本大小以使其完全适合其边界。android-ripple-background 适用于您应用的精美波纹动画。BluetoothSocket 此库可以方便的帮你使用经典蓝牙做socket 通讯。EasyNavigation 几行代码实现Tab导航（随意定制加号、带红点消息提示、高度定制、支持ViewPager2。MMKV 微信开发的高效，小型移动键值存储框架。jadx Dex到Java反编译器。Cactus 安卓保活，Cactus 集成双进程前台服务，JobScheduler，一像素，WorkManager，无声音乐。watermark-android 加文字水印 支持配置文字大小，倾斜角度，多行水印。soter 腾讯开源, 在Android设备上实现可信的指纹认证。MusicIndicator Android音乐指示器。易于使用。VRPlayer 一个简单但功能强大的本地VR视频播放器。AndServer Android平台的Web服务器和Web框架(文章)。SwipeCaptcha Android 平台的滑动验证码。CombineBitmap 仿钉钉、微信 群聊组合头像。excelPanel Android的二维RecyclerView。不仅可以加载历史数据，还可以加载将来的数据。XUpdate 一个轻量级、高可用性的Android版本更新框架。AndroidPdfViewer 用于显示使用PdfiumAndroid渲染的PDF。MagicIndicator 强大、可定制、易扩展的 ViewPager 指示器框架。NineGridView 展示图片的九宫格控件。 开源项目cocoachina 开发者成长社区。SeeWeather 是一款遵循 Material Design 风格的只看天气的APP。EffectiveAndroidUI 一款讲解高效展示UI的教学型App。u2020 款提供Dagger的高级教学示例的app。androidmvp 一款展示Android端Mvp设计的demo。C9MJ 个人练手项目(新闻 + 视频直播)： 基于 MVP。WeChatLuckyMoney 微信抢红包插件。bilibili-android-client 仿哔哩哔哩客户端。MVPArms 一个整合了大量主流开源项目高度可配置化的 Android MVP 快速集成框架。HighPerformanceFriendsCircle 实现高性能微信朋友圈。AnchorImageView 支持给图片加锚点的 Android 组件。Isometric Android 透视三维体效果实现","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"Android最流行的网络请求框架Retrofit","slug":"categories/Android/Android最流行的网络请求框架Retrofit","date":"2024-05-22T08:36:48.000Z","updated":"2024-07-16T08:32:20.618Z","comments":true,"path":"2024/05/22/categories/Android/Android最流行的网络请求框架Retrofit/","link":"","permalink":"https://visen123.github.io/2024/05/22/categories/Android/Android%E6%9C%80%E6%B5%81%E8%A1%8C%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%A1%86%E6%9E%B6Retrofit/","excerpt":"","text":"在日常的Android开发,我们经常要获取网络上的数据，最常用的两种请求方式-GET POST，对自己的Project进行数据更新.安卓为我们提供了一个流行的网络请求框架—Retrofit.那什么是Retrofit呢? Retrofit实际上是对OkHttp的一个封装,底层请求网络利用的还是OkHttp,经过Retrofit的封装,可以使网络请求变得更加简便,只需要利用相应的Retrofit的注解,就可以进行对网络的访问. 那么,要怎样使用retrofit呢?话不多说,直接上代码. 先引入相应的依赖 implementation &#39;com.google.code.gson:gson:2.8.0&#39;(gson生成和解析库) implementation &#39;com.squareup.okhttp3:okhttp:3.9.1&#39;(开源的网络请求库) implementation &#39;com.squareup.okhttp3:logging-interceptor:3.9.1&#39;(支持okhttp跟踪到一个网络请求的所有状态，包括请求头、请求体、响应行、 响应体,方便调试) implementation &#39;com.squareup.retrofit2:retrofit:2.3.0&#39;(实现将HTTP请求转换为Java接口) implementation &#39;com.squareup.retrofit2:adapter-rxjava:2.1.0&#39;(配合Rxjava 使用) implementation &#39;com.squareup.retrofit2:converter-gson:2.1.0&#39;(转换器，请求结果转换成Model) implementation &#39;io.reactivex:rxandroid:1.2.1&#39; implementation &#39;io.reactivex:rxjava:1.2.1&#39;(一种帮助你做异步的框架. 类似于 AsyncTask. 但其灵活性和扩展性远远强于前者. 从能力上讲, 如果说 AsycnTask 是 DOS 操作系统, RxJava 是 Window 操作系统。 封装Retrofit import retrofit2.Retrofit; import retrofit2.adapter.rxjava3.RxJava3CallAdapterFactory; import retrofit2.converter.gson.GsonConverterFactory; public class RetrofitClient &#123; private static volatile RetrofitClient mInstance; private Retrofit retrofit; private static final String BASE_URL=&quot;修改自己的请求地址&quot;; //此处是网络请求的基本url,便于后续加入url的参数,请求不一样的数据,需要从开发者文档中查询 private RetrofitClient()&#123; &#125; public static RetrofitClient getInstance() &#123; if(mInstance==null)&#123; //如果该类对象为空,则创建各类对象 synchronized (RetrofitClient.class)&#123; //锁,防止线程问题 if(mInstance==null)&#123; mInstance=new RetrofitClient(); &#125; &#125; &#125; return mInstance; //返回该类对象,此方法用于外界调用 &#125; //创建RetrofitClient对象后调用,参数传对应的Service,即可调用Service中的方法,Service在下文会讲到 public &lt;T&gt; T getService(Class&lt;T&gt; cls)&#123; return getRetrofit().create(cls); &#125; //私有方法,在外界调用getService的时候,如果retrofit为空,则创建对象 private synchronized Retrofit getRetrofit() &#123; if(retrofit==null)&#123; retrofit = new Retrofit.Builder().baseUrl(BASE_URL) .addConverterFactory(GsonConverterFactory.create()) //添加Gson转化器,方便数据转为JavaBean .addCallAdapterFactory(RxJava3CallAdapterFactory.create()) //添加Rxjava适配器 .build(); //创建 &#125; return retrofit; //返回retrofit &#125; &#125; 创建对应的Service public interface Service &#123; @GET(&quot;get&quot;) //这里是基本网址拼接上GET中的字符串 //Flowable: 自动转化器,会将服务器响应的数据自动转化为标准的JavaBean //JavaBean需要自己写,可以通过bejson工具自动生成 //GET请求传参数需要加入@Query注解,参数会以拼接的方式连接起来 //示例: username=?&amp;password=? //基本用法,还有更多注解在这里就不一一介绍 Flowable&lt;JavaBean&gt; get(@Query(&quot;username&quot;) String username, @Query(&quot;password&quot;) String password); @POST(&quot;post&quot;) @FormUrlEncoded //表示请求体是一个Form表单 //post传递单个参数需要加入@Field注解 //示例: username=?&amp;password=? //post请求如需传入一段json数据,可以将一个map传入,然后加上@Body注解,底层会将map自动转化为json数据 Flowable&lt;JavaBean&gt; post(@Field(&quot;username&quot;) String username, @Field(&quot;password&quot;) String password); &#125; 在Activity中进行网络请求 import androidx.appcompat.app.AppCompatActivity; import android.util.Log; public class MainActivity extends AppCompatActivity &#123; private String TAG=&quot;tag&quot;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //retrofit请求网络是异步请求 RetrofitClient.getInstance. getService(Service.class). get(&quot;111&quot;,&quot;111&quot;) //此处参数应由用户传输进来 .subscribeOn(Schedulers.io()) //利用io线程进行网络请求 .observeOn(AndroidSchedulers.mainThread()) //请求回调到Android主线程 .subscribe(new Consumer&lt;JavaBean&gt;() &#123; //提交请求 @Override public void accept(JavaBean bean) throws Throwable &#123; //请求成功,返回的json数据被Gson转化为JavaBean //如果进到此方法,则网络请求成功 Log.d(TAG, &quot;accept1: &quot;+bean);//此处在控制台打印请求返回的结果 &#125; &#125;, new Consumer&lt;Throwable&gt;() &#123; @Override public void accept(Throwable throwable) throws Throwable &#123; //如果进到此方法,则网络请求失败 Log.d(TAG, &quot;accept2: &quot;+throwable);//此处在控制台打印请求失败的异常 &#125; &#125;); &#125; &#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"javaspringboot实现上传文件接口","slug":"categories/后端/SpringBoot开源项目","date":"2023-12-26T09:50:13.000Z","updated":"2024-07-16T10:21:00.007Z","comments":true,"path":"2023/12/26/categories/后端/SpringBoot开源项目/","link":"","permalink":"https://visen123.github.io/2023/12/26/categories/%E5%90%8E%E7%AB%AF/SpringBoot%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"Spring Boot 算是目前 Java 领域最火的技术栈了，也是 Java 开发人员不得不掌握的技术，整理了 19 个优质 Spring Boot 开源项目，希望能够帮助到正在学习 Spring Boot 的小伙伴！简历中添加这些项目绝对是亮点的。 1.SPTools 一个基于SpringBoot、JPA、Shiro的后台管理系统，单体架构，依赖少，极易上手，后端开发的福利。最重要的是还附带免费小程序以及微服务版本，可自行选择。 内置功能 组织机构：机构管理、用户管理、角色管理、行政区域。 系统监控：系统日志、在线用户，后期会慢慢追加完善。 应用管理：任务调度、邮件管理、图片管理、文章管理、打卡任务、数据查询、人工智能，每个模块只需要你稍作修改就可以打造成一个项目了。 系统管理：敏捷开发、系统菜单、全局配置、在线代码编辑器，小伙伴们只需要设计好表结构，三秒钟就能撸出一个增删查改的模块。 项目地址：小柒2012/SPAdmin 2.web-flash 基于Spring Boot+Vue的后台管理系统,权限管理，字典，配置，定时任务，短信，邮件，根据excel模板导出，cms内容管理，手机端h5，IDEA 代码生成插件。 项目地址：enilu/web-flash 3.mall4j 一个基于spring boot、spring oauth2.0、mybatis、redis的轻量级、前后端分离、防范xss攻击、拥有分布式锁，为生产环境多实例完全准备，数据库为b2b2c设计，拥有完整sku和下单流程的完全开源商城。 项目致力于为中小企业打造一个完整、易于维护的开源的电商系统，采用现阶段流行技术实现。后台管理系统包含商品管理、订单管理、运费模板、规格管理、会员管理、运营管理、内容管理、统计报表、权限管理、设置等模块。 项目地址：Mall4j商城系统/Mall4j商城 java商城 电商商城系统 4.Timo TIMO后台管理系统，基于SpringBoot2.0 + Spring Data Jpa + Thymeleaf + Shiro 开发的后台管理系统，采用分模块的方式便于开发和维护，支持前后台模块分别部署，目前支持的功能有：权限管理、部门管理、字典管理、日志记录、文件上传、代码生成等，为快速开发后台系统而生的脚手架！ 技术选型 后端技术：SpringBoot + Spring Data Jpa + Thymeleaf + Shiro + Jwt + EhCache 前端技术：Layui + Jquery + zTree + Font-awesome 项目地址：小懒虫/Timo 5.litemall 又一个小商场系统，Spring Boot后端 + Vue管理员前端 + 微信小程序用户前端 + Vue用户移动端。 项目地址：linlinjava/litemall 6.SmartAdmin 我们开源一套漂亮的代码和一套整洁的代码规范，让大家在这浮躁的代码世界里感受到一股把代码写好的清流！同时又让开发者节省大量的时间，减少加班，快乐工作，热爱生活。SmartAdmin 让你从认识到忘不了，绝对是你最想要的！ 项目地址：1024-lab/smart-admin 7、mallstar 数 12.7k，项目地址： https://github.com/macrozheng/mall mall 项目是一套电商系统，包括前台商城系统及后台管理系统，基于 SpringBoot+MyBatis 实现。前台商城系统包含首页门户、商品推荐、商品搜索、商品展示、购物车、订单流程、会员中心、客户服务、帮助中心等模块。 后台管理系统包含商品管理、订单管理、会员管理、促销管理、运营管理、内容管理、统计报表、财务管理、权限管理、设置等模块。","categories":[{"name":"后端","slug":"后端","permalink":"https://visen123.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"后端","slug":"后端","permalink":"https://visen123.github.io/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"javaspringboot实现上传文件接口","slug":"categories/后端/javaspringboot实现上传文件接口","date":"2023-09-19T02:00:13.000Z","updated":"2024-07-16T09:59:50.571Z","comments":true,"path":"2023/09/19/categories/后端/javaspringboot实现上传文件接口/","link":"","permalink":"https://visen123.github.io/2023/09/19/categories/%E5%90%8E%E7%AB%AF/javaspringboot%E5%AE%9E%E7%8E%B0%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"java springboot 实现上传文件接口在Spring Boot中实现文件上传接口，你可以使用@RestController和@PostMapping注解来创建一个控制器，并使用MultipartFile接口来接收上传的文件。以下是一个简单的例子： import org.springframework.web.bind.annotation.*; import org.springframework.web.multipart.MultipartFile; @RestController public class FileUploadController &#123; @PostMapping(&quot;/upload&quot;) public String handleFileUpload(@RequestParam(&quot;file&quot;) MultipartFile file) &#123; if (file.isEmpty()) &#123; return &quot;文件为空，请选择一个文件上传。&quot;; &#125; try &#123; // 获取文件名 String fileName = file.getOriginalFilename(); // 获取文件的字节 byte[] bytes = file.getBytes(); // 这里可以添加保存文件的逻辑，例如保存到磁盘或数据库 return &quot;文件上传成功：&quot; + fileName; &#125; catch (Exception e) &#123; return &quot;文件上传失败：&quot; + e.getMessage(); &#125; &#125; &#125; 确保你的Spring Boot应用已经配置了multipart文件上传的支持，在application.properties或application.yml中添加以下配置： application.properties spring.servlet.multipart.max-file-size=128KB spring.servlet.multipart.max-request-size=128KB 或者使用YAML格式： application.yml spring: servlet: multipart: max-file-size: 128KB max-request-size: 128KB","categories":[{"name":"后端","slug":"后端","permalink":"https://visen123.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"后端","slug":"后端","permalink":"https://visen123.github.io/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"springboot实现验证码功能","slug":"categories/后端/springboot实现验证码功能","date":"2023-08-22T07:00:13.000Z","updated":"2024-07-16T10:08:58.821Z","comments":true,"path":"2023/08/22/categories/后端/springboot实现验证码功能/","link":"","permalink":"https://visen123.github.io/2023/08/22/categories/%E5%90%8E%E7%AB%AF/springboot%E5%AE%9E%E7%8E%B0%E9%AA%8C%E8%AF%81%E7%A0%81%E5%8A%9F%E8%83%BD/","excerpt":"","text":"1、编写工具类生成4位随机数该工具类主要生成从0-9，a-z，A-Z范围内产生的4位随机数 /** * 产生4位随机字符串 */ public static String getCheckCode() { String base = “0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz”; int size = base.length(); Random r = new Random(); StringBuffer sb = new StringBuffer(); for (int i = 1; i &lt;= 4; i++) { //产生0到size-1的随机值 int index = r.nextInt(size); //在base字符串中获取下标为index的字符 char c = base.charAt(index); //将c放入到StringBuffer中去 sb.append(c); } return sb.toString(); }2、编写常量类用户常量的绑定，所有的常量都可以在ConfigConsts中定义，方便管理。 import java.util.Arrays;import java.util.List; public interface ConfigConsts { /** * 验证码存session */ String IMAGE_CODE_SESSION = “IMAGE_CODE”;}3、获取验证码接口这段代码的主要作用是为用户生成一个图片验证码，并将其显示在浏览器中。当调用该代码对应的URL时，服务器会创建一个包含随机验证码的图片，并将此验证码存储在用户的会话中，然后将该图片发送给用户的浏览器显示 /** * 验证码 */ @RequestMapping(&quot;/getImgCode&quot;) public void getImgCode(HttpServletRequest request, HttpServletResponse response) &#123; int width = 80; int height = 30; BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); //获取画笔 Graphics graphics = image.getGraphics(); //设置画笔颜色为白色 graphics.setColor(Color.white); //填充图片 graphics.fillRect(0, 0, width, height); //设置画笔颜色为黑色 graphics.setColor(Color.black); //设置字体的小大 graphics.setFont(new Font(&quot;黑体&quot;, Font.BOLD, 24)); //产生4个随机验证码 String checkCode = CommonUtil.getCheckCode(); //将验证码放入HttpSession中 HttpSession session = request.getSession(); session.setAttribute(ConfigConsts.IMAGE_CODE_SESSION, checkCode); //向图片上写入验证码 graphics.drawString(checkCode, 15, 25); //将内存中的图片输出到浏览器 try &#123; response.setContentType(&quot;image/png&quot;); ImageIO.write(image, &quot;PNG&quot;, response.getOutputStream()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 4、controller跳转到登录页对“/loginPage”的GET请求，并将用户重定向到登录页面。当调用这个URL时，系统会返回一个名为”login”的视图（通常是一个HTML页面），这个视图通常用于显示登录表单，让用户输入用户名和密码等信息。 /** * 跳转到登陆页面 * @return 登陆页面 */ @GetMapping(&quot;/loginPage&quot;) public String loginPage()&#123; return &quot;login&quot;; &#125; 5、登录界面在Web页面上实现一个图形验证码的输入功能 HTML部分：创建一个表单项，内部包含两列（使用layui的栅格系统）。在第一列中，有一个标签和一个文本输入框。标签用于显示一个验证码图标，输入框用于用户输入图形验证码。在第二列中，有一个图片元素用于显示图形验证码图片。JavaScript部分：配置layui的静态资源路径和主入口模块。初始化时，调用getImgCode函数加载验证码图片，并渲染表单。getImgCode函数通过Ajax请求从服务器获取验证码图片，并将其显示在页面上的图片元素中。这段代码主要利用了layui框架来实现页面的布局和交互，同时通过JavaScript和Ajax实现与服务器的通信，以获取并显示图形验证码。 &lt;img id=&quot;codeImg&quot; class=&quot;layadmin-user-login-codeimg&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; layui.config(&#123; base: &#39;/static/layuiadmin/&#39; //静态资源所在路径 &#125;).extend(&#123; index: &#39;lib/index&#39; //主入口模块 &#125;).use([&#39;index&#39;, &#39;user&#39;], function()&#123; let $ = layui.$, form = layui.form; // 初始化 getImgCode(); form.render(); &#125; /** * 获取验证码 */ function getImgCode() &#123; let url = ctx + &#39;/getImgCode&#39;; let xhr = new XMLHttpRequest(); xhr.open(&#39;GET&#39;, url, true); xhr.responseType = &quot;blob&quot;; xhr.onload = function() &#123; if (this.status === 200) &#123; let blob = this.response; document.getElementById(&quot;codeImg&quot;).src = window.URL.createObjectURL(blob); &#125; &#125; xhr.send(); &#125; &lt;/script&gt; 6、验证码过滤校验验证码的过滤器，基于Java的Spring框架。 该过滤器继承了OncePerRequestFilter，确保每次请求只被过滤一次。在doFilterInternal方法中，它首先检查请求是否是登录请求（通过检查请求路径是否为”/login”以及请求方法是否为”POST”）。如果是登录请求，它会调用validate方法来校验验证码。validate方法从请求中获取验证码，然后与会话中存储的验证码进行比对。如果验证码不存在、为空或不匹配，将抛出异常。如果验证码校验失败，过滤器会捕获异常，并向响应中写入错误信息（以JSON格式）。如果请求不是登录请求，过滤器不会进行验证码校验，直接让请求继续向下执行（通过调用filterChain.doFilter）。如果登录请求成功通过验证码校验，代码会继续执行后续的过滤器或处理器。@Componentpublic class ValidateCodeFilter extends OncePerRequestFilter { @Override protected void doFilterInternal(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain) throws ServletException, IOException { // 登陆请求 if (“/login”.equals(httpServletRequest.getServletPath()) &amp;&amp; “POST”.equalsIgnoreCase(httpServletRequest.getMethod())){ try { validate(httpServletRequest); } catch (Exception exception) { httpServletResponse.setCharacterEncoding(“utf-8”); httpServletResponse.setContentType(“application/json;charset=UTF-8”); PrintWriter writer = httpServletResponse.getWriter(); writer.write(JSON.toJSONString(Result.failure(exception.getMessage()))); writer.flush(); return; } } // 不是一个登录请求，不做校验 直接通过 filterChain.doFilter(httpServletRequest, httpServletResponse); } private void validate(HttpServletRequest request) &#123; String code = request.getParameter(&quot;code&quot;); if (StringUtils.isBlank(code))&#123; throw new RuntimeException(&quot;验证码不能为空&quot;); &#125; Object checkCode = request.getSession(false).getAttribute(ConfigConsts.IMAGE_CODE_SESSION); if (Objects.isNull(checkCode)) &#123; throw new RuntimeException(&quot;验证码不存在&quot;); &#125; if (!StringUtils.equalsIgnoreCase(code,checkCode.toString())) &#123; throw new RuntimeException(&quot;验证码不匹配&quot;); &#125; request.getSession(false).removeAttribute(ConfigConsts.IMAGE_CODE_SESSION); &#125; }7、集成mysecurity集成Spring Security的安全配置类，用于Web应用的安全性设置。 通过@EnableWebSecurity和@Configuration注解，启用并配置Spring Security。使用@EnableGlobalMethodSecurity(prePostEnabled = true)来启用全局方法级别的安全性，允许使用例如@PreAuthorize和@PostAuthorize等注解。定义了一个名为MySecurityConfig的配置类，该类继承自WebSecurityConfigurerAdapter，用于定制安全性设置。通过@Autowired注入了一个名为validateCodeFilter的验证码过滤器实例。在configure(HttpSecurity http)方法中，对应用的安全性进行了详细配置：允许所有人访问/loginPage和/getImgCode这两个路径，不进行任何安全检查。对所有其他请求，需要用户进行身份验证（即需要登录后才能访问）。在用户名和密码验证过滤器之前，添加了一个自定义的验证码过滤器（validateCodeFilter），用于在登录过程中校验验证码。这段代码的主要目的是增强Web应用的安全性，通过添加验证码校验来防止自动化登录尝试和暴力破解，并限制了只有经过身份验证的用户才能访问应用的受保护资源。 @Configuration@EnableWebSecurity@EnableGlobalMethodSecurity(prePostEnabled = true)public class MySecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private ValidateCodeFilter validateCodeFilter; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() // 放过 .antMatchers(&quot;/loginPage&quot;, &quot;/getImgCode&quot;).permitAll() .anyRequest().authenticated() .and() // 过滤登录验证码 .addFilterBefore(validateCodeFilter, UsernamePasswordAuthenticationFilter.class) &#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://visen123.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"后端","slug":"后端","permalink":"https://visen123.github.io/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"SpringBoot下载打包图片","slug":"categories/后端/SpringBoot下载打包图片","date":"2023-07-29T02:00:13.000Z","updated":"2024-07-16T10:22:03.184Z","comments":true,"path":"2023/07/29/categories/后端/SpringBoot下载打包图片/","link":"","permalink":"https://visen123.github.io/2023/07/29/categories/%E5%90%8E%E7%AB%AF/SpringBoot%E4%B8%8B%E8%BD%BD%E6%89%93%E5%8C%85%E5%9B%BE%E7%89%87/","excerpt":"","text":"现有需求：将若干图片从互联网下载，并打包成指定压缩包，返回给前端 实现功能前提，思考流程判断当前文件夹是否存在（防止上一次删除失败），存在则删除创建文件夹下载文件将文件打包将文件传输给前端删除文件第一步，前后端文件交互采用 HttpServletResponse 通过流来传输文件，具体接口定义为下面代码： @ApiOperation(value = &quot;导出图片&quot;, httpMethod = &quot;POST&quot;) @RequestMapping(value = &quot;/downloadImage&quot;, method = RequestMethod.POST, produces = &quot;application/json&quot;) public void downloadImage( @ApiParam(name = &quot;RequestVo&quot;, value = &quot;查询实体&quot;) @Validated @RequestBody RequestVo requestVo, HttpServletResponse response)&#123; log.info(&quot;检验数据表批量导出图片入参：&quot; + requestVo); service.batchDownloadImage(requestVo, response); &#125; 接口不需要定义返回值，当通过流传输的时候，就不会通过这边的返回来返回内容 确定了如何去和前端进行交互后，就需要书写与互联网交互的工具类 HttpUtil 第二步，网络交互 HttpUtil这里简单介绍一下要做的事情 通过 URL 下载文件到本地通过 URL 连接到对应网址，建立稳定连接后，获取连接的输入流，创建本地的输出流，通过输出流写到本地文件并命名将本地文件传输给前端具体实现：通过 response 获取 输出流，获取本地文件的输入流，读取到字节数组byte[]当中，通过输出流输出字节数组，即完成了传输工具类代码： package com.hwh.communitymanage.utils; import lombok.extern.slf4j.Slf4j; import javax.activation.MimetypesFileTypeMap;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.*;import java.net.URL;import java.net.URLConnection;import java.net.URLEncoder; /** @description: 网络文件下载工具类 @author: HWH @create: 2022-10-14 09:28 */ @Slf4jpublic class HttpUtil { /** * Http 下载文件到本地 * @param urlStr 下载文件地址 * @param path 存储全路径（包括名称） */ public static void downloadHttpFileToLocal(String urlStr, String path)&#123; try&#123; URL url = new URL(urlStr); URLConnection conn = url.openConnection(); InputStream inputStream = conn.getInputStream(); // 创建输出流 FileOutputStream outputStream = new FileOutputStream(path); int byteRead; byte[] buffer = new byte[1024]; while((byteRead = inputStream.read(buffer)) != -1)&#123; outputStream.write(buffer, 0, byteRead); &#125; // 关闭流 inputStream.close(); outputStream.close();; &#125;catch (Exception e)&#123; throw new RuntimeException(&quot;下载失败&quot;, e); &#125; &#125; /** * 传输文件流 * @param path 传输文件路径 * @param fileName 传输文件名称 * @param response http响应 * @return 是否成功传输 */ public static Boolean transferFileStream(String path, String fileName, HttpServletResponse response)&#123; if(path == null)&#123; log.error(&quot;文件路径不能为空&quot;); return false; &#125; File file = new File(path + File.separator + fileName); if(!file.exists())&#123; log.error(&quot;文件不存在&quot;); return false; &#125; long startTime = System.currentTimeMillis(); FileInputStream inputStream = null; BufferedInputStream bis = null; try&#123; // 设置头 setResponse(fileName, response); // 开启输入流 inputStream = new FileInputStream(file); bis = new BufferedInputStream(inputStream); // 获取输出流 OutputStream os = response.getOutputStream(); // 读取文件 byte[] buffer = new byte[1024]; int i; // 传输 while((i = bis.read(buffer)) != -1)&#123; os.write(buffer, 0, i); &#125; // 计时 long endTime = System.currentTimeMillis(); log.info(&quot;文件传输时间： &#123;&#125; ms&quot;, endTime - startTime); &#125;catch (Exception e)&#123; throw new RuntimeException(&quot;文件传输失败&quot;); &#125;finally &#123; try&#123; if(inputStream != null)&#123; inputStream.close(); &#125; if(bis != null)&#123; bis.close(); &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; return true; &#125; private static void setResponse(String fileName, HttpServletResponse response) throws UnsupportedEncodingException &#123; response.addHeader(&quot;Content-Disposition&quot;, &quot;attachment;fileName=&quot; + URLEncoder.encode(fileName, &quot;UTF-8&quot;));// 设置文件名 &#125; } 第三步，文件交互 FileUtil考虑： 对于下载的图片，需要根据不同的需求放到不同的文件夹当中，可以根据日期，也可以根据类型。所以需要一个文件夹创建的功能 并且有可能并发的情况下，由于文件的内容是在使用完后就要删除的，所以每个用户需要有专属的文件夹；还有单用户可能会发生并发的情况，可以考虑加上时间戳因此考虑到要实现的功能为 创建文件夹，包括父路径全部删除文件夹包括文件夹下所有的内容自我思考：当下载图片的并发可能会很大的时候，也就会涉及到服务器的IO频率高，可能会导致服务器处理不过来的情况 因此可以采用缓存的方式，文件不再是即刻删除，而是采用延时删除，例如消息队列中的延时队列，定时删除线程等等方式实现 但是也有弊端，存储空间可能会消耗大，并且要确定文件/文件夹的命中几率较高，才有实用的价值，不然就是白白增加了服务器的负担。 实现： 回到正题，如何实现现有的功能 创建文件夹，采用Files.createDirectories(Path path) 方法，就可以将本目录以及父目录全部创建完成删除文件夹，采用递归的方式，当是文件夹的时候，向下递归，知道遇到文件再删除，然后删除空文件夹下面贴出我的代码实现： package com.hwh.communitymanage.utils; import lombok.extern.slf4j.Slf4j; import java.io.File;import java.io.FileOutputStream;import java.io.InputStream;import java.io.OutputStream;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.util.UUID; /** @Author: HwH @Description: @Date: created in 15:38 2022/9/27 /@Slf4jpublic class FileUtil { /** 强制创建文件夹，连同父级同时创建，同时如果本层文件夹已存在，删除 @param pathStr 文件路径 /public static boolean makeDirAndParent(String pathStr){ // 如果存在，删除 File file = new File(pathStr); if(file.exists()){ deletedPath(pathStr); } try { // 创建父级及本级文件夹 Path path = Paths.get(pathStr); Files.createDirectories(path); }catch (Exception e){ throw new RuntimeException(&quot;创建文件夹失败&quot;); } return true;} /** 删除文件夹及文件夹下的文件 @param sourcePath 文件夹路径 @return 如果删除成功true否则false /public static boolean deletedPath(String sourcePath){ File sourceFile = new File(sourcePath); if(!sourceFile.exists()){ log.error(&quot;文件不存在, 删除失败&quot;); return false; } // 获取文件下子目录 File[] fileList = sourceFile.listFiles(); if(fileList != null) { // 遍历 for (File file : fileList) &#123; // 判断是否为子目录 if (file.isDirectory()) &#123; deletedPath(file.getPath()); &#125; else &#123; file.delete(); &#125; &#125; } sourceFile.delete(); return true;}} 第四步，压缩文件夹 ZipUtil这里为什么说是压缩文件夹而不是压缩文件，因为在我看来所有需要的文件和文件都在一个文件夹下面，可以是根目录，也可以是自定目录，比如：/image/123456，此时123456下全是图片，不管是文件夹还是文件，所以说这里只需要压缩一个自定的文件夹就足够了 具体的实现： 通过文件夹路径创建 File判断是否是文件夹（这里也可以做成非文件夹格式，写成通用的方式，也就不仅限于传文件夹了）获取文件夹下的内容fileList(因为当前文件夹是不需要打包的，所以会放到上层遍历)构建 ZipOutputStream 作为递归参数遍历 fileList，递归处理判断是文件，构建ZipEntry判断是文件夹，遍历递归递归完成，关闭流代码实现： package com.hwh.communitymanage.utils; import io.jsonwebtoken.lang.Collections;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value; import java.io.*;import java.util.List;import java.util.zip.ZipEntry;import java.util.zip.ZipOutputStream; /** @description: 压缩工具类 @author: HWH @create: 2022-10-14 10:21 */ @Slf4jpublic class ZipUtil { /** * 文件夹内容批量压缩 * @param sourcePath 文件夹路径列表(压缩后不包括该文件夹) * @param targetPath 存储路径路径 * @param zipName 压缩文件名称 * @return zip的绝对路径 */ public static boolean fileToZip(String sourcePath, String targetPath, String zipName)&#123; if(sourcePath == null || targetPath == null)&#123; log.error(&quot;文件夹路径/存放/文件名 不能为空, filePathList:&#123;&#125;, targetPath:&#123;&#125;&quot;, sourcePath, targetPath); return false; &#125; // 开始时间 long startTime = System.currentTimeMillis(); FileOutputStream fos = null; ZipOutputStream zos = null; try&#123; // 读取文件夹 File sourceFile = new File(sourcePath); if(!sourceFile.exists() || !sourceFile.isDirectory())&#123; log.error(&quot;文件夹不存在, sourceFile: &#123;&#125;&quot;, sourcePath); return false; &#125; // 获取文件夹下内容 File[] fileList = sourceFile.listFiles(); if(fileList == null || fileList.length == 0 )&#123; log.error(&quot;文件夹不能为空, sourceFile: &#123;&#125;&quot;, sourceFile); return false; &#125; // 开启输出流 fos = new FileOutputStream(targetPath + File.separator + zipName); zos = new ZipOutputStream(fos); // 遍历文件夹下所有 for(File file : fileList)&#123; compress(file, zos, file.getName()); &#125; // 结束时间 long end = System.currentTimeMillis(); log.info(&quot;文件压缩耗时：&#123;&#125; ms&quot;, end - startTime); &#125;catch (Exception e)&#123; throw new RuntimeException(&quot;文件压缩失败&quot;); &#125;finally &#123; // 关闭流 try&#123; if(zos != null)&#123; zos.close(); &#125; if(fos != null)&#123; fos.close(); &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; return true; &#125; /** * 递归文件压缩 * @param sourceFile 来源文件/文件夹 * @param zos 文件流 * @param name 名称 */ private static void compress(File sourceFile, ZipOutputStream zos, String name) throws IOException &#123; byte[] buffer = new byte[1024 * 1024]; // 文件 if(sourceFile.isFile())&#123; // 添加进压缩包 zos.putNextEntry(new ZipEntry(name)); BufferedInputStream bis = new BufferedInputStream(new FileInputStream(sourceFile)); int read; while((read = bis.read(buffer, 0, 1024)) != -1)&#123; zos.write(buffer, 0, read); &#125; zos.closeEntry(); bis.close(); &#125; // 文件夹 else&#123; // 获取文件夹下的文件 File[] fileList = sourceFile.listFiles(); // 空文件夹处理 if(fileList == null || fileList.length == 0)&#123; zos.putNextEntry(new ZipEntry(name + &quot;/&quot;)); zos.closeEntry(); &#125; // 非空，遍历递归向下处理 else&#123; for(File file : fileList)&#123; compress(file, zos, name + &quot;/&quot; + file.getName()); &#125; &#125; &#125; &#125; } 第五步，串联使用下面代码有用到属性注入，需要配置到 application.yml 中 imagePath: image1串联实现代码： private final String ZIP_SUFFIX = &quot;.zip&quot;; @Value(&quot;ImagePath&quot;) private String IMAGE_BASE_PATH; private boolean downloadImage(Request requestVo,List&lt;ImagePo&gt; urlList, HttpServletResponse response, boolean batch)&#123; if(urlList.isEmpty())&#123; throw new BusinessException(&quot;不存在相应信息&quot;); &#125; // 根目录 (基础路径/学号+时间戳) String basePath = IMAGE_BASE_PATH + File.separator + AppContext.getContext().getUserInfo().getStudentNum() + System.currentTimeMillis(); // 创建根目录文件夹 FileUtil.makeDirAndParent(basePath); // 压缩包名称 zipName = requestVo.getStartTime() + &quot;-&quot; + requestVo.getEndTime() + ZIP_SUFFIX; // 下载图片 /....这里一般会复杂些，移除掉了.../ HttpUtil.downloadHttpFileToLocal(url, imagePath); // 文件压缩 ZipUtil.fileToZip(basePath, zipName); // 文件传输 HttpUtil.transferFileStream(basePath, zipName, response); // 删除文件 FileUtil.deletedPath(basePath); return true; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://visen123.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"后端","slug":"后端","permalink":"https://visen123.github.io/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"SpringBoot 实现视频分段播放","slug":"categories/后端/SpringBoot 实现视频分段播放","date":"2023-06-23T08:00:13.000Z","updated":"2024-07-16T09:50:12.639Z","comments":true,"path":"2023/06/23/categories/后端/SpringBoot 实现视频分段播放/","link":"","permalink":"https://visen123.github.io/2023/06/23/categories/%E5%90%8E%E7%AB%AF/SpringBoot%20%E5%AE%9E%E7%8E%B0%E8%A7%86%E9%A2%91%E5%88%86%E6%AE%B5%E6%92%AD%E6%94%BE/","excerpt":"","text":"需求：现在我本地电脑中有一个文件夹，文件夹中都是视频，需要实现视频播放的功能。 问题：如果通过类似 SpringBoot static 文件夹的方式来实现，客户端要下载好完整的视频之后才可以播放，并且服务端也会占用大量宽带。所以这里考虑采取视频分段的方式进行下载，客户端播放视频时，可以通过进度条调节视频进度。 实现方法：在 SpringBoot 中支持自定义资源请求处理器，通过自定义的资源处理器来实现。 依赖：主要就是 SpringBoot 的相关依赖： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 编写一个自定义资源请求处理器，需要继承 ResourceHttpRequestHandler 重写 getResource() 方法。该自定义处理器还需要加上 @Component 注解。在案例中 getResource() 方法中，需要拿到对应的视频地址，通过 Controller 层的代码通过 request.setAttribute(“video-uri”, videoUri) 设置 video-uri 的 value，value 可以是视频的本地路径，也可以是视频的唯一标识，需要按照自己的业务来传值。 import org.springframework.core.io.FileSystemResource; import org.springframework.core.io.Resource; import org.springframework.stereotype.Component; import org.springframework.web.servlet.resource.ResourceHttpRequestHandler; import javax.servlet.http.HttpServletRequest; /** * @author 17279 */ @Component public class VideoResourceHttpRequestHandler extends ResourceHttpRequestHandler &#123; // 只需要重写 getResource 方法 @Override protected Resource getResource(HttpServletRequest request) &#123; // 这里的 videoUri 是在 Controller 中通过 request.setAttribute(&quot;video-uri&quot;, videoUri) 进来的值 String videoUri = (String) request.getAttribute(&quot;video-uri&quot;); // D:\\Downloads\\test.mp4 // 可以通过 videoUri 传递的值根据我们的业务查找对应的文件 return new FileSystemResource(videoUri); &#125; &#125; 编写 Controller 层代码： 这里通过 request.setAttribute(“video-uri”, videoUri) 添加 video-uri 的 value，自定义处理中通过这个 value 找到向前端返回的视频。 import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.servlet.resource.ResourceHttpRequestHandler; import javax.servlet.ServletException; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.nio.charset.StandardCharsets; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; /** * @author 17279 */ @RestController @RequestMapping(&quot;video&quot;) public class VideoController &#123; @Autowired private ResourceHttpRequestHandler resourceHttpRequestHandler; /** * @param fileName fileName 前端传递过来的视频文件名名称 */ @GetMapping(value = &quot;/&#123;fileName&#125;&quot;) public void video(@PathVariable(&quot;fileName&quot;) String fileName, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException &#123; // 视频文件根目录【换成实际的视频根目录】 final String videoBasePath = &quot;D:/Downloads/&quot;; // 视频根目录 + 文件名称，找到对应的文件 String videoUri = videoBasePath + fileName; Path videoPath = Paths.get(videoUri); if (Files.exists(videoPath)) &#123; // 如果找到视频，那么返回视频信息 String contentType = Files.probeContentType(videoPath); if (contentType != null &amp;&amp; !&quot;&quot;.equals(contentType)) &#123; response.setContentType(contentType); &#125; // video-path 主要是将视频的地址传递给自定义的资源处理器处使用 request.setAttribute(&quot;video-uri&quot;, videoUri); resourceHttpRequestHandler.handleRequest(request, response); &#125; else &#123; // 如果文件不存在，那么跳到 404 页面 response.setStatus(HttpServletResponse.SC_NOT_FOUND); response.setCharacterEncoding(StandardCharsets.UTF_8.toString()); &#125; &#125; &#125; 访问地址：http://localhost/video/test.mp4 访问效果：这里设置的视频跟目录是 D:/Downloads/，前端传递的 fileName 为 test.mp4，所以实际返回前端的文件为 D:/Downloads/test.mp4","categories":[{"name":"后端","slug":"后端","permalink":"https://visen123.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"后端","slug":"后端","permalink":"https://visen123.github.io/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"Java SpringBoot集成onlyoffice实现word文档编辑保存","slug":"categories/后端/JavaSpringBoot实现文档编辑保存","date":"2023-06-17T05:36:13.000Z","updated":"2024-07-16T10:18:05.164Z","comments":true,"path":"2023/06/17/categories/后端/JavaSpringBoot实现文档编辑保存/","link":"","permalink":"https://visen123.github.io/2023/06/17/categories/%E5%90%8E%E7%AB%AF/JavaSpringBoot%E5%AE%9E%E7%8E%B0%E6%96%87%E6%A1%A3%E7%BC%96%E8%BE%91%E4%BF%9D%E5%AD%98/","excerpt":"","text":"在Java Spring Boot项目中集成OnlyOffice来实现Word文档的在线编辑和保存，你需要遵循以下几个步骤： 添加依赖首先，确保你的Maven pom.xml 文件中包含了OnlyOffice和相关库的依赖。通常，你不需要直接添加OnlyOffice的依赖，而是要确保你有处理HTTP请求的能力，比如使用Spring Web的依赖。 org.springframework.boot spring-boot-starter-web &lt;!-- 如果需要额外的JSON处理能力 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;/dependency&gt; 2. 配置OnlyOffice服务器 你需要在本地或远程部署OnlyOffice的服务器。OnlyOffice提供了Docker镜像，可以通过Docker快速部署： docker pull onlyoffice/documentserverdocker run –name onlyoffice -d -p 80:80 onlyoffice/documentserver3. 配置Spring Boot应用在Spring Boot应用中，你需要配置OnlyOffice的URL和编辑器的基地址。通常，这可以通过application.properties或application.yml文件来完成： onlyoffice.url=http://localhost:804. 实现文件上传和下载你需要实现文件的上传和下载功能，以便OnlyOffice可以加载和保存文档。以下是一个简单的控制器示例，用于处理文件上传和下载： import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.*;import org.springframework.core.io.Resource;import org.springframework.core.io.FileSystemResource; import java.io.File;import java.nio.file.Paths; @RestController@RequestMapping(“/documents”)public class DocumentController { @PostMapping(&quot;/upload&quot;) public ResponseEntity&lt;String&gt; uploadDocument(@RequestParam(&quot;file&quot;) MultipartFile file) &#123; // 保存文件到本地或数据库 // 返回文件的URL或ID，以便OnlyOffice可以使用 return ResponseEntity.ok().body(&quot;File uploaded successfully&quot;); &#125; @GetMapping(&quot;/download/&#123;id&#125;&quot;) public ResponseEntity&lt;Resource&gt; downloadDocument(@PathVariable(&quot;id&quot;) String id) &#123; // 根据文件ID加载文件 File file = new File(Paths.get(&quot;path/to/your/files&quot;, id).toString()); Resource resource = new FileSystemResource(file); // 返回文件资源 return ResponseEntity.ok() .header(HttpHeaders.CONTENT_DISPOSITION, &quot;attachment; filename=\\&quot;&quot; + file.getName() + &quot;\\&quot;&quot;) .body(resource); &#125; }5. 集成OnlyOffice编辑器接下来，你需要在前端页面中集成OnlyOffice编辑器。这通常涉及到JavaScript代码，使用OnlyOffice提供的API来初始化编辑器： var editor = onlyoffice.editors.edit({ url: “/onlyoffice/edit”, document: { url: “/documents/download/1”, title: “Sample Document” }, mode: “edit”, callback: function(event) { console.log(event); }});6. 处理OnlyOffice的回调当文档在OnlyOffice中被编辑并保存时，OnlyOffice会发送一个回调请求到你的服务器。你需要实现一个端点来处理这些回调，保存更新后的文档： @PostMapping(“/onlyoffice/callback”)public ResponseEntity handleCallback(@RequestBody Map&lt;String, Object&gt; data) { // 处理回调数据，保存更新后的文档 return ResponseEntity.ok().body(“Callback handled successfully”);}7. 部署和测试完成上述步骤后，部署你的Spring Boot应用并测试文档编辑和保存功能。确保OnlyOffice服务器和Spring Boot应用之间的网络通信没有问题。 以上步骤提供了集成OnlyOffice的基本框架，但具体实现细节可能会根据你的项目需求和技术栈有所不同。确保阅读OnlyOffice的官方文档以获得更详细的指南和最佳实践。","categories":[{"name":"后端","slug":"后端","permalink":"https://visen123.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"后端","slug":"后端","permalink":"https://visen123.github.io/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"SpringBoot 结合 WebSocket 实现聊天功能","slug":"categories/后端/SpringBoot实现聊天功能","date":"2023-06-11T02:00:13.000Z","updated":"2024-07-16T09:46:02.843Z","comments":true,"path":"2023/06/11/categories/后端/SpringBoot实现聊天功能/","link":"","permalink":"https://visen123.github.io/2023/06/11/categories/%E5%90%8E%E7%AB%AF/SpringBoot%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E5%8A%9F%E8%83%BD/","excerpt":"","text":"目录 一、WebSocket 介绍 二、源码 2.1 pom.xml 2.2 WebSocket配置类，用于配置WebSocket的相关设置 2.3 自定义WebSocket处理器类，用于处理WebSocket的生命周期事件 2.4 自定义WebSocket握手拦截器，用于增强WebSocket的握手过程 2.5 SessionBean类用于封装与WebSocket会话相关的数据 2.6 前端代码 三、界面效果 一、WebSocket 介绍WebSocket 是一种网络通信协议，用于在单个 TCP 连接上进行全双工通信。它具有实时性、双向通信、低开销和跨域支持等特点，适用于实时聊天、在线游戏等应用场景。在实际应用中，通常与前端技术结合使用，通过 WebSocket API 来实现实时数据的传输和处理。 二、源码代码结构 2.1 pom.xml &lt;java.version&gt;17&lt;/java.version&gt; com.alibaba fastjson 2.0.32 org.springframework.boot spring-boot-starter-websocket org.springframework.boot spring-boot-starter-tomcat cn.hutool hutool-all 5.8.9 org.apache.tomcat.embed tomcat-embed-websocket 10.1.20 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;excludes&gt; &lt;exclude&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 2.2 WebSocket配置类，用于配置WebSocket的相关设置package com.by.config; import jakarta.annotation.Resource;import org.springframework.context.annotation.Configuration;import org.springframework.web.socket.config.annotation.EnableWebSocket;import org.springframework.web.socket.config.annotation.WebSocketConfigurer;import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry; /** @author 黄远超 /@Configuration@EnableWebSocketpublic class MyWsConfig implements WebSocketConfigurer { @Resource MyWsHandler myWsHandler; @Resource MyWsInterceptor myWsInterceptor; @Override public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) { registry.addHandler(myWsHandler,&quot;/myWs1&quot;) .addInterceptors(myWsInterceptor) .setAllowedOrigins(&quot;*&quot;); } //访问的位置，设置拦截器，设置拦截范围} 2.3 自定义WebSocket处理器类，用于处理WebSocket的生命周期事件package com.by.config; import cn.hutool.core.text.StrBuilder;import lombok.extern.slf4j.Slf4j;import org.springframework.boot.web.servlet.server.Session;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;import org.springframework.web.socket.CloseStatus;import org.springframework.web.socket.TextMessage;import org.springframework.web.socket.WebSocketSession;import org.springframework.web.socket.handler.AbstractWebSocketHandler; import java.io.IOException;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.atomic.AtomicInteger; /** 物理程序 */@Component@Slf4jpublic class MyWsHandler extends AbstractWebSocketHandler { private static Map&lt;String,SessionBean&gt; sessionBeanMap; private static AtomicInteger clientIdMaker; private static StringBuffer stringBuffer; //初始化 static { sessionBeanMap = new ConcurrentHashMap&lt;&gt;(); clientIdMaker = new AtomicInteger(0); stringBuffer = new StringBuffer(); } @Override public void afterConnectionEstablished(WebSocketSession session) throws Exception { super.afterConnectionEstablished(session); SessionBean sessionBean = new SessionBean(session, clientIdMaker.getAndIncrement()); sessionBeanMap.put(session.getId(),sessionBean); log.info(sessionBeanMap.get(session.getId()).getClientId()+”建立连接”); stringBuffer.append(sessionBeanMap.get(session.getId()).getClientId()+”进入了群聊“); sendMessage(sessionBeanMap); } @Override protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception &#123; super.handleTextMessage(session, message); log.info(sessionBeanMap.get(session.getId()).getClientId()+&quot;:&quot;+message.getPayload()); stringBuffer.append(sessionBeanMap.get(session.getId()).getClientId()+&quot;:&quot;+message.getPayload()+&quot;&lt;br/&gt;&quot;); sendMessage(sessionBeanMap); &#125; //异常时 @Override public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception &#123; super.handleTransportError(session, exception); if (session.isOpen())&#123; session.close(); &#125; sessionBeanMap.remove(session.getId()); &#125; @Override public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception &#123; super.afterConnectionClosed(session, status); int clientId = sessionBeanMap.get(session.getId()).getClientId(); sessionBeanMap.remove(session); log.info(clientId+&quot;关闭了连接&quot;); stringBuffer.append(clientId+&quot;退出了群聊&lt;br/&gt;&quot;); sendMessage(sessionBeanMap); &#125; public void sendMessage(Map&lt;String,SessionBean&gt; sessionBeanMap)&#123; for(String key:sessionBeanMap.keySet())&#123;&#123; try &#123; sessionBeanMap.get(key).getWebSocketSession().sendMessage(new TextMessage(stringBuffer.toString())); &#125; catch (IOException e) &#123; log.info(\"出错啦\"); &#125; &#125;&#125; &#125; // //定时任务// @Scheduled(fixedDelay = 2000)//多少秒执行1次// public void sendMessage() throws IOException {// for (String key:sessionBeanMap.keySet()){// sessionBeanMap.get(key).getWebSocketSession().sendMessage(new TextMessage(“：心跳”));// }// }} 2.4 自定义WebSocket握手拦截器，用于增强WebSocket的握手过程package com.by.config; import lombok.extern.slf4j.Slf4j;import org.springframework.http.server.ServerHttpRequest;import org.springframework.http.server.ServerHttpResponse;import org.springframework.stereotype.Component;import org.springframework.web.socket.WebSocketHandler;import org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor; import java.util.Map; /** @author 黄远超 /@Component@Slf4jpublic class MyWsInterceptor extends HttpSessionHandshakeInterceptor { @Override public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes) throws Exception { return super.beforeHandshake(request, response, wsHandler, attributes); } @Override public void afterHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Exception ex) { super.afterHandshake(request, response, wsHandler, ex); }} 2.5 SessionBean类用于封装与WebSocket会话相关的数据package com.by.config; import jakarta.websocket.Session;import lombok.AllArgsConstructor;import lombok.Data;import org.springframework.web.server.WebSession;import org.springframework.web.socket.WebSocketSession; /** @author 黄远超 //** SessionBean类用于封装与WebSocket会话相关的数据。 webSocketSession 代表一个WebSocket会话的对象，用于与客户端进行双向通信。 clientId 客户端的唯一标识符，用于区分不同的客户端连接。 /@Data@AllArgsConstructorpublic class SessionBean { private WebSocketSession webSocketSession; // WebSocket会话对象 private Integer clientId; // 客户端ID} 2.6 前端代码 Title 发送 let ws = new WebSocket(\"ws://localhost:8080/myWs1\") ws.onopen=function (){ } ws.onmessage=function (message) { document.getElementById(\"talkMsg\").innerHTML = message.data } function sendMsg() { ws.send(document.getElementById(\"message\").value) document.getElementById(\"message\").value=\"\" }","categories":[{"name":"后端","slug":"后端","permalink":"https://visen123.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"后端","slug":"后端","permalink":"https://visen123.github.io/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"Spring Boot 简介与环境搭建","slug":"categories/后端/Spring Boot 简介与环境搭建","date":"2023-03-11T03:00:13.000Z","updated":"2024-07-16T09:40:37.329Z","comments":true,"path":"2023/03/11/categories/后端/Spring Boot 简介与环境搭建/","link":"","permalink":"https://visen123.github.io/2023/03/11/categories/%E5%90%8E%E7%AB%AF/Spring%20Boot%20%E7%AE%80%E4%BB%8B%E4%B8%8E%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"一、Spring Boot 简介与环境搭建1.1 Spring Boot 简介Spring Boot 是一种基于 Java 的开源框架，由 Pivotal Software 开发，旨在简化新 Spring 应用程序的初始化、配置和部署过程。它遵循约定优于配置的原则，通过内嵌的Tomcat、Jetty或Undertow等容器，使得开发者能够快速构建独立运行的、生产级别的基于Spring框架的应用程序。Spring Boot 包含了大量的自动配置功能，可智能识别已存在的库并配置相应组件，从而减少手动配置的工作量。 1.2 开发环境准备1.2.1 JDK 安装与配置首先确保您的开发环境中安装了Java Development Kit (JDK)，推荐使用 Oracle JDK 8 及以上版本。设置系统环境变量，包括 JAVA_HOME，并在 PATH 中包含 %JAVA_HOME%\\bin （Windows）或 $JAVA_HOME/bin （Linux/macOS）。 1.2.2 IDE 选择与配置IntelliJ IDEA: 下载并安装 IntelliJ IDEA 社区版或旗舰版，然后在其插件市场中搜索并安装 Spring Assistant 或 Spring Boot 插件，以便更好地支持 Spring Boot 项目的创建和开发。 Eclipse: 安装 Eclipse IDE for Enterprise Java and Web Developers 版本，并通过 Marketplace 安装 Spring Tools 4 插件。 1.2.3 构建工具配置 Maven: 使用 Maven 构建 Spring Boot 项目，需要在项目的 pom.xml 文件中添加 Spring Boot 的父项目依赖，以及指定所需的功能起步依赖。以下是示例：1&lt;project xmlns=”http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=”http://www.w3.org/2001/XMLSchema-instance&quot;2 xsi:schemaLocation=”http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;3 4.0.045 6 7 org.springframework.boot8 spring-boot-starter-parent9 2.6.x 10 11 1213 com.example14 my-spring-boot-app15 0.0.1-SNAPSHOT16 My Spring Boot App17 Demo project for Spring Boot1819 20 21 22 org.springframework.boot23 spring-boot-starter-web24 25 2627 282930 31- **Gradle**: 在 Gradle 项目中，可在build.gradle` 文件中添加 Spring Boot 插件和起步依赖：3233```groovy34plugins {35 id ‘org.springframework.boot’ version ‘2.6.x’ // 替换为当前最新的稳定版36 id ‘io.spring.dependency-management’ version ‘1.0.11.RELEASE’37 id ‘java’38}3940group = ‘com.example’41version = ‘0.0.1-SNAPSHOT’42sourceCompatibility = ‘1.8’4344repositories {45 mavenCentral()46}4748dependencies {49 implementation ‘org.springframework.boot:spring-boot-starter-web’50 // 其他依赖51} 1.3 创建第一个 Spring Boot 项目可以通过以下两种方式创建 Spring Boot 项目： 使用 IDE 内置向导：在 IntelliJ IDEA 或 Eclipse 中直接新建 Spring Boot 项目，按照向导指引选择所需的依赖。 使用 Spring Initializr：访问 https://start.spring.io/，在线生成基础的 Spring Boot 项目结构，下载后导入到本地 IDE 中。 生成的项目中包含一个带有 @SpringBootApplication 注解的主类，它是 Spring Boot 应用的核心入口点： 1import org.springframework.boot.SpringApplication;2import org.springframework.boot.autoconfigure.SpringBootApplication;34@SpringBootApplication5public class MyApplication {67 public static void main(String[] args) {8 SpringApplication.run(MyApplication.class, args);9 }10}二、Spring Boot 核心特性及组件2.1 自动配置（Auto-Configuration）Spring Boot 的自动配置机制基于条件注解（Conditional Annotations）和META-INF/spring.factories中的配置元数据。当类路径中检测到特定的库时，Spring Boot 将自动配置对应的Bean。例如，当发现 spring-boot-starter-data-jpa 和连接数据库的驱动时，会自动配置数据源、JPA EntityManagerFactory、TransactionManager 等组件。 2.2 起步依赖（Starter Dependencies）Spring Boot 通过提供一系列的“起步依赖”（starter），帮助开发者轻松地添加相关技术栈。这些依赖集合了该技术领域常用的一系列库，避免了逐个添加和管理单个依赖的繁琐工作。 2.3 主启动类（Main Application Class）@SpringBootApplication 注解的主类不仅指示了应用的入口点，还聚合了 @Configuration（表示这是一个配置类）、@EnableAutoConfiguration（开启自动配置）和 @ComponentScan（自动扫描组件）注解。这使得 Spring 容器能够自动发现、装配和管理应用程序中的所有组件。 三. Spring Boot Web 开发3.1 RESTful API 设计Spring Boot 提供了强大的支持来设计和实现符合 RESTful 规范的 Web 服务。通过使用 @RestController 注解标记控制器类或者方法，可以很容易地创建处理 HTTP 请求的资源端点。同时，借助于 @PathVariable、@RequestParam、@RequestBody 等注解，可以处理 URL 路径参数、查询参数和请求体数据。此外，响应式编程模型（Reactor/Mono/Flux）也能无缝整合进 Spring Boot Web 开发中，以实现高效的非阻塞 I/O。 3.2 控制器（Controller）在 Spring Boot 中，控制器负责接收客户端的请求并处理相应的业务逻辑。控制器类通常包含多个处理不同HTTP动作的方法，比如 GET、POST、PUT、DELETE 等。通过 @GetMapping、@PostMapping 等注解指定对应的动作类型，配合 Model 和 View 或 JSON 数据返回给客户端。 3.3 视图层技术Spring Boot 支持多种模板引擎，包括 Thymeleaf 和 FreeMarker。Thymeleaf 是一款服务器端的现代模版引擎，它可以无缝处理HTML，允许在HTML文件中编写表达式和语句，动态生成网页内容。FreeMarker 则是一种灵活的基于模板的文本处理器，常用于生成 HTML 页面和其他类型的文档。 四. 数据访问与持久化4.1 Spring Data JPASpring Data JPA 是 Spring Boot 对 Java Persistence API (JPA) 的封装，极大地简化了数据库操作。通过定义继承自 JpaRepository 或 CrudRepository 的接口，即可快速实现对数据库的基本 CRUD 操作。此外，Spring Data JPA 还提供了分页、排序、自定义查询等功能。 4.2 Hibernate作为 JPA 实现的一种，Hibernate 在 Spring Boot 中被广泛应用于 ORM 映射，将对象关系映射到数据库表中。通过配置 Hibernate 的实体映射、事务管理等，可以方便地进行数据库的交互。 4.3 NoSQL 数据库集成Spring Boot 不仅支持传统的关系型数据库，也非常容易集成各种 NoSQL 数据存储方案，如 MongoDB、Cassandra、Redis 等。通过引入相关的 starter 依赖，即可快速接入这些数据库，使用 Spring Data 提供的统一接口进行操作。 五. 安全性（Spring Security）Spring Security 是一套完整的安全解决方案，可用于实现认证（Authentication）和授权（Authorization）。在 Spring Boot 中，只需简单的配置就可以启用 Spring Security，实现登录验证、角色权限控制、CSRF防护等功能。还可以定制过滤器链、加密策略以及其他高级安全特性。 六. 配置管理6.1 properties/yaml文件Spring Boot 支持使用 properties 或 yaml 文件进行应用配置，包括数据库连接、端口绑定、日志级别等各种配置项。默认读取 application.properties 或 application.yml 文件。 6.2 外部化配置Spring Boot 提倡配置外部化，即从环境变量、命令行参数或远程配置中心加载配置，便于多环境下的应用部署和管理。 6.3 Actuator 监控端点Spring Boot Actuator 提供了一系列内置的健康检查、审计、指标收集和暴露端点，使开发者能够方便地了解应用运行状态和性能指标，这对于运维监控至关重要。 七. 单元测试与集成测试7.1 Spring Boot TestSpring Boot Test 模块提供了丰富的测试支持，如模拟 MVC 测试、数据层测试等。通过 @SpringBootTest 注解启动一个完整应用程序上下文进行测试。 7.2 MockMvcMockMvc 是一个用于执行模拟请求、测试控制器行为的工具，无需启动整个 Servlet 容器就能验证 Controller 层的逻辑正确性。 7.3 TestRestTemplateTestRestTemplate 类简化了对 RESTful 服务的集成测试，尤其适用于测试对外提供的 REST API。 八. 微服务架构8.1 EurekaEureka 是 Netflix OSS 中的服务注册与发现组件，在 Spring Cloud 中扮演重要角色，帮助构建高可用的服务治理体系。 8.2 RibbonRibbon 提供客户端负载均衡功能，可以透明地实现服务间的通信与负载均衡策略。 8.3 FeignFeign 是一个声明式的伪客户端 HTTP 请求库，使得微服务之间的调用变得简洁明了。 8.4 ZuulZuul 是边缘服务路由网关，用于处理所有的微服务对外请求，提供路由转发、过滤器等功能，实现微服务的安全性、鉴权和流量控制。 九. DevTools 工具Spring Boot DevTools 提供了热部署功能，当代码发生变化时，自动重启应用，大大提高了开发效率。 十. 日志管理与分布式跟踪10.1 Logback/Spring Boot 默认日志系统Spring Boot 默认采用 Logback 作为日志框架，但也可以轻松切换到其他如 Log4j2。配置日志级别、输出格式以及文件滚动策略等十分便利。 10.2 Sleuth/Zipkin 分布式跟踪Spring Cloud Sleuth 提供了一套针对分布式系统的追踪解决方案，结合 Zipkin 可以可视化展示服务间的调用链路，便于分析和定位分布式环境下的性能瓶颈和服务异常。 十一. 应用部署与运维11.1 Docker容器化Spring Boot 应用非常适合容器化部署，通过 Dockerfile 构建镜像，实现标准化的部署流程，易于维护和扩展。 11.2 Kubernetes编排利用 Kubernetes 进行应用编排，能够自动化部署、管理和扩展 Spring Boot 应用，适应云原生时代的基础设施需求。","categories":[{"name":"后端","slug":"后端","permalink":"https://visen123.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"后端","slug":"后端","permalink":"https://visen123.github.io/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"JS获取手机型号和系统版本","slug":"categories/前端/JS获取手机型号和系统版本","date":"2022-10-12T02:36:42.000Z","updated":"2024-07-16T09:24:29.606Z","comments":true,"path":"2022/10/12/categories/前端/JS获取手机型号和系统版本/","link":"","permalink":"https://visen123.github.io/2022/10/12/categories/%E5%89%8D%E7%AB%AF/JS%E8%8E%B7%E5%8F%96%E6%89%8B%E6%9C%BA%E5%9E%8B%E5%8F%B7%E5%92%8C%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC/","excerpt":"","text":"前端浏览器获取设备信息和系统信息只能通过navigator对象的userAgent属性获取。小米9和苹果7plus的userAgent长这样： //米9 &quot;Mozilla/5.0 (Linux; Android 9; MI 9 Build/PKQ1.181121.001; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/66.0.3359.126 MQQBrowser/6.2 TBS/044904 Mobile Safari/537.36 MMWEBID/9234 MicroMessenger/7.0.6.1500(0x2700063E) Process/tools NetType/WIFI Language/zh_CN&quot; //苹果7 plus &quot;Mozilla/5.0 (iPhone; CPU iPhone OS 10_2 like Mac OS X) AppleWebKit/602.3.12 (KHTML, like Gecko) Mobile/14C92 Safari/601.1 wechatdevtools/1.02.1907300 MicroMessenger/7.0.4 Language/zh_CN webview/15693784144112003 webdebugger port/58531&quot; 我们现在要获取三个参数手机型号，这个看上面的只有安卓能获取，这里是MI 9，苹果只能知道是iPhone还是iPad，无法知道具体手机型号。系统版本，安卓苹果手机都能获取，上面的安卓是Android 9，苹果是iPhone OS 10_2。微信版本，如果在微信浏览器中打开，我们需要获取微信的版本。这个苹果安卓都能获取，上面显示的是MicroMessenger/7.0.4先判断是苹果还是安卓，代码如下： let userAgent = navigator.userAgent if (userAgent.includes(&#39;iPhone&#39;) || userAgent.includes(&#39;iPad&#39;)) &#123; console.log(&#39;苹果手机&#39;) &#125; if (userAgent.includes(&#39;Android&#39;)) &#123; console.log(&#39;安卓手机&#39;) &#125; 下面我们用正则分别来获取这三个需要的参数 系统版本（安卓）：这里的 (?=;) 是指到分号为止，但不包括分号。第一个问号，就是 /Android.*?(?=;)/ 是指匹配第一个后面括号里的内容，也就是匹配第一个分号。 let m1 = userAgent.match(/Android.*?(?=;)/) if (m1 &amp;&amp; m1.length &gt; 0) &#123; system = m1[0] // Android 9 &#125; 系统版本（苹果）：这个和上面一样，只是匹配空格。 let m1 = userAgent.match(/iPhone OS .*?(?= )/) if (m1 &amp;&amp; m1.length &gt; 0) &#123; system = m1[0] // iPhone OS 10_2 &#125; 微信版本： let m1 = userAgent.match(/MicroMessenger.*?(?= )/) if (m1 &amp;&amp; m1.length &gt; 0) &#123; wechat = m1[0] // MicroMessenger/7.0.4 &#125; 手机型号（安卓）：这里由于包含一个非问号开头的括号表示，所以match会有2个结果，第一个是全部匹配，第二个是括号内的匹配，我们只要括号内的匹配。 let m1 = userAgent.match(/Android.*; ?(.*(?= Build))/) if (m1 &amp;&amp; m1.length &gt; 1) &#123; device = m1[1] // MI 9 &#125; 完整代码 let webLog = &#123;&#125; let userAgent = navigator.userAgent // 获取微信版本 let m1 = userAgent.match(/MicroMessenger.*?(?= )/) if (m1 &amp;&amp; m1.length &gt; 0) &#123; webLog.wechat = m1[0] &#125; // 苹果手机 if (userAgent.includes(&#39;iPhone&#39;) || userAgent.includes(&#39;iPad&#39;)) &#123; // 获取设备名 if (userAgent.includes(&#39;iPad&#39;)) &#123; webLog.device = &#39;iPad&#39; &#125; else &#123; webLog.device = &#39;iPhone&#39; &#125; // 获取操作系统版本 m1 = userAgent.match(/iPhone OS .*?(?= )/) if (m1 &amp;&amp; m1.length &gt; 0) &#123; webLog.system = m1[0] &#125; &#125; // 安卓手机 if (userAgent.includes(&#39;Android&#39;)) &#123; // 获取设备名 m1 = userAgent.match(/Android.*; ?(.*(?= Build))/) if (m1 &amp;&amp; m1.length &gt; 1) &#123; webLog.device = m1[1] &#125; // 获取操作系统版本 m1 = userAgent.match(/Android.*?(?=;)/) if (m1 &amp;&amp; m1.length &gt; 0) &#123; webLog.system = m1[0] &#125; &#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://visen123.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://visen123.github.io/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"VueJs2.0建议学习路线","slug":"categories/前端/VueJs2.0建议学习路线","date":"2022-08-09T02:26:42.000Z","updated":"2024-07-16T09:21:52.588Z","comments":true,"path":"2022/08/09/categories/前端/VueJs2.0建议学习路线/","link":"","permalink":"https://visen123.github.io/2022/08/09/categories/%E5%89%8D%E7%AB%AF/VueJs2.0%E5%BB%BA%E8%AE%AE%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/","excerpt":"","text":"最近VueJs确实火了一把，自从Vue2.0发布后，Vue就成了前端领域的热门话题，github也突破了三万的star，那么对于新手来说，如何高效快速的学习Vue2.0呢。 既然大家会看这篇文章，那么肯定是vue的学习者了，或是遇到的瓶颈，或者刚刚开始学，不知道如何快速起步，本篇文章将带领大家在最短的时间内构件一个学习Vue的学习路线 Vuejs的作者尤雨溪尤大也写过一篇关于新手学习vue路径的文章新手向：Vue 2.0 的建议学习顺序 百度vuejs搜索的是vue1的文档，推荐大家直接上2.0,毕竟1和2还是有区别的。vue2.0文档地址Vue2.0 Vue基础对于没有接触过es6和webpack的童鞋来说，不建议直接用官方的脚手架vue-cli构件项目。先按文档顺序最少学习完组件那一章。直接在html文件中引入vue.js开始学习,了解vue的基础指令和语法。vue的生命周期很重要，了解这点以后可以免去很多问题。学完这些可以做一些练手的小项目，比如万年不变的todolist。。。现在可以开始学习使用vue-cli构件项目了，学习组件化之前，推荐先看一下es6关于模块的介绍。阮一峰《ECMAScript6》 Module光会这些还是不够的，还得会一些npm基础，知道如何用git-bash来安装依赖，会一些常用的命令。这方面的知识可以参阅npm入门文档看完这些就可以试着将之前的写的demo用搭建的vue-cli来实现。附上我写的一个入门小demovue-demo-search多看看组件那里，看看如何在vue-cli中怎么实现组件化，说白了，vue玩的就是组件。到这里vue基础篇就结束了。你还可以有条件的参阅剩下的官方文档里面的进阶篇，如果时间有限，就直接进入vue-router Vue-router和之前一样，推荐直接用html+js过一遍文档对路由导航钩子得好好看一看。看完文档就可以上手vue-cli，一般新手在这几天都会死活跑不出来。偷笑最直接的方法就是去github上搜一些关于vue-router2.0的demo，看如何构件路由，如何构件项目目录。我这里有一个传送门如果能跑出来，就可以做一些小项目了，比如写一个知乎日报啊偷笑，这些demo在github上很多。可以结合一些组件库写demo，这样可以更加了解组件化。比如饿了么团队的Element、mint-ui Vuex什么是vuex？ Vuex 是一个专门为 Vue.js 应用设计的 状态管理模型 + 库。它为应用内的所有组件提供集中式存储服务，其中的规则确保状态只能按预期方式变更。说白了就是控制应用的一些全局状态。状态改变了，对应的视图也会改变。 在学习Vuex时，会有一些ES6特性，当遇到这些时，最好不要一带而过，去好好看一看这些es6特性。比如在学习Action时可以看看ES6新增的Promise和参数解构。实践的方法一样是先看别人别人写的代码，比如官方的购物车实例的应用结构。把之前写的demo优化一下，有些地方可以用用vuex。vuex主要是用来对不同组件间进行通信，它构建了一个Vue实例的全局数据与方法，这些数据与方法可以在该Vue实例的所有组件中getter与setter。 到此，恭喜你已经成功入门Vue了。还学会了一点ES6,，附带一点Webpack偷笑，可以开始写一些小作品了，比如写个播放器啊，写个高级点的todoList等等，附上我写的一个仿照酷狗webapp的例子吧","categories":[{"name":"前端","slug":"前端","permalink":"https://visen123.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://visen123.github.io/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"前端常见的十七个框架","slug":"categories/前端/前端常见的十七个框架","date":"2022-07-08T12:26:42.000Z","updated":"2024-07-16T09:14:53.252Z","comments":true,"path":"2022/07/08/categories/前端/前端常见的十七个框架/","link":"","permalink":"https://visen123.github.io/2022/07/08/categories/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8D%81%E4%B8%83%E4%B8%AA%E6%A1%86%E6%9E%B6/","excerpt":"","text":"1.Layui 官方网址：http://www.layui.com/ Layui是一款采用自身模块规范编写的国产前端UI框架，遵循原生HTML/CSS/JS的书写与组织形式，门槛极低，拿来即用。从核心代码到API的每一处细节都经过精心雕琢，非常适合界面的快速开发。，从核心代码到API的每一处细节都经过精心雕琢，非常适合界面的快速开发。Layui还很年轻，首个版本发布于2016年金秋，她区别于那些基于MVVM底层的UI框架，却并非逆道而行，而是信奉返璞归真之道。准确地说，她更多是为服务端程序员量身定做，你无需涉足各种前端工具的复杂配置，只需面对浏览器本身，让一切你所需要的元素与交互，从这里信手拈来。 前端常见的十七个框架经典模块化前端框架2.NEC： 官方网址：http://nec.netease.com/case 你是否常常碰到以下问题：你总是看不懂他写的代码，或者读起来很吃力；你需要改他的代码却无从下手，或总是要去问他这里是什么改了会不会影响其他代码；你和他一起开发一个产品，你总是怕代码和他有冲突或互相影响；你的代码在多次维护任务之后变得越来越臃肿，越来越难以维护，解决以上问题只需一种方法——读我们的规范！ 前端常见的十七个框架国产web前端框架推荐之–NEC3：amaze UI 官方网址：http://amazeui.org/ 之前公司的网站被黑客攻击之后，整个网站的东西都用不了了，处于丢失和瘫痪的状态，楼主毫不犹豫在这个网站上找了一个框架，仅仅两三天的时间，就成功挽救了这一糟糕的局面，还是要感谢我们这强大的框架，妹子UI,适配pc端和移动端，功能齐全，网站开发什么的，都SOeasy 前端常见的十七个框架中国首个开源 HTML5 跨屏前端框架.4.NEJ 官方网址：http://nej.netease.com/ NEJ全称：Nice Easy Javascript 是由网易前端组工程师们发起创建的简洁，美观，真正的跨平台web前端开发框架；在适配性上支持桌面及移动平台、浏览器及混合应用开发，补丁模式无缝扩展适配平台，配置方式灵活定制目标平台 前端常见的十七个框架5.boostrap 框架官方网址：http://www.bootcss.com/ 这个我就不多说了，大多数人都在用这个框架来开发，官方文档的API完整可靠，还有各种Bootstrap相关优质项目推荐，前端开发首选框架 前端常见的十七个框架简洁、直观、强悍的前端开发框架，让web开发更迅速、简单。6：Foundation 官方网址：http://www.foundcss.com/ Foundation 是一个易用、强大而且灵活的响应式前端框架，用于构建基于任何设备上的响应式网站、 Web应用和电子邮件。结构语义化、移动设备优先、完全可定制。 前端常见的十七个框架响应式前端框架7.Jquery代码库 官方网址：http://www.jqueryui.org.cn/ 前端常见的十七个框架基于Jquery的开源网页用户界面代码库：8.jQuery插件库 官方网址：http://www.jq22.com/ 史上最全的jQuery效果，包括了开发所需要的所有需求的demo，如果有不会的东西，就来jQuery插件库吧，这里总有一些你想要的，还在等什么？ 前端常见的十七个框架9.FrozenUI 官方网址：http://frozenui.github.io/ 随心所用的样式组件，更显灵动的JS插件，酷炫好玩的案例秀，提供的Animationcase，把业务上有趣好玩的案例沉淀下来，帮助日后能更快速找到设计灵感。FrozenUI是一个开源的简单易用，轻量快捷的移动端UI框架。基于手Q样式规范，选取最常用的组件，做成手Q公用离线包减少请求，升级方式友好，文档完善，目前全面应用在腾讯手Q增值业务中。 前端常见的十七个框架移动端开发专用框架：10：SUI 官方网址：http://m.sui.taobao.org/ SUI是一套基于bootstrap开发的前端组件库，同时她也是一套设计规范。通过SUI，可以非常方便的设计和实现精美的页面。同时sui还有移动端版本msui，msui是阿里巴巴共享业务事业部UED团队的作品。目的是为了手机H5页面提供一个常用的组件库，减少重复工作。 前端常见的十七个框架搭建手机H5应用：11:AUI 官方网址：http://www.auicss.com/ AUI2.0是一套全新的AUI框架，在1.X基础上进行了重新架构。结合实际项目出发，站在开发者和项目的角度，重新定义AUI框架。在2.0中使用了大量弹性响应式布局，采用容器+布局结构+控件的嵌套形式，方便开发者快速布局样式。我们充分吸取了AUI使用者的反馈意见和借鉴了市场上其他优秀UI框架，完成了2.0版本的开发。2.0遵循GoogleMaterial 设计规范，使用MIT开源协议。 前端常见的十七个框架12:MUI： 官方网址：http://dev.dcloud.net.cn/mui/ 最接近原生APP体验的高性能前端框架,相信这个大家都不陌生：鉴于之前的很多前端框架（特别是响应式布局的框架），UI控件看起来太像网页，没有原生感觉，因此追求原生UI感觉也是我们的重要目标MUI以iOS平台UI为基础，补充部分Android平台特有的UI控件 前端常见的十七个框架13:Semantic UI 官方网址：http://www.semantic-ui.cn/ Semantic作为一款开发框架，帮助开发者使用对人类友好的HTML语言构建优雅的响应式布局。更快地设计赏心悦目的网站 前端常见的十七个框架14.Aliceui 官方网址：http://www.oschina.net/p/aliceui?fromerr=mgWZvlr0 Aliceui是支付宝的样式解决方案，是一套精选的基于 spm 生态圈的样式模块集合，是 Arale 的子集，也是一套模块化的样式命名和组织规范，是写 CSS 的更好方式。 前端常见的十七个框架15.H-ui 官网地址：http://www.h-ui.net/ H-ui是轻量级前端框架，简单免费，兼容性好，适用于中国网站。H-ui是一个相对成长比较慢的前端框架，相比目前行业众多框架还有很多不足。但初心不改，实实在在把事做好，做用户最喜欢的框架。 前端常见的十七个框架16.Weui 官网地址：https://github.com/weui/weui weUI是一套同微信原生视觉体验一致的基础样式库，由微信官方设计团队为微信 Web开发量身设计，可以令用户的使用感知更加统一。包含button、cell、dialog、 progress、toast、article、actionsheet、icon等各式元素。 前端常见的十七个框架17.YDUI Touch 官网地址：http://www.ydui.org/ YDUI Touch 专为移动端打造，在技术实现、交互设计上兼容主流移动设备，保证代码轻、性能高;使用 Flex 技术，灵活自如地对齐、收缩、扩展元素，轻松搞定移动页面布局;实现强大的屏幕适配布局，等比例适配所有屏幕。什么？用得不开心？轻松切换 px;自定义JavaScript组件、Less文件、Less变量，定制一份属于自己的YDUI; 前端常见的十七个框架一只注重审美，且性能高效的移动端&amp;微信UI","categories":[{"name":"前端","slug":"前端","permalink":"https://visen123.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://visen123.github.io/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"JS字符串常用方法","slug":"categories/前端/JS字符串常用方法","date":"2022-05-16T12:26:42.000Z","updated":"2024-07-16T09:23:19.840Z","comments":true,"path":"2022/05/16/categories/前端/JS字符串常用方法/","link":"","permalink":"https://visen123.github.io/2022/05/16/categories/%E5%89%8D%E7%AB%AF/JS%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"String类型String类型是字符串的对象包装类型，可以使用String构造函数来创建 var str = new String(‘hello world’)也可以使用使用字面量创建 var str = ‘hello world’String类型的每个实例都有一个length属性，表示字符串中含有多少个字符 var str = ‘hello world’console.log(str.length); //11字符方法1.charAt()通过索引查找对应的字符 var str = ‘hello’;cosnole.log(str.charAt(1)); //e2.charCodeAt()通过索引查找对应字符的字符集编码 var str = ‘hello’;cosnole.log(str.charCodeAt(1)); //101字符串操作方法3.concat()字符串拼接：将一到多个字符串拼接起来，返回新的字符串,原值不发生变化，可以接收多个参数 var str = ‘hello ‘;var newStr = str.concat(‘world’,’!’);console.log(newStr); ///hello world!4.slice()slice(n,m) 字符串截取，从索引n开始截取到索引m，不包含m，包前不包后,源字符串不发生变化 var str = ‘hello world’;var str2 = str.slice(1,7); console.log(str2); //ello w5.substr()subStr(n,m) 字符串截取，从索引n开始截取m个，源字符串不发生变化 var str = ‘hello world’;var str2 = str.substr(1,7); console.log(str2); //ello wo6.substring()substring(n,m) 字符串截取，与slice()相同，从索引n开始截取到索引m，不包含m，包前不包后，源字符串不发生变化 var str = ‘hello world’;var str2 = str.substring(1,7); console.log(str2); //ello wslice(n),substr(n),substring(n) 都可以只传一个参数，只传一个参数是这三个的作用是一样的，都表示从所引n开始截取后面所有的字符然后返回 var str = ‘hello world’;var str2 = str.slice(1);var str3 = str.substr(1);var str4 = str.substring(1); console.log(str2); //ello world console.log(str3); //ello world console.log(str4); //ello world字符串位置方法7.indexOf()从一个字符串中搜索给定的字符串，然后返回给定字符串的索引位置，如果没有找到返回-1，从前往后找，如果包含多个给定字符串，只返回查找到的第一个给定字符串的位置 var str = ‘hello world!’;console.log(str.indexOf(‘o’)); //4console.log(str.indexOf(‘x’)); //-18.lastIndexOf()从一个字符串中搜索给定的字符串，然后返回给定字符串的索引位置，如果没有找到返回-1，从后往前找，如果包含多个给定字符串，只返回查找到的第一个给定字符串的位置 var str = ‘hello world!’;console.log(str.lastIndexOf(‘o’)); //7console.log(str.lastIndexOf(‘x’)); //-1indeOf()和lastIndexOf()都可以接收可选的第二个参数，表示从那个位置开始搜索 var str = ‘hello world’;console.log(str.indexOf(‘o’,6)); //7console.log(str.lastIndexOf(‘o’,6)); //4字符串大小写转换9.toUpperCase()转大写 var str = ‘hello world’;console.log(str.toUpperCase()); //HELLO WORLD10.toLowerCase()转小写 var str = ‘HELLO WORLD’;console.log(str.toLowerCase()); //hello world字符串的模式匹配方法11.search()search() 找到并返回第一个匹配项的索引，没有返回-1 var str = ‘hello world’; console.log(str.search(‘orl’)); //7console.log(str.search(‘xx’)); //-112.match()match() 该方法返回一个数组，数组第一项是要匹配的字符串，第二项返回第一个匹配项的索引，第三项是查找的字符串的全部字符,没有找到返回null var str = ‘hello world’; console.log(str.match(‘orl’)); //[“o”, index: 4, input: “hello world”…]console.log(str.match(‘xx’)); //-113.replace()找到第一个要匹配的字符串并替换为要替换的字符串 var str = ‘cat, bat, sat, fat’;var str2 = str.replace(‘at’,’ond’);console.log(str2); //cond, bat, sat, fatconsole.log(str); //cat, bat, sat, fat可以用全局标志的正则表达式替换匹配到的所有字符串 var str = ‘cat, bat, sat, fat’;var str2 = str.replace(/at/g,’ond’);console.log(str2); //cond, bond, sond, fondconsole.log(str); //cat, bat, sat, fat14.split()这个方法可以基于指定的分隔符将字符串分割成多个子字符串，返回一个新的数组，可以接收可选的第二个参数，用于指定数组大小 var str = ‘hello’;var str2 = str.split(‘’);var str3 = str.split(‘’，3);console.log(str2); //[“h”, “e”, “l”, “l”, “o”]console.log(str3); //[“h”, “e”, “l”]split(),match(),search(),replace(‘’,’’) 这几个方法都是可以跟正则配合的字符串方法","categories":[{"name":"前端","slug":"前端","permalink":"https://visen123.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://visen123.github.io/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"前端图片滑动验证","slug":"categories/前端/前端图片滑动验证","date":"2022-04-18T12:26:42.000Z","updated":"2024-07-16T09:23:02.254Z","comments":true,"path":"2022/04/18/categories/前端/前端图片滑动验证/","link":"","permalink":"https://visen123.github.io/2022/04/18/categories/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%9B%BE%E7%89%87%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81/","excerpt":"","text":"有些网站为了防止有人恶意使用脚本进行批量操作，会设置前后端进行配合的图片滑动验证，本文这里只介绍前端的验证功能。 这里可以直接使用 vue-monoplasty-slide-verify 这个库组件： 开始使用 库组件下载： npm install –save vue-monoplasty-slide-verify main.js中引入全局组件SlideVerify： import SlideVerify from “vue-monoplasty-slide-verify”; Vue.use(SlideVerify); 使用组件： &lt;template&gt; &lt;!-- 遮罩层 --&gt; &lt;div class=&quot;mask&quot;&gt; &lt;div class=&quot;slideContainer&quot;&gt; &lt;slide-verify @success=&quot;onSuccess&quot; @fail=&quot;onFail&quot; @refresh=&quot;onRefresh&quot; @fulfilled=&quot;onFulfilled&quot; slider-text=&quot;向右滑动验证&quot;&gt; &lt;/slide-verify&gt; &lt;div style=&quot;margin-top: 15px;&quot;&gt;&#123;&#123; text &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; data () &#123; return &#123; text:&#39;&#39; &#125; &#125;, methods:&#123; onSuccess(times)&#123; this.text = &#39;验证通过，耗时 &#39;+ (times / 1000).toFixed(1) + &#39;秒&#39; &#125;, onFail()&#123; this.text = &#39;验证失败&#39; &#125;, onRefresh()&#123; //点击刷新按钮 this.text = &#39;&#39; &#125;, onFulfilled() &#123; //验证失败自动刷新 this.text = &#39;重新验证&#39; &#125;, &#125; &#125; &lt;/script&gt; &lt;style scoped&gt; .mask &#123; position: fixed; left: 0%; top: 0%; width: 100%; height: 100%; z-index: 100; overflow: hidden; background-color: rgba(0, 0, 0, 0.5); &#125; .mask .slideContainer &#123; position: absolute; left: 50%; top: 50%; background-color: rgb(255, 255, 255); transform: translate(-50%,-50%); padding: 15px; &#125; &lt;/style&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://visen123.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://visen123.github.io/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"VUE 开源库","slug":"categories/前端/VUE 开源库","date":"2022-03-02T12:26:42.000Z","updated":"2024-07-16T09:17:44.387Z","comments":true,"path":"2022/03/02/categories/前端/VUE 开源库/","link":"","permalink":"https://visen123.github.io/2022/03/02/categories/%E5%89%8D%E7%AB%AF/VUE%20%E5%BC%80%E6%BA%90%E5%BA%93/","excerpt":"","text":"最近做了一个Vue开源项目库汇总，里面集合了OpenDigg 上的优质的Vue开源项目库，方便移动开发人员便捷的找到自己需要的项目工具等，感兴趣的可以到GitHub上给个star。 文章篇幅较长，我们将把它分为两部分发布。 第一部分 第二部分UI 组件 开发框架 实用库 服务端 辅助工具 应用实例 Demo 示例 UI 组件 1、element ★9305 - 饿了么出品的Vue2的web UI工具套件 https://github.com/ElemeFE/element 2、Vux ★6802 - 基于Vue和WeUI的组件库 https://github.com/airyland/vux 3、mint-ui ★4776 - Vue 2的移动UI元素 https://github.com/ElemeFE/mint-ui 4、iview ★4458 - 基于 Vuejs 的开源 UI 组件库 https://github.com/iview/iview 5、Keen-UI ★2363 - 轻量级的基本UI组件合集 https://github.com/JosephusPaye/Keen-UI 6、vue-material ★2207 - 通过Vue Material和Vue 2建立精美的app应用 https://github.com/marcosmoura/vue-material 7、muse-ui ★1992 - 三端样式一致的响应式 UI 库 https://github.com/museui/muse-ui 8、vuetify ★1678 - 为移动而生的Vue JS 2组件框架 https://github.com/vuetifyjs/vuetify 9、vonic ★1494 - 快速构建移动端单页应用 https://github.com/wangdahoo/vonic 10、eme ★1390 - 优雅的Markdown编辑器 https://github.com/egoist/eme 11、vue-multiselect ★1166 - Vue.js选择框解决方案 https://github.com/monterail/vue-multiselect 12、vue-table ★824 - 简化数据表格 https://github.com/ratiw/vue-table 13、VueCircleMenu ★776 - 漂亮的vue圆环菜单 https://github.com/OYsun/VueCircleMenu 14、vue-chat ★748 - vuejs和vuex及webpack的聊天示例 https://github.com/Coffcer/vue-chat 15、radon-ui ★633 - 快速开发产品的Vue组件库 https://github.com/luojilab/radon-ui 16、vue-waterfall ★605 - Vue.js的瀑布布局组件 https://github.com/MopTym/vue-waterfall 17、vue-carbon ★595 - 基于 vue 开发MD风格的移动端 https://github.com/myronliu347/vue-carbon 18、vue-beauty ★569 - 由vue和ant design创建的优美UI组件 https://github.com/FE-Driver/vue-beauty 19、vue-blu ★557 - 帮助你轻松创建web应用 https://github.com/chenz24/vue-blu 20、vueAdmin ★556 - 基于vuejs2和element的简单的管理员模板 https://github.com/taylorchen709/vueAdmin 21、vue-syntax-highlight ★551 - Sublime Text语法高亮 https://github.com/vuejs/vue-syntax-highlight 22、vue-infinite-scroll ★524 - VueJS的无限滚动指令 https://github.com/ElemeFE/vue-infinite-scroll 23、Vue.Draggable ★493 - 实现拖放和视图模型数组同步 https://github.com/David-Desmaisons/Vue.Draggable 24、vue-awesome-swiper ★476 - vue.js触摸滑动组件 https://github.com/surmon-china/vue-awesome-swiper 25、vue-calendar ★465 - 日期选择插件 https://github.com/jinzhe/vue-calendar 26、bootstrap-vue ★458 - 应用于Vuejs2的Twitter的Bootstrap 4组件 https://github.com/pi0/bootstrap-vue 27、vue-swipe ★361 - VueJS触摸滑块 https://github.com/ElemeFE/vue-swipe 28、vue-amap ★346 - 基于Vue 2和高德地图的地图组件 https://github.com/ElemeFE/vue-amap 29、vue-chartjs ★333 - vue中的Chartjs的封装 https://github.com/apertureless/vue-chartjs 30、vue-datepicker ★331 - 日历和日期选择组件 https://github.com/hilongjw/vue-datepicker 31、markcook ★318 - 好看的markdown编辑器 https://github.com/jrainlau/markcook 32、vue-google-maps ★287 - 带有双向数据绑定Google地图组件 https://github.com/GuillaumeLeclerc/vue-google-maps 33、vue-progressbar ★248 - vue轻量级进度条 https://github.com/hilongjw/vue-progressbar 34、vue-picture-input ★236 - 移动友好的图片文件输入组件 https://github.com/alessiomaffeis/vue-picture-input 35、vue-infinite-loading ★224 - VueJS的无限滚动插件 https://github.com/PeachScript/vue-infinite-loading 36、vue-upload-component ★204 - Vuejs文件上传组件 https://github.com/lian-yue/vue-upload-component 37、vue-datetime-picker ★197 - 日期时间选择控件 https://github.com/Haixing-Hu/vue-datetime-picker 38、vue-scroller ★196 - Vonic UI的功能性组件 https://github.com/wangdahoo/vue-scroller 39、vue2-calendar ★181 - 支持lunar和日期事件的日期选择器 https://github.com/icai/vue2-calendar 40、vue-video-player ★178 - VueJS视频及直播播放器 https://github.com/surmon-china/vue-video-player 41、vue-fullcalendar ★176 - 基于vue.js的全日历组件 https://github.com/Wanderxx/vue-fullcalendar 42、rubik ★170 - 基于Vuejs2的开源 UI 组件库 https://github.com/ccforward/rubik 43、VueStar ★169 - 带星星动画的vue点赞按钮 https://github.com/OYsun/VueStar 44、vue-mugen-scroll ★167 - 无限滚动组件 https://github.com/egoist/vue-mugen-scroll 45、mint-loadmore ★167 - VueJS的双向下拉刷新组件 https://github.com/mint-ui/mint-loadmore 46、vue-tables-2 ★162 - 显示数据的bootstrap样式网格 https://github.com/matfish2/vue-tables-2 47、vue-virtual-scroller ★158 - 带任意数目数据的顺畅的滚动 https://github.com/Akryum/vue-virtual-scroller 48、DataVisualization ★149 - 数据可视化 https://github.com/SimonZhangITer/DataVisualization 49、vue-quill-editor ★149 - 基于Quill适用于Vue2的富文本编辑器 https://github.com/surmon-china/vue-quill-editor 50、Vueditor ★138 - 所见即所得的编辑器 https://github.com/hifarer/Vueditor 51、vue-html5-editor ★132 - html5所见即所得编辑器 https://github.com/PeakTai/vue-html5-editor 52、vue-msgbox ★127 - vuejs的消息框 https://github.com/ElemeFE/vue-msgbox 53、vue-slider ★126 - vue 滑动组件 https://github.com/warpcgd/vue-slider 54、vue-core-image-upload ★124 - 轻量级的vue上传插件 https://github.com/Vanthink-UED/vue-core-image-upload 55、vue-slide ★121 - vue轻量级滑动组件 https://github.com/hilongjw/vue-slide 56、vue-lazyload-img ★118 - 移动优化的vue图片懒加载插件 https://github.com/JALBAA/vue-lazyload-img 57、vue-drag-and-drop-list ★114 - 创建排序列表的Vue指令 https://github.com/Alex-fun/vue-drag-and-drop-list 58、vue-progressive-image ★107 - Vue的渐进图像加载插件 https://github.com/MatteoGabriele/vue-progressive-image 59、vuwe ★107 - 基于微信WeUI所开发的专用于Vue2的组件库 https://github.com/vuwe/vuwe 60、vue-dropzone ★105 - 用于文件上传的Vue组件 https://github.com/rowanwins/vue-dropzone 61、vue-charts ★101 - 轻松渲染一个图表 https://github.com/hchstera/vue-charts 62、vue-swiper ★95 - 易于使用的滑块组件 https://github.com/weilao/vue-swiper 63、vue-images ★93 - 显示一组图片的lightbox组件 https://github.com/littlewin-wang/vue-images 64、vue-carousel-3d ★91 - VueJS的3D轮播组件 https://github.com/Wlada/vue-carousel-3d 65、vue-region-picker ★89 - 选择中国的省份市和地区 https://github.com/QingWei-Li/vue-region-picker 66、vue-typer ★89 - 模拟用户输入选择和删除文本的Vue组件 https://github.com/cngu/vue-typer 67、vue-impression ★88 - 移动Vuejs2 UI元素 https://github.com/NewDadaFE/vue-impression 68、vue-datatable ★87 - 使用Vuejs创建的DataTableView https://github.com/galenyuan/vue-datatable 69、vue-instant ★86 - 轻松创建自动提示的自定义搜索控件 https://github.com/santiblanko/vue-instant 70、vue-dragging ★86 - 使元素可以拖拽 https://github.com/hilongjw/vue-dragging 71、vue-slider-component ★85 - 在vue1和vue2中使用滑块 https://github.com/NightCatSama/vue-slider-component 72、vue2-loading-bar ★76 - 最简单的仿Youtube加载条视图 https://github.com/BosNaufal/vue2-loading-bar 73、vue-datepicker ★75 - 漂亮的Vue日期选择器组件 https://github.com/weifeiyue/vue-datepicker 74、vue-video ★70 - Vue.js的HTML5视频播放器 https://github.com/hilongjw/vue-video 75、vue-toast-mobile ★68 - VueJS的toast插件 https://github.com/ElemeFE/vue-toast-mobile 76、vue-image-crop-upload ★67 - vue图片剪裁上传组件 https://github.com/dai-siki/vue-image-crop-upload 77、vue-tooltip ★66 - 带绑定信息提示的提示工具 https://github.com/Akryum/vue-tooltip 78、vue-highcharts ★66 - HighCharts组件 https://github.com/weizhenye/vue-highcharts 79、vue-touch-ripple ★62 - vuejs的触摸ripple组件 https://github.com/surmon-china/vue-touch-ripple 80、coffeebreak ★61 - 实时编辑CSS组件工具 https://github.com/Kocisov/coffeebreak 81、vue-datasource ★60 - 创建VueJS动态表格 https://github.com/coderdiaz/vue-datasource 82、vue2-timepicker ★60 - 下拉时间选择器 https://github.com/phoenixwong/vue2-timepicker 83、vue-date-picker ★59 - VueJS日期选择器组件 https://github.com/Bubblings/vue-date-picker 84、vue-scrollbar ★58 - 最简单的滚动区域组件 https://github.com/BosNaufal/vue-scrollbar 85、vue-quill ★56 - vue组件构建quill编辑器 https://github.com/CroudSupport/vue-quill 86、vue-google-signin-button ★55 - 导入谷歌登录按钮 https://github.com/phanan/vue-google-signin-button 87、vue-svgicon ★53 - 创建svg图标组件的工具 https://github.com/MMF-FE/vue-svgicon 88、vue-float-label ★49 - VueJS浮动标签模式 https://github.com/bkzl/vue-float-label 89、vue-baidu-map ★46 - 基于 Vue 2的百度地图组件库 https://github.com/Dafrok/vue-baidu-map 90、vue-social-sharing ★45 - 社交分享组件 https://github.com/nicolasbeauvais/vue-social-sharing 91、vue2-editor ★44 - HTML编辑器 https://github.com/davidroyer/vue2-editor 92、vue-tagsinput ★41 - 基于VueJS的标签组件 https://github.com/Ginhing/vue-tagsinput 93、vue-easy-slider ★41 - Vue 2.x的滑块组件 https://github.com/shhdgit/vue-easy-slider 94、datepicker ★38 - 基于flatpickr的时间选择组件 https://github.com/vue-bulma/datepicker 95、vue-chart ★37 - 强大的高速的vue图表解析 https://github.com/miaolz123/vue-chart 96、vue-music-master ★37 - vue手机端网页音乐播放器 https://github.com/yunyi1895/vue-music-master 97、handsontable ★35 - 网页表格组件 https://github.com/vue-bulma/handsontable 98、vue-simplemde ★35 - VueJS的Markdown编辑器组件 https://github.com/F-loat/vue-simplemde 99、vue-popup-mixin ★35 - 用于管理弹出框的遮盖层 https://github.com/myronliu347/vue-popup-mixin 100、cubeex ★33 - 包含一套完整的移动UI https://github.com/fangyongbao/cubeex 101、vue-fullcalendar ★32 - vue FullCalendar封装 https://github.com/CroudSupport/vue-fullcalendar 102、vue-material-design ★32 - Vue MD风格组件 https://github.com/loujiayu/vue-material-design 103、vue-morris ★31 - Vuejs组件封装Morrisjs库 https://github.com/bbonnin/vue-morris 104、we-vue ★30 - Vue2及weui1开发的组件 https://github.com/tianyong90/we-vue 105、vue-image-clip ★29 - 基于vue的图像剪辑组件 https://github.com/legeneek/vue-image-clip 106、vue-bootstrap-table ★29 - 可排序可检索的表格 https://github.com/jbaysolutions/vue-bootstrap-table 107、vue-radial-progress ★28 - Vue.js放射性进度条组件 https://github.com/wyzant-dev/vue-radial-progress 108、vue-slick ★28 - 实现流畅轮播框的vue组件 https://github.com/staskjs/vue-slick 109、vue-pull-to-refresh ★27 - Vue2的上拉下拉 https://github.com/bajian/vue-pull-to-refresh 110、vue-form-2 ★26 - 全面的HTML表单管理的解决方案 https://github.com/matfish2/vue-form-2 111、vue-side-nav ★26 - 响应式的侧边导航 https://github.com/vue-comps/vue-side-nav 112、mint-indicator ★26 - VueJS移动加载指示器插件 https://github.com/mint-ui/mint-indicator 113、chartjs ★24 - Vue Bulma的chartjs组件 https://github.com/vue-bulma/chartjs 114、vue-scroll ★24 - vue滚动 https://github.com/suguangwen/vue-scroll 115、vue-ripple ★24 - 制作谷歌MD风格涟漪效果的Vue组件 https://github.com/BosNaufal/vue-ripple 116、vue-touch-keyboard ★22 - VueJS虚拟键盘组件 https://github.com/icebob/vue-touch-keyboard 117、vue-chartkick ★22 - VueJS一行代码实现优美图表 https://github.com/ankane/vue-chartkick 118、vue-ztree ★21 - 用 vue 写的树层级组件 https://github.com/lisiyizu/vue-ztree 119、vue-m-carousel ★20 - vue 移动端轮播组件 https://github.com/shiye515/vue-m-carousel 120、vue-datepicker-simple ★20 - 基于vue的日期选择器 https://github.com/dai-siki/vue-datepicker-simple 121、vue-tabs ★20 - 多tab页轻型框架 https://github.com/alexqdjay/vue-tabs 122、vue-verify-pop ★19 - 带气泡提示的vue校验插件 https://github.com/aweiu/vue-verify-pop 123、vue-parallax ★15 - 整洁的视觉效果 https://github.com/vue-comps/vue-parallax 124、vue-img-loader ★14 - 图片加载UI组件 https://github.com/JackGit/vue-img-loader 125、vue-typewriter ★13 - vue组件类型 https://github.com/eduardostuart/vue-typewriter 126、vue-smoothscroll ★12 - smoothscroll的VueJS版本 https://github.com/Teddy-Zhu/vue-smoothscroll 127、vue-city ★10 - 城市选择器 https://github.com/xinxingyu/vue-city 128、vue-tree ★10 - vue树视图组件 https://github.com/weibangtuo/vue-tree 129、vue-ios-alertview ★8 - iOS7+ 风格的alertview服务 https://github.com/Treri/vue-ios-alertview 130、dd-vue-component ★7 - 订单来了的公共组件库 https://github.com/ibufu/dd-vue-component 131、paco-ui-vue ★7 - PACOUI的vue组件 https://github.com/yeseason/paco-ui-vue 132、vue-cmap ★5 - Vue China map可视化组件 https://github.com/doodlewind/vue-cmap 133、vue-button ★4 - Vue按钮组件 https://github.com/steven5538/vue-button 开发框架 1、vue.js ★45466 - 流行的轻量高效的前端组件化方案 https://github.com/vuejs/vue 2、vue-admin ★3222 - Vue管理面板框架 https://github.com/fundon/vue-admin 3、electron-vue ★1273 - Electron及VueJS快速启动样板 https://github.com/SimulatedGREG/electron-vue 4、vue-2.0-boilerplate ★241 - Vue2单页应用样板​ https://github.com/petervmeijgaard/vue-2.0-boilerplate 5、vue-spa-template ★223 - 前后端分离后的单页应用开发 https://github.com/hanan198501/vue-spa-template 6、Framework7-Vue ★210 - VueJS与Framework7结合 https://github.com/nolimits4web/Framework7-Vue 7、vue-bulma ★132 - 轻量级高性能MVVM Admin UI框架 https://github.com/wangxg2016/vue-bulma 8、vue-webgulp ★100 - 仿VueJS Vue loader示例 https://github.com/rodzzlessa24/vue-webgulp 9、vue-element-starter ★34 - vue启动页 https://github.com/Metnew/vue-element-starter 实用库 1、vuex ★5997 - 专为 Vue.js 应用程序开发的状态管理模式 https://github.com/vuejs/vuex 2、vuelidate ★750 - 简单轻量级的基于模块的Vue.js验证 https://github.com/monterail/vuelidate 3、qingcheng ★677 - qingcheng主题 https://github.com/zerqu/qingcheng 4、vue-desktop ★461 - 创建管理面板网站的UI库 https://github.com/ElemeFE/vue-desktop 5、vue-meta ★257 - 管理app的meta信息 https://github.com/declandewet/vue-meta 6、vue-axios ★209 - 将axios整合到VueJS的封装 https://github.com/imcvampire/vue-axios 7、vue-svg-icon ★116 - vue2的可变彩色svg图标方案 https://github.com/cenkai88/vue-svg-icon 8、avoriaz ★110 - VueJS测试实用工具库 https://github.com/eddyerburgh/avoriaz 9、vue-framework7 ★83 - 结合VueJS使用的Framework7组件 https://github.com/lmk123/vue-framework7 10、vue-bootstrap-modal ★78 - vue的Bootstrap样式组件 https://github.com/Coffcer/vue-bootstrap-modal 11、vuep ★72 - 用实时编辑和预览来渲染Vue组件 https://github.com/QingWei-Li/vuep 12、vue-online ★67 - reactive的在线和离线组件 https://github.com/Sopamo/vue-online 13、vue-lazy-render ★66 - 用于Vue组件的延迟渲染 https://github.com/yeyuqiudeng/vue-lazy-render 14、vue-password-strength-meter ★65 - 交互式密码强度计 https://github.com/apertureless/vue-password-strength-meter 15、element-admin ★57 - 支持 vuecli 的 Element UI 的后台模板 https://github.com/lynzz/element-admin 16、vue-electron ★55 - 将选择的API封装到Vue对象中的插件 https://github.com/SimulatedGREG/vue-electron 17、cleave ★55 - 基于cleave.js的Cleave组件 https://github.com/vue-bulma/cleave 18、vue-events ★54 - 简化事件的VueJS插件 https://github.com/cklmercer/vue-events 19、vue-shortkey ★53 - 应用于Vue.js的Vue-ShortKey 插件 https://github.com/iFgR/vue-shortkey 20、vue-cordova ★50 - Cordova的VueJS插件 https://github.com/kartsims/vue-cordova 21、vue-router-transition ★49 - 页面过渡插件 https://github.com/weinot/vue-router-transition 22、vue-gesture ★48 - VueJS的手势事件插件 https://github.com/mlyknown/vue-gesture 23、http-vue-loader ★46 - 从html及js环境加载vue文件 https://github.com/FranckFreiburger/http-vue-loader 24、vue-qart ★46 - 用于qartjs的Vue2指令 https://github.com/superman66/vue-qart 25、vuemit ★44 - 处理VueJS事件 https://github.com/gocanto/vuemit 26、vue-websocket ★42 - VueJS的Websocket插件 https://github.com/icebob/vue-websocket 27、vue-local-storage ★41 - 具有类型支持的Vuejs本地储存插件 https://github.com/pinguinjkeke/vue-local-storage 28、lazy-vue ★41 - 懒加载图片 https://github.com/gocanto/lazy-vue 29、vue-bus ★36 - VueJS的事件总线 https://github.com/yangmingshan/vue-bus 30、vue-reactive-storage ★35 - vue插件的Reactive层 https://github.com/ropbla9/vue-reactive-storage 31、vue-notifications ★32 - 非阻塞通知库 https://github.com/se-panfilov/vue-notifications 32、vue-lazy-component ★32 - 懒加载组件或者元素的Vue指令 https://github.com/Coffcer/vue-lazy-component 33、v-media-query ★32 - vue中添加用于配合媒体查询的方法 https://github.com/AStaroverov/v-media-query 34、vue-observe-visibility ★31 - 当元素在页面上可见或隐藏时检测 https://github.com/Akryum/vue-observe-visibility 35、vue-ts-loader ★29 - 在Vue装载机检查脚本 https://github.com/HerringtonDarkholme/vue-ts-loader 36、vue-pagination-2 ★28 - 简单通用的分页组件 https://github.com/matfish2/vue-pagination-2 37、vuex-i18n ★26 - 定位插件 https://github.com/dkfbasel/vuex-i18n 38、Vue.resize ★26 - 检测HTML调整大小事件的vue指令 https://github.com/David-Desmaisons/Vue.resize 39、vuex-shared-mutations ★25 - 分享某种Vuex mutations https://github.com/xanf/vuex-shared-mutations 40、vue-file-base64 ★16 - 将文件转换为Base64的vue组件 https://github.com/BosNaufal/vue-file-base64 41、modal ★15 - Vue Bulma的modal组件 https://github.com/vue-bulma/modal 42、Famous-Vue ★15 - Famous库的vue组件 https://github.com/irwansyahwii/Famous-Vue 43、leo-vue-validator ★13 - 异步的表单验证组件 https://github.com/LeoHuiyi/leo-vue-validator 44、Vue-Easy-Validator ★11 - 简单的表单验证 https://github.com/MetinSeylan/Vue-Easy-Validator 45、vue-truncate-filter ★9 - 截断字符串的VueJS过滤器 https://github.com/imcvampire/vue-truncate-filter 46、vue-zoombox ★9 - 一个高级zoombox https://github.com/vue-comps/vue-zoombox 47、vue-input-autosize ★5 - 基于内容自动调整文本输入的大小 https://github.com/syropian/vue-input-autosize 48、vue-lazyloadImg ★3 - 图片懒加载插件 https://github.com/yodfz/vue-lazyloadImg","categories":[{"name":"前端","slug":"前端","permalink":"https://visen123.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://visen123.github.io/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"Android开发工程师必备工具","slug":"categories/工具/Android开发工程师必备工具","date":"2021-09-02T10:00:13.000Z","updated":"2021-09-07T13:59:22.729Z","comments":true,"path":"2021/09/02/categories/工具/Android开发工程师必备工具/","link":"","permalink":"https://visen123.github.io/2021/09/02/categories/%E5%B7%A5%E5%85%B7/Android%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7/","excerpt":"","text":"1.Android StudioAndroid程序员的吃饭工具，可以说现在绝大部分的安卓项目都是跑在Android Studio上面的。Android Studio 是基于 IntelliJ IDEA 且适用于开发 Android 应用的官方集成开发环境 (IDE)，功能非常强大，使用体验相当好，从我的使用感觉来说比Visual Studio要好。 最新版本: 稳定版4.2.2(20210725记录)下载地址: https://developer.android.google.cn/studio2.必备的网站作为一名程序员，查看文档不可避免，遇到问题要懂得从文档中查找解决方法，也需要搜索下别人的解决方案，下面是安卓日常开发中打开频率最高的网站。 安卓开发指南，https://developer.android.google.cn/guideJava文档，https://docs.oracle.com/javase/8/docs/api/kotlin文档，https://www.kotlincn.net/开源项目查找，https://github.com/安卓源码在线查看，http://aospxref.com/编程问答，https://stackoverflow.com/在线画流程与UML图，https://www.processon.com/3.PxCookUI是安卓开发中必不可少的元素，如何将UI设计图完美地实现呢？有一种做法是UI将各个元素的距离标注出来的，然后开发者再将数值在布局中写入，以此来达到还原设计图稿的目的。但只要有了PxCook这个神器，UI会开心地蹦起来的，从此元素布局就是如此地简单。能标注每个元素的大小，能自动生成参考xml，如果安装了PhotoShop还能切图，UI设计师只要给一个psd文件就完成工作了，皆大欢喜。 下载地址：https://www.fancynode.com.cn/pxcook4.jd-gui在开发过程中如果想查看某个下载到的开源库里边源代码，那就需要一个反编译工具，大部分源码是以jar包的形式存在的，jd-gui就是一个强大的反编译工具，使用也很方便，直接把jar包拖入窗口即能看到源码。下载地址：http://java-decompiler.github.io/ 5.Total-Control手机投屏在调试过程中是一个相当便利的功能，如果在电脑上能直接操控调试的手机就方便许多了，不需要再到手机上点按钮走业务流程。Total-Control就是一个强大的投屏软件，能直接用鼠标操作手机，还能同时连接多部设备，非常实用。下载地址：http://tc.sigma-rt.com.cn/ 6.Visual Studio Code微软开源的一个文本编辑器，同时也可用以代码编辑，强大好用，也有插件拓展，适合用于平时快速打开和查看一些单独的代码文件下载地址：https://code.visualstudio.com/20210725注：这篇文章之前版本推荐的文本编辑器是notepad++,但是之前没发现notepad++软件的作者竟然在版本发布说明中夹带私货，对于xg的事情说三道四，详情可查看这里release7.8.9开始，希望大家以后不要再使用这个软件，以免助长notepad++作者的猖狂之志。我已卸载notepad++并且以后不再用。 7.Postman接口调试神器，支持GET,POST,PUT等各种HTTP操作，是用来测试后台接口相当实用的一个工具。下载地址：https://www.postman.com/downloads/ 8.SQLite Expert Personal安卓集成了一个轻量数据库SQLite,如果想要查看设备中生成的sqlite数据库数据，可以导出到电脑进行浏览，而SQLite Expert Personal就是一个免费的sqlite查看工具。下载地址：http://www.sqliteexpert.com/download.html 9.Typora一款界面简洁、功能强大的markdown编辑器，平时用以记录文档最合适不过。下载地址：https://www.typora.io/ 10.Xmind制作思维导图的工具，有结构层次地记录下一些想法或者是对业务流程的层次进行梳理，xmind的界面设计非常优秀，用起来很舒服。下载地址：https://www.xmind.cn/","categories":[{"name":"工具","slug":"工具","permalink":"https://visen123.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[],"keywords":[{"name":"工具","slug":"工具","permalink":"https://visen123.github.io/categories/%E5%B7%A5%E5%85%B7/"}]},{"title":"java后端技术","slug":"categories/后端/java后端技术","date":"2021-08-31T08:00:13.000Z","updated":"2021-08-31T15:29:58.387Z","comments":true,"path":"2021/08/31/categories/后端/java后端技术/","link":"","permalink":"https://visen123.github.io/2021/08/31/categories/%E5%90%8E%E7%AB%AF/java%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/","excerpt":"","text":"服务框架：Dubbo，zookeeper，Rest服务缓存：redis，ehcache消息中间件：ActiveMQ，kafka负责均衡：Nginx分布式文件：FastDFS安全框架：Apache shiro任务调度：quartz持久层框架：mybatis日志：log4j项目基础搭建。spring，springmvc，环境搭建：linux下，开发工具：eclipse。idea等服务器：tomcat，jetty等 目前系统主流搭建：Nginx+tomcat+mybatis+redis。针对不同的业务需求，我们会引用不同的技术。 这些主要定位于互联网企业架构 框架简介： 企业信息化系统基础功能和高效的代码生成工具，包括: 系统权限组件，数据权限组件，数据字典组件，核心工具组件，视图操作组件，工作流组件，代码生成等。采用分层设计，双重验证。提交数据安全编码，密码加密，访问验证，，数据权限验证、 平台简介： 是一个分布式的框架。提供项目模块化，服务化。热插拔的思想。高度封装安全性的java EE快速开发平台。 本身集成Dubbo服务管控，zookeeper注册中心。Redis分布式缓存技术。FastDFS分布式文件吸系统。ActiveMQ异步消息中间件，Nginx负责均衡等分布式技术。 使用maven做项目管理，项目模块化。提供项目的易开发性，扩展性。 以spring Framework为核心容器。SpringMVC为模型视图控制器，mybatis为数据访问层，Apache shiro为权限授权层。Ehcache对常用数据进行缓存。Activit为工作流引擎等。 前端集成bootstrap 框架。响应式 目前包括以下模块项目，后台系统管理系统。RestFull独立服务系统，Schedule定时调度系统，内容管理（CMS）系统，在线办公（OA）系统。我的待办（Task服务），我的收藏（bookmark服务） 提供了常用工具进行封装，包括日志工具、缓存工具、服务器端验证、数据字典、当前组织机构数据（用户、机构、区域）以及其它常用小工具等。另外 还提供一个强大的在线 代码生成 工具，此工具提供简单的单表、一对多、树结构功能的生成，如果对外观要求不是很高，生成的功能就可以用了。使用了基础框架，可以提高快速开发效 率。 内置功能(只列了一部分功能) 1.用户管理：用户是系统操作者，该功能主要完成系统用户配置。 2.机构管理：配置系统组织机构（公司、部门、小组），树结构展现，可随意调整上下级。 3.区域管理：系统城市区域模型，如：国家、省市、地市、区县的维护。 4.菜单管理：配置系统菜单，操作权限，按钮权限标识等。 5.角色管理：角色菜单权限分配、设置角色按机构进行数据范围权限划分。 6.字典管理：对系统中经常使用的一些较为固定的数据进行维护，如：是否、男女、类别、级别等。 7.操作日志：系统正常操作日志记录和查询；系统异常信息日志记录和查询。 8.连接池监视：监视当期系统数据库连接池状态，可进行分析SQL找出系统性能瓶颈。 9.工作流引擎：实现业务工单流转、在线流程设计器。 开发工具 1.Eclipse IDE：采用Maven项目管理，模块化。 2.代码生成：通过界面方式简单配置，自动生成相应代码，目前包括三种生成方式（增删改查）：单表、一对多、树结构。生成后的代码如果不需要注意美观程度，生成后即可用。 技术选型（只列了一部分技术） 1、后端 服务框架：Dubbo、zookeeper、Rest服务 缓存：Redis、ehcache 消息中间件：ActiveMQ 负载均衡：Nginx 分布式文件：FastDFS 数据库连接池：Alibaba Druid 1.0 核心框架：Spring framework 安全框架：Apache Shiro 1.2 视图框架：Spring MVC 4.0 服务端验证：Hibernate Validator 5.1 布局框架：SiteMesh 2.4 工作流引擎：Activiti 5.15 任务调度：quartz 1.8.5 持久层框架：MyBatis 3.2 日志管理：SLF4J 1.7、Log4j 工具类：Apache Commons、Jackson 2.2、Xstream 1.4、Dozer 5.3、POI 2、前端 JS框架：JQuery 1.9。 CSS框架： Bootstrap 4 metronic 客户端验证：JQuery Validation Plugin。 富文本：CKEcitor 文件管理：CKFinder 动态页签：Jerichotab 数据表格：jqGrid 对话框：jQuery jBox 树结构控件：jQuery zTree 其他组件：Bootstrap 4 metronic 3、支持 服务器中间件：Tomcat 6、7、Jboss 7、WebLogic 10、WebSphere 8 数据库支持：目前仅提供mysql数据库的支持，但不限于数据库，下个版本升级多数据源切换和数据库读写分离： 如：Oracle、SqlServer、H2等 支持开发环境：Eclipse、MyEclipse、Ras、Idea等","categories":[{"name":"后端","slug":"后端","permalink":"https://visen123.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"后端","slug":"后端","permalink":"https://visen123.github.io/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"WEB开发技术 知识点总结","slug":"categories/前端/WEB开发技术","date":"2021-08-26T07:00:16.000Z","updated":"2021-08-31T15:30:02.311Z","comments":true,"path":"2021/08/26/categories/前端/WEB开发技术/","link":"","permalink":"https://visen123.github.io/2021/08/26/categories/%E5%89%8D%E7%AB%AF/WEB%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/","excerpt":"","text":"WEB开发技术 知识点总结 第一章：（填空判断） 1、什么是WWW WWW是World Wide Web的缩写，中文译名“万维网”。 Web是Internet提供的一种服务，是基于Internet、采用Internet协议的一种体系结构。 2、Web三要素: 统一资源定位（URL）：解决网上资源在何处的问题。 资源访问方式（HTTP）：解决用什么方法访问资源的问题。 超链接：提供在资源之间自由访问的手段。 3、什么是URL （Universal Resource Locator）? URL中文名为“统一资源定位器”。每一个站点及站点上的每个网页都有一个唯一的地址，向浏览器输入URL，可以访问URL指出的Web网页。 URL的基本结构为： 通信协议://服务器名称[:通信端口号]/文件夹…/文件名 http://www.163.com:2100/bbs/index.htm 4、HTTP 是在Internet上传送超文本的协议，它是运行在TCP/IP集之上的应用协议。简单地说，HTTP就是专门为WWW设计的协议。 5、C/S模式(Client/Server) C/S计算模式将应用一分为二：前端是客户机，几乎所有的应用逻辑都在客户端进行和表达，客户机完成与用户的交互任务。后端是服务器，它负责后台数据的查询和管理、大规模的计算等服务。通常客户端的任务比较繁重，称作“肥”客户端，而服务器端的任务较轻，称作“瘦”服务器。 C/s模式 6、B/S模式 B/S模式是一种基于Web的协同计算模式，是一种三层架构的瘦客户机/肥服务器的计算模式。 第一层为客户端表示层，客户层只保留一个Web浏览器，不存放任何应用程序，其运行代码可以从位于第二层Web服务器下载到本地的浏览器中执行，几乎不需要任何管理工作。第二层是应用服务器层，由一台或多台服务器（Web服务器也位于这一层）组成，处理应用中的所有业务逻辑，包括对数据库的访问等工作，该层具有良好的可扩充性，可以随着应用的需要任意增加服务的数目。第三层是数据中心层，主要由数据库系统组成。B/s模式 7、Web服务器端开发技术 CGI技术 JSP(Java Server Pages)技术 ASP(Active Server Pages)与ASP.NET技术 PHP(Personal Homepage Tools)技术、ASP.NET、PHP技术 8、Web客户端开发技术 HTML、CSS、脚本、XML/XHTML/Ajax/ JSON Javascript特性主要包括： 通过JavaScript的XMLHttpRequest对象实现异步请求与调用。 通过JavaScript对XML进行解析和处理。 通过JavaScript操作DOM来实现客户端的动态显示。 第二章：（简答题） 9、在选择网站主题的时候要注意以下3点： 主题小而内容精，创新的内容很重要； 题材最好是自己擅长的内容； 题材不要太滥，目标不要过高。 10、在选择网站名称的时候要注意以下3点： 名称要端正； 名称要易记； 名称要有特色。 11、设计网站的标志 站点标志作用类似于商标，它是网站特色和内涵的集中体现。 最常用和最简单的方式是用自己网站的名称作为标志，采用不同的字体、字母的变形或组合可以很容易制作好自己的标志。 12、在配色的时候要把握以下原则： 网站要有一个主色调； 要深浅搭配； 保持整个网站颜色的统一性。 13、在选择网站栏目的时候要注意以下4点： 紧扣网站主题； 设计一个最近更新或网站指南栏目； 设计一个可以互动交流的栏目； 设计一个下载或常见问题回答栏目。 14、设计网站的目录结构 不要将网站内容全部放在一个目录中，按菜单栏目内容建立子目录。 目录的层次不要太深，尽量用英文命名目录和文件名。 目录一般不超过3层。目录路径过深，跳转的URL地址就会变长，会增加页面链接的复杂性。 15、Web站点的链接结构有三种基本方式： 1）树状链接结构：首链接指向以及页面，一级页面链接指向二级页面。用户可以一级级进入，一级级退出。 2）星状链接结构：结构中的每个页面相互之间都直接建立了连接。 3）混合结构：首页和一级页面之间用星形链接结构，一级和二级、二级和三级页面之间均采用树形结构。 16、配色原则 对于网站的色彩处理原则应该是“总体协调，局部对比”。 三原色：红、绿、蓝 （2）色彩的特征 色调：表现色彩的种类； 亮度：表现色彩的明亮程度； 饱和度：表现色彩的鲜艳程度。 （3）色彩的分类 按照色彩对人们心理的影响可以进行以下分类。 暖色系：红、橙、橙黄、黄等色彩让人感觉温馨、热情； 中性系：黄绿、绿等色彩让人觉得舒适、和谐； 冷色系：青绿、蓝绿、蓝等色彩让人觉得宁静、高雅。 第三章： 17、 什么是IIS？ Internet 信息服务（Internet Informationn Server，IIS）是一组Windows操作系统组件，此组件可以使公司很方便的创建自己的Web服务器、FTP服务器以及简单的SMTP和NNTP服务器，很方便地将信息和业务应用程序发布到 Web中。 18、 什么是 Tomcat Tomcat是当前使用最为广泛的Servlet/JSP服务器。它是由JavaSoft和Apache开发团队合作计划的产品，被Sun公司作为官方推荐的servlet和jsp容器。具有运行稳定，性能可靠，免费的特点，是学习Web开发的最佳选择。 19、 什么是Apache Apache是使用最广的Web服务器之一，它可以运行在几乎所有广泛使用的计算机平台上，以高效、稳定、安全、免费而著称，60%的Web服务器采用Apache。用户可以从Apache网站下载Apache服务器软件。 第四章： 20、HTML5中：&lt;meta charset=“gb2312”/ 21、HTML5的声明： 22、标签：1）…：定义文档标题。编写每个网页时，都应该指定一个标题，显示在浏览器标题栏上。2）...：用于在页面中加入脚本程序。语法格式：...。3）：用于为页面上所有链接规定默认地址或默认目标。语法格式：&lt;base href=”基准地址”target=”目标窗口名称”&gt;…。4）：显示该文档和其他文档之间的链接关系。例如：。5）：在标签中可以含有任意数量的标签。该标签用于在文档中嵌入样式表单，常称为内部样式。6）meta标签–head区的一个辅助性标签。提供的信息是用户不可见的，用于包含于文档相关的信息。Meta标签常见的两种属性：http-equiv属性和name属性。 23、标题文字标记：用来标示页面中的标题文字，被标示的文字将以粗体形式显示。作为标题的文字(其中n=1,2.……6） 24、段落标记：① 段落可以以段落为单位设置文字的对齐方式，形式如下：段落文字 ② 换行标记 是个空标签，用于另起一行，中间不插入空行。③ 预格式化标记HTML文档会忽略文本中的空格、换行符等，而使用标签可以保留它们，按照原样显示文本，实现“所见即所得”的效果。形式如下：这里是多行文本 25、插入水平线：有时为了较明显地划分上下各部分的内容，在文档中间加入一些水平线，使用形式如下： 26、加入图像：要在网页的某个位置放置一个图像，使用标签。 27、表格标记：要在网页中插入一个表格，需要用到一组标签，分别表示整个表格的属性、表格中一行的属性和表格中一列的属性。定义表格的有关标签如下：…：定义表格 …：定义表行 …：定义列标题，多数浏览器显示为粗体居中文字 …：定义表格数据单元 28、表格结构： 表格标题 第1列标题 第2列标题 列内容 列内容 29、表格的另一种定义方法： …定义表格的表头 …对HTML中表格中的主体内容进行分组 …定义表格的页脚（脚注或表注） 30、无序列表标记… 格式： 列表内容列表内容 … Disk:加重符号是实心圆点（默认） Circle:加重符号是空心圆点 Square:加重符号是实心方块 31、有序列表… 列表内容列表内容… 这里的li，可以有value属性，即把这一项的列表编号制定为特定值。 32、 定义列表标记… 术语术语的定义1… 术语 术语的定义2 dl有可选属性compact，使用该属性使术语和定义在同一行显示 33、超链接标记： 超链接显示内容 作用：单击“超链接显示内容”将跳转到“要连接到的URL” 处。1）链接到其他站点 新浪网 2）链接到本站内的某一页面 公司简介 3）图像链接 4）链接到电子信箱 电子信箱地址 5）在新窗口打开链接 新浪网 6）链接到本页的其他地方书签位置文字超链接显示内容 7）热点链接： 热点链接也叫图像映射，属于另一种形式的超链接。它是一个能对链接指示做出反应的图形或文本框，单击该图形或文本框的已定义区域，可跳转到与该区域相连接的目标。存在两种创建图像映射的方法：在标签中使用标签和标签① 标签负责为图像创建映射，紧跟在标签后；② 标签负责定义可单击的热点的边界形状和坐标，area 元素始终嵌套在 标签内部。在标签中使用标签 34、表单使用的一般形式为：&lt;form action=“URL” method=“get/post” autocomplete=on|off&gt;表单域的定义 1)输入标记… ① 文本框text和密码框password ② 单选框和复选框 单选框教师学生医生 复选框游泳唱歌上网 2) 列表框标记… 3) 文本输入区标记 初始文本 4)标签 姓名 35、文字移动（走马灯） 移动的文字 scroll:不断的从一边移到另一边 slide:从一边移到另一边，然后停止 alternate:来回移动 36、div&gt;标签和标签 …：块元素，用来设置字、图、表格等的摆放位置。 …：对行内元素进行分组，以便通过样式对它们进行格式化。 第六章 37、浮动窗口… 可以将一个HTML文档嵌入到另一个HTML中显示。 38、CSS的定义：1. CSS的定义是由三个部分构成： ①选择符（selector）:样式要套用的对象 ②属性（properties） ③属性的取值（value） 2. 基本格式如下： selector{property:value}（选择符{属性:值}）例如：h1{color:blue} 3. 如果属性的值是多个单词，必须在值上加引号，比如字体的名称经常是几个单词的组合：p{font-family: “sans serif”} 39、CSS中的选择符： CSS中有六种选择符：HTML标记、具有上下文关系的HTML标记、用户自定义类选择符、用户定义的ID选择符、虚类、虚元素。 1. HTML标记类选择符 格式：HTML标记 {属性:值} 如：select, textarea {font-size:13px} 2. 具有上下文关系的HTML标记类选择符 如：div p{color:blue} 3. 用户定义的类选择符 ① 格式：HTML标记.类名{属性:值} 使用类选择符能够把相同的元素分类定义不同的样式，如： p.right {text-align: right} p.center {text-align: center} 40、ID选择符 定义ID选择符要在ID名称前加上一个“#”号。 ① HTML标记#IDname{} 例：p#intro{ font-size:110%; font-weight:bold; color:#0000ff; background-color:transparent } ② #IDname{} 例： #intro { font-size:110%; font-weight:bold; color:#0000ff; background-color:transparent } 41、优先级： ID选择符 &gt; 类选择符 &gt; HTML标记选择符 如果想超越这三者之间的关系，可以用!important提升样式表的优先权。 42、样式表应用 有四种方法将样式表的功能应用到Web页面中： 1. 直接定义HTML标记中的style属性 2. 定义内部样式表 3. 嵌入外部样式表 4. 链接外部样式表 43、直接定义HTML标记中的style属性 &lt;HTML标记名称 style=“属性1：值1；属性2：值2；…”&gt; 例如： 这是一个段落 （这个段落颜色为蓝色，左边距为20象素） 44、定义内部样式表 &lt;!— hr {color: sienna} p {margin-left: 20px} body {background-image: url(“images/back40.gif”)} –&gt; 45、 嵌入外部样式表 46、 链接外部样式表 rel=“stylesheet”是指在页面中使用这个外部的样式表。 type=“text/css”是指文件的类型是样式表文本。 href=“mystyle.css”是文件所在的位置。 media表示使用样式表的网页将用什么媒体输出。 47、 48、 49、 50、文本属性① 文本修饰（text-decoration） ：在文本中添加underline（下划线）、overl（上划线）、line-through（中划线）、blink（闪烁效果）、none（不显示上述任何效果）。 基本格式：text-decoration：参数 ② 行高（line-height）: 设置文本所在行的行高。默认为normal,行间距离取值：①不带单位的数字，以1为基数，相当于比例关系的100%；②带长度单位的数字；③比例关系。 基本格式：line-height：行间距离 ③ 文本横向排列（text-align）: 可以控制文本的水平对齐。left（左对齐）、right（右对齐）、center（居中）、justify（相当于左右对齐）。 基本格式：text-align：参数 4 文本缩进（text-indent）: 设置文本块中首行的缩进。 基本格式：text-indent：length 其中，length属性值可以是百分比数字，也可以是由浮点数和单位标识符组成的长度值，允许负值。 第七章 51、数组 数组就是由一组数值按照顺序排列在一起，放在同一个变量中，而每个数值都可以利用索引（Index）来得到数组中所存储的信息。 注：JavaScript中，数组的长度都是变长的。 52、JavaScript有6种数据类型：主要的类型有Number、String、Object以及Boolean。其他两种类型为Null和Undefined。 53、String数据类型① 字符串是用单引号或双引号来说明的。 var s1=”The cow jumped over the moon.” var sColor=“blue”； var sColor=‘blue’; ② String类型是唯一没有固定大小的原始类型。可以用字符串存储零个或多个统一编码的字符。③ 转义字符。如：\\n，\\t，\\b，\\等。 54、数值数据类型1. 整数可以以十进制、八进制和十六进制来表示。 ① 八进制整数用前导“0”指明。 ② 十六进制整数用前导“0x”指明，其中“x”大小写均可。 定义浮点值，必须包括小数点和小数点后的一位数字。对于非常大或非常小的数，可用科学计数法表示。 55、Boolean类型 有true和false两个值。分别表示逻辑真和逻辑假。 56、字符串运算符 字符串运算符主要是运算符“+”和它的变形形式“+=”。 例如：var result=5+“5”–“55” var result=true +“56”–“true56” 57、JavaScript 函数 函数定义 function函数名（参数表）{ 语句块；} function 函数名（参数表）{ 语句块； return [表达式]；} return语句的功能是当调用函数时返回值。 58、JavaScript的常用函数 1. eval()函数 eval()函数可以对以字符串形式表示的任意有效的JavaScript代码求值。 2、 parseInt()函数和parseFloat()函数 parseInt()函数功能是从一个字符串中提出一个整数，如果遇到字符串中除了数字以外的字符，parseInt()就停止转换，返回已有的结果。 如果第一个字符不是数字，parseInt()就返回“NaN”值。 语法：parseInt(string, [radix]) 59、JavaScript的事件 超级链接事件主要包括： Click, 浏览器事件主要包括：各种元素 Load, Unload 等 60、单击事件 鼠标单击事件是最常见的事件，语法非常简单： οnclick=函数或是处理语句 61、onchange事件 onchange事件是当某个HTML元素的内容改变的时候发生的事件 。 οnchange= 处理函数或是处理语句 （onselect事件是当某个HTML元素的内容被选中的时候发生的事件 。 onfocus事件是当光标落在某个HTML元素，使它得到焦点时候发生的事件 。 onblur事件是某个HTML元素失去焦点的时候发生的事件。） 62、JavaScript的对象 JavaScript中的对象是由属性和方法两个基本的元素构成的。 在JavaScript中使用一个对象可采用以下三种方式： ① 引用JavaScript内置对象； ② 用户自定义对象； ③ 引用浏览器对象。 63、必考 JavaScript内置对象 时间对象（Date对象） 时间对象使用前必须先声明，如：var cur=new Date() 注意Date()的首字母必须大写。 64、Math对象 Math对象可以用来处理各种数学运算。Math对象的内置方法定义了各种数学运算和可以直接调用的Math对象的方法。特点：静态对象，不需实例化。 65、 String对象 一般利用String对象提供的函数来处理字符串。 [var] String对象实例名=字符串值 String对字符串的处理主要提供了下列方法： ① charAt(idx): 返回指定位置处的字符 ② indexOf(str): 返回指定子字符串的位置，从左到右 ④ toLowerCase( ): 将字符串中的字符全部转化成小写 ⑤ toUpperCase( ): 将字符串中的字符全部转化成大写 66、Array对象 特点：可变长。 67、 定时器必考 window对象 ⑤ alert(message)：用于弹出一个消息对话框。⑥ confirm(message)：用于弹出一个可以确认的对话框，提供了OK和Cancle两种选择。结果返回布尔值。 ⑦ prompt(message, defaultInput)：用于弹出一个可以输入文字的对话框。 ⑧ setTimeout(expression,time)：设置暂停，等待多少毫秒执行某代码。 clearTimeout(timer)：取消原来的时间控制器内的时间设置。 ⑨ setInterval(expression,time)：以指定的时间间隔重复执行某一功能。 clearInterval(timer) 68、document对象 常用属性: 1）title, lastModified, location 2）forms:数组，保存网页中所有的表单 常用方法： 1）write(string):向网页中输出文字 2）writeln(string):向网页中输出一行文字 69、知道怎样访问表单中的一个标题 form对象 主要属性： elements 元素数组，存储表单中的所有控件对象。对表单中的属性域，可以通过“表单名.elements[下标]”来访问，也可以通过“表单名.控件名”来访问，例如myform.elements[0]、myform.account 70、代码例子 例7-28：在网页中插入一张图片，使图片具有闪烁效果。if(angel.style.visibility==”visible”)angel.style.visibility=”hidden”;else angel.style.visibility=”visible”; 例7-29：在网页中插入一张图片，使图片产生水中倒影效果。例7-30：在网页中屏蔽鼠标右键，使网页内容不能被选择、拖拽、复制等。 例7-31：在网页中显示距离新年的倒计时。 例7-32 走马灯效果。 例7-33： 在标题栏动态显示时间。 例7-34：产生随即验证码。 第八章： 71、Ajax的定义 Ajax (Asynchronous JavaScript and XML)不是一个新的技术，事实上，它是一些旧有的成熟的技术以一种全新的更加强大的方式整合在一起","categories":[{"name":"前端","slug":"前端","permalink":"https://visen123.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://visen123.github.io/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"Android Jetpack架构组件Navigation管理Fragment框架","slug":"categories/Android/Android-Jetpack架构组件Navigation管理Fragment框架","date":"2021-08-21T13:26:42.000Z","updated":"2021-09-01T04:47:49.293Z","comments":true,"path":"2021/08/21/categories/Android/Android-Jetpack架构组件Navigation管理Fragment框架/","link":"","permalink":"https://visen123.github.io/2021/08/21/categories/Android/Android-Jetpack%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6Navigation%E7%AE%A1%E7%90%86Fragment%E6%A1%86%E6%9E%B6/","excerpt":"","text":"Navigation目前仅AndroidStudio 3.2以上版本支持，如果您的版本不足3.2， 下载AndroidStudio3.2以上版本。官网下载地址：https://developer.android.google.cn/studio/ 快速开发， 组件可单独使用，也可以同时工作。 消除样板 ，让代码Android 架构Jetpack管理乏味的活动事件，比如后台任务、导航和生命周期管理。这样你可以专注于让你的app更棒的东西，构建高质量、健壮的app 基于现代设计实践，Android Jetpack组件可以减少崩溃和内存泄漏，且向后兼容。接下来讲述Navigation的使用以及如何管理多个Fragment等 项目builde.gradle文件需配置： implementation “androidx.navigation:navigation-fragment-ktx:2.3.0-alpha05”implementation “androidx.navigation:navigation-ui-ktx:2.3.0-alpha05” 1.创建MainActivity和布局文件activity_navigation布局里配置: activity_navigation.xml布局配置： &lt;com.google.android.material.bottomnavigation.BottomNavigationView android:id=”@+id/bottom_nav_view” android:layout_width=”match_parent” android:layout_height=”wrap_content” app:labelVisibilityMode=”labeled” app:menu=”@menu/bottom_nav_menu” /&gt; MainActivity里配置： val host: NavHostFragment = supportFragmentManager .findFragmentById(R.id.my_nav_host_fragment) as NavHostFragment? ?: return val navController = host.navController val bottomNav = findViewById(R.id.bottom_nav_view) bottomNav?.setupWithNavController(navController) 2、新建HomeFragment、FlowStepFragment、FlowStepFragment、SettingsFragment、DeepLinkFragment在Fragment片段里跳片段方法 方法1： view.findViewById(R.id.navigate_destination_button).setOnClickListener( Navigation.createNavigateOnClickListener(R.id.next_action) ) 方法2： view.findViewById(R.id.navigate_destination_button)?.setOnClickListener { findNavController().navigate(R.id.flow_step_one_dest, null, null) } 3、在res里新建文件夹navigation 类型选择Navigation，然后在这个文件夹里创建mobile_navigation.xml 在mobile_navigation.xml里写入要跳转的各个片段Fragment及要传递的参数： startDestination默认第一个跳的片段iddestination跳到另外一个片段idaction 隐式跳转 ，argType传递参数类型，defaultValue传递参数值 &lt;!--todo destination隐式跳转到Fragement id=flow_step_one_dest --&gt; &lt;action android:id=&quot;@+id/next_action&quot; app:destination=&quot;@+id/flow_step_one_dest&quot; app:enterAnim=&quot;@anim/slide_in_right&quot; app:exitAnim=&quot;@anim/slide_out_left&quot; app:popEnterAnim=&quot;@anim/slide_in_left&quot; app:popExitAnim=&quot;@anim/slide_out_right&quot; /&gt; &lt;action android:id=&quot;@+id/next_action&quot; app:destination=&quot;@+id/flow_step_two_dest&quot;&gt; &lt;/action&gt; &lt;argument android:name=&quot;flowStepNumber&quot; app:argType=&quot;integer&quot; android:defaultValue=&quot;2&quot;/&gt; &lt;action android:id=&quot;@+id/next_action&quot; app:destination=&quot;@+id/settings_dest&quot;&gt; &lt;/action&gt; &lt;fragment android:id=&quot;@+id/deeplink_dest&quot; android:name=&quot;com.my.navigation.DeepLinkFragment&quot; android:label=&quot;@string/deeplink&quot; tools:layout=&quot;@layout/deeplink_fragment&quot;&gt; &lt;argument android:name=&quot;myarg&quot; android:defaultValue=&quot;Android!&quot;/&gt; &lt;/fragment&gt;","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"创建和运行一个应用界面","slug":"categories/HarmonyOS/创建和运行一个应用界面","date":"2021-08-09T12:26:42.000Z","updated":"2021-09-03T07:00:58.641Z","comments":true,"path":"2021/08/09/categories/HarmonyOS/创建和运行一个应用界面/","link":"","permalink":"https://visen123.github.io/2021/08/09/categories/HarmonyOS/%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E7%95%8C%E9%9D%A2/","excerpt":"","text":"DevEco Studio开发环境配置完成后，可以通过运行HelloWorld工程来验证环境设置是否正确。以Phone工程为例，在Phone的远程模拟器中运行该工程。 创建一个新工程打开DevEco Studio，在欢迎页点击Create HarmonyOS Project，创建一个新工程。根据工程创建向导，选择需要的Ability工程模板，然后点击Next。关于工程模板的介绍和支持的设备类型，请参考支持的设备模板和编程语言。 填写工程相关信息，Device Type选择Phone，其他保持默认值即可，点击Finish。关于各个参数的详细介绍，请参考创建一个新的工程。 工程创建完成后，DevEco Studio会自动进行工程的同步，同步成功如下图所示。 使用模拟器运行HelloWorldDevEco Studio提供远程模拟器和本地模拟器，本示例以远程模拟器为例进行说明。关于本地模拟器的使用请参考使用Local Emulator运行应用（即将上线、敬请期待）。 在DevEco Studio菜单栏，点击Tools &gt; Device Manager。在Remote Emulator页签中点击Login，在浏览器中弹出华为开发者联盟帐号登录界面，请输入已实名认证的华为开发者联盟帐号的用户名和密码进行登录（查看远程模拟器登录常见问题）。说明推荐使用最新版本Chrome浏览器，如果使用Safari、360等其他浏览器，要取消阻止跨站跟踪和阻止所有Cookie功能。 登录后，请点击界面的允许按钮进行授权。 在设备列表中，选择Phone设备P40，并点击按钮，运行模拟器。点击DevEco Studio工具栏中的按钮运行工程，或使用默认快捷键Shift+F10（Mac为Control+R）运行工程。 DevEco Studio会启动应用的编译构建，完成后应用即可运行在模拟器上。已成功运行了第一个HarmonyOS应用，接下来，可以通过一个简单的DEMO工程示例，来详细了解HarmonyOS应用的开发过程，具体请参见HarmonyOS应用开发快速入门。","categories":[{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"https://visen123.github.io/categories/HarmonyOS/"}],"tags":[],"keywords":[{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"https://visen123.github.io/categories/HarmonyOS/"}]},{"title":"Android9.0无法加载图片及访问不了服务器问题","slug":"categories/Android/Android9.0无法加载图片及访问不了服务器问题","date":"2021-08-09T07:30:46.000Z","updated":"2021-09-01T04:47:49.324Z","comments":true,"path":"2021/08/09/categories/Android/Android9.0无法加载图片及访问不了服务器问题/","link":"","permalink":"https://visen123.github.io/2021/08/09/categories/Android/Android9.0%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87%E5%8F%8A%E8%AE%BF%E9%97%AE%E4%B8%8D%E4%BA%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%AE%E9%A2%98/","excerpt":"","text":"当在安卓9.0加载网络请求数据时，如果抛出如下异常： Cause (1 of 1): class java.io.IOException: Cleartext HTTP traffic to xxxx.xxxx.xxxx not permitted 这是因为Android 9.0 版本系统默认支持一个网络访问协议：Https协议的网络，所以不支持网络访问：Http协议的网络面对这样的问题，解决办法： 第一种办法在AndroidMainfest.xml清单文件 Application里增加代码:： android:usesCleartextTraffic=”true” 然后重新运行，就可以解决了访问不到服务器HTTP接口和图片加载的问题 第二种方案：在rec文件夹中创建一个xml文件夹，然后创建一个network-security-config.xml。xml文件代码如下： 然后在标签内添加以下代码： android:networkSecurityConfig=”@xml/network_security_config” 如果im还是登录不上去，推送也注册失败。是因为Android 9.0版本找不到http.client的类了。解决半部分，在AndroidMainfast.xml文件清单里再加一句如下代码：","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"使用可视化开发鸿蒙","slug":"categories/HarmonyOS/使用可视化开发鸿蒙","date":"2021-08-08T09:26:42.000Z","updated":"2021-09-03T14:57:58.541Z","comments":true,"path":"2021/08/08/categories/HarmonyOS/使用可视化开发鸿蒙/","link":"","permalink":"https://visen123.github.io/2021/08/08/categories/HarmonyOS/%E4%BD%BF%E7%94%A8%E5%8F%AF%E8%A7%86%E5%8C%96%E5%BC%80%E5%8F%91%E9%B8%BF%E8%92%99/","excerpt":"","text":"创建JS工程说明请使用DevEco Studio V2.2 Beta1及更高版本。 低代码开发功能仅适用于Phone设备的JS工程，且compileSdkVersion必须为6及以上。 打开DevEco Studio，创建一个新工程，选择支持Phone的JS模板，如Empty Ability(JS):点击放大 在工程配置向导中，Device Type只能选择Phone，其他参数根据实际需要设置即可，然后点击Finish等待工程同步完成。点击放大 创建第一个页面在Project窗口，选择工程中的“entry &gt; src &gt; main &gt; js &gt; default &gt; pages.index”，单击鼠标右键，选择“New &gt; JS Visual”。点击放大 勾选“Update compileSdkVersion”（若compilesSdk版本已升级，则不会出现该选项）。创建完成后，可以看到“entry &gt; src &gt; main &gt; supervisual&gt; default &gt; pages &gt; page &gt; page.visual”的文件目录结构如下： 删除工程运行默认的入口文件夹：删除“entry &gt; src &gt; main &gt; js&gt; default &gt; pages &gt; index”文件夹。操作后的工程结构目录如下： 第一个页面内有一个文本和一个按钮，通过Text和Button组件来实现。打开“page.visual”文件，选中画布中的组件，单击鼠标右键，选择Delete删除画布原有组件。选中画布，点击右侧属性样式栏中的样式图标（Flex），设置画布的JustifyContent样式为center，使得其子组件在主轴上居中显示；设置画布的AlignItems样式为center，使得其子组件在交叉轴上居中显示。操作如下所示：点击放大 选中UI Control中的Text组件，将其拖至中央画布区域。点击右侧属性样式栏中的属性图标（Properties），设置Text组件的Content属性为“Hello World”；点击右侧属性样式栏中的样式图标（Feature），设置组件的FontSize样式为60px，使得其文字放大；设置组件的TextAlign样式为center，使得组件文字居中显示。再选中画布上的Text组件，拖动放大。操作如下所示：点击放大 选中UI Control中的Button组件，将其拖至Text组件下面。点击右侧属性样式栏中的属性图标（Properties），设置Button组件的Value属性为“Next”，点击右侧属性样式栏中的样式图标（Feature），设置组件的FontSize样式为39px，使得其文字放大；再选中画布上Button组件，拖动放大。操作如下所示：点击放大 使用预览器或模拟器运行项目，效果如下图所示：点击放大 创建另一个页面在Project窗口，选择工程中的“entry &gt; src &gt; main &gt; js &gt; default &gt; pages.page”，单击鼠标右键，选择“New &gt; JS Visual”。创建后的page2.visual文件结构如下： 第二个页面上有一个文本，通过Text组件来实现。打开“page2.visual”文件，删除画布原有组件。选中画布，设置画布的JustifyContent样式为center，设置画布的AlignItems样式为center。操作如下所示：点击放大 选中Text组件拖至画布，设置Text组件的Content属性为“Hi there”，设置组件的FontSize样式为60px，设置组件的TextAlign样式为center，再选中画布上的Text组件，拖动放大。操作如下所示：点击放大 实现页面跳转在Project窗口，打开工程中的“entry &gt; src &gt; main &gt; js &gt; default &gt; pages &gt; page &gt; page.js”,，导入router模块，页面路由router根据页面的uri来找到目标页面，从而实现跳转。示例代码如下：import router from ‘@system.router’; export default { launch() { router.push ({ uri:’pages/page2/page2’, // 指定要跳转的页面 }) }}打开“page.visual”，选中画布上的Button组件，点击右侧属性样式栏中的事件图标（Events），鼠标点击Click事件的输入框，选择launch事件，操作示例如下图：点击放大 再次使用预览器或模拟器运行项目，效果如下图所示：点击放大 想要深入了解可视化开发的更多内容，请参见低代码开发。 恭喜你，至此已成功完成HarmonyOS快速入门-使用可视化开发。","categories":[{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"https://visen123.github.io/categories/HarmonyOS/"}],"tags":[],"keywords":[{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"https://visen123.github.io/categories/HarmonyOS/"}]},{"title":"使用JS语言开发鸿蒙","slug":"categories/HarmonyOS/使用JS语言开发鸿蒙","date":"2021-08-07T12:26:42.000Z","updated":"2021-09-07T13:57:38.166Z","comments":true,"path":"2021/08/07/categories/HarmonyOS/使用JS语言开发鸿蒙/","link":"","permalink":"https://visen123.github.io/2021/08/07/categories/HarmonyOS/%E4%BD%BF%E7%94%A8JS%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E9%B8%BF%E8%92%99/","excerpt":"","text":"编写第一个页面第一个页面内有一个文本和一个按钮，通过text和button组件来实现。在Project窗口，选择“entry &gt; src &gt; main &gt; js &gt; default &gt; pages.index”，打开“index.hml”文件，添加一个文本和一个按钮，示例代码如下： Hello World 打开“index.css”文件，设置文本和按钮的样式，示例代码如下： /* index.css */ .container { flex-direction: column; /* 设置容器内的项目纵向排列 */ justify-content: center; /* 设置项目位于容器主轴的中心 */ align-items: center; /* 项目在交叉轴居中 */ } /* 对class=\"text\"的组件设置样式 */ .text{ font-size: 42px; } /* 对class=\"button\"的组件设置样式 */ .button { width: 240px; height: 60px; background-color: #007dff; font-size: 30px; text-color: white; margin-top: 20px; } 使用预览器或模拟器运行项目，效果如下图所示： 创建另一个页面在Project窗口，打开“entry &gt; src &gt; main &gt; js &gt; default”，右键点击“pages.index”文件夹，选择“New &gt; JS Page”，命名为“details”，单击回车键。创建完成后，可以看到“pages.index”文件夹下的文件目录结构如： 打开“details.hml”文件，添加一个文本，示例代码如下： Hi there 打开“details.css”文件，设置文本的样式，示例代码如下： /* details.css */ .container { flex-direction: column; justify-content: center; align-items: center; } .text { font-size: 42px; text-align: center; } 实现页面跳转 打开第一个页面的“index.js”文件，导入router模块，页面路由router根据页面的uri来找到目标页面，从而实现跳转。示例代码如下： // index.js import router from '@system.router'; export default { launch() { router.push ({ uri:’pages/index/details/details’, // 指定要跳转的页面 }) }}再次使用预览器或模拟器运行项目，效果如下图所示：点击放大 恭喜你，至此已成功完成HarmonyOS快速入门-使用JS语言开发。","categories":[{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"https://visen123.github.io/categories/HarmonyOS/"}],"tags":[],"keywords":[{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"https://visen123.github.io/categories/HarmonyOS/"}]},{"title":"鸿蒙配置开发环境","slug":"categories/HarmonyOS/配置开发环境","date":"2021-08-06T08:00:16.000Z","updated":"2021-09-03T07:00:58.648Z","comments":true,"path":"2021/08/06/categories/HarmonyOS/配置开发环境/","link":"","permalink":"https://visen123.github.io/2021/08/06/categories/HarmonyOS/%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"","text":"下载&amp;更新HarmonyOS SDKDevEco Studio提供SDK Manager统一管理SDK及工具链，下载各种编程语言的SDK包时，SDK Manager会自动下载该SDK包依赖的工具链。SDK Manager提供多种编程语言的SDK包和工具链，具体说明请参考下表。类别 包名 说明 默认是否下载 参考 SDK Native C/C++语言SDK包。 x 《Native API参考》 JS JS语言SDK包。 √ 《JS API参考》 Java Java语言SDK包。 √ 《Java API参考》 SDK Tool Toolchains SDK工具链，HarmonyOS应用开发必备工具集，包括编译、打包、签名、数据库管理等工具的集合。 √ - Previewer HarmonyOS应用预览器，在开发过程中可以动态预览Phone、TV、Wearable、LiteWearable等设备的应用效果，支持JS和Java应用预览。 √ 使用预览器查看应用效果下载HarmonyOS SDK第一次使用DevEco Studio，需要下载HarmonyOS SDK及对应工具链。如果是非首次安装DevEco Stduio，SDK下载和更新方法请参考更新HarmonyOS SDK。 说明HarmonyOS SDK与OpenHarmony SDK不兼容，下载的HarmonyOS SDK并不适用于OpenHarmony工程。加载OpenHarmony SDK和开发OpenHarmony应用，请参考OpenHarmony使用指南。 运行已安装的DevEco Studio，首次使用，请选择Do not import settings，点击OK。进入配置向导页面，设置npm registry，DevEco Studio已预置对应的仓，直接点击Start using DevEco Studio进入下一步。说明 如果配置向导界面出现的是设置Set up HTTP Proxy界面，说明网络受限，请根据参考信息配置DevEco Studio代理、NPM代理和Gradle代理后，再下载HarmonyOS SDK。通过DevEco Studio向导指引开发者下载HarmonyOS SDK，默认情况下，SDK会下载到user目录下，也可以指定对应的存储路径，SDK存储路径不支持中文字符，然后点击Next。默认会下载最新版本的Java SDK、JS SDK、Previewer和Toolchains。在弹出的License Agreement窗口，点击Accept开始下载SDK。说明下载SDK过程中，如果出现下载JS SDK失败，提示“Install js dependencies failed.”，请根据JS SDK安装失败处理指导进行处理。 等待HarmonyOS SDK及工具下载完成，点击Finish，界面会进入到DevEco Studio欢迎页。 SDK默认只会下载最新版本的Java SDK、JS SDK、Previewer和Toolchains，点击上图欢迎页中的Configure（或图标） &gt; Settings，进入HarmonyOS SDK页面，可以下载其它组件，只需要勾选对应的组件包，然后点击Apply即可。 更新HarmonyOS SDK如果已经下载过HarmonyOS SDK，当存在新版本的SDK时，可以通过SDK Manager来更新对应的SDK。进入SDK Manager的方法： 在DevEco Studio欢迎页，点击Configure（或图标） &gt; Settings &gt; HarmonyOS SDK进入SDK Manager界面（macOS系统为Configure &gt; Preferences &gt; HarmonyOS SDK）。在DevEco Studio打开工程的情况下，点击Tools &gt; SDK Manager界面进入；或者点击Files &gt; Settings &gt; HarmonyOS SDK进入（macOS系统为DevEco Studio &gt; Preferences &gt; HarmonyOS SDK）。在SDK Manager中，勾选需要更新的SDK，然后点击Apply，然后在弹出的确认更新窗口，点击OK即可开始更新。 配置HDC工具环境变量HDC是为开发者提供HarmonyOS应用的调试工具，为方便使用HDC工具，请为HDC工具的端口号设置环境变量。Windows环境变量设置方法：在此电脑 &gt; 属性 &gt; 高级系统设置 &gt; 高级 &gt; 环境变量中，添加HDC端口变量。变量名为：HDC_SERVER_PORT，变量值设置为7035。 环境变量配置完成后，关闭并重启DevEco Studio。macOS环境变量设置方法：打开终端工具，执行以下命令，打开.bash_profile文件。vi ./.bash_profile点击字母“i”，进入Insert模式。输入以下内容，添加HDC_SERVER_PORT环境变量信息。HDC_SERVER_PORT=7035launchctl setenv HDC_SERVER_PORT $HDC_SERVER_PORTexport HDC_SERVER_PORT编辑完成后，点击“Esc”键，退出编辑模式，然后输入“:wq”，点击“Enter”按钮保存。执行以下命令，使配置的环境变量生效。source .bash_profile环境变量配置完成后，关闭并重启DevEco Studio。参考信息DevEco Studio开发环境需要依赖于网络环境，需要连接上网络才能确保工具的正常使用。 一般来说，如果使用的是个人或家庭网络，是不需要设置代理信息的；只有部分企业网络受限的情况下，才需要设置代理信息。 如果是第一次打开DevEco Studio，配置向导界面出现设置Set up HTTP Proxy界面，说明网络受限，可以通过配置代理的方式来解决，需要配置DevEco Studio代理、NPM代理和Gradle代理。 配置DevEco Studio代理启动DevEco Studio，配置向导进入Set up HTTP Proxy界面，勾选Manual proxy configuration，设置DevEco Studio的HTTP Proxy。说明如果非首次设置向导进入HTTP Proxy，可以通过如下方式进入HTTP Proxy配置界面： 在欢迎页点击Configure（或图标） &gt; Settings &gt; Appearance &amp; Behavior &gt; System Settings &gt; HTTP Proxy进入HTTP Proxy设置界面（Mac系统为Configure &gt; Preferences &gt; Appearance &amp; Behavior &gt; System Settings &gt; HTTP Proxy）。在打开了工程的情况下，可以点击File &gt; Settings &gt; Appearance &amp; Behavior &gt; System Settings &gt; HTTP Proxy进入HTTP Proxy设置界面（Mac系统为DevEco Studio &gt; Preferences &gt; Appearance &amp; Behavior &gt; System Settings &gt; HTTP Proxy）HTTP配置项，设置代理服务器信息。如果不清楚代理服务器信息，可以咨询你们的网络管理人员。Host name：代理服务器主机名或IP地址。Port number：代理服务器对应的端口号。No proxy for：不需要通过代理服务器访问的URL或者IP地址（地址之间用英文逗号分隔）。Proxy authentication配置项，如果代理服务器需要通过认证鉴权才能访问，则需要设置。否则，请跳过该配置项。Login：访问代理服务器的用户名。Password：访问代理服务器的密码。Remember：勾选，记住密码。 配置完成后，点击Check connection，输入网络地址（如：https://developer.harmonyos.com），检查网络连通性。提示“Connection successful”表示代理设置成功。点击Next: Configure npm继续设置NPM代理信息，请参考配置NPM代理。配置NPM代理通过DevEco Studio的设置向导设置NPM代理信息，代理信息将写入用户“users/用户名/”目录下的.npmrc文件。说明该向导只有第一次安装DevEco Studio才会出现。如果未出现该向导，可以直接在“users/用户名/”目录下的.npmrc文件中，添加代理配置信息。 npm registry：设置npm仓的地址信息，建议勾选。HTTP proxy：代理服务器信息，默认会与DevEco Studio的HTTP proxy设置项保持一致。Enable Https Proxy：同步设置HTTPS Proxy配置信息，建议勾选。 然后点击Start using DevEco Studio继续下一步操作。如果代理服务器需要认证（需要用户名和密码），请先根据如下指导配置代理服务器的用户名和密码信息，然后再下载HarmonyOS；否则，请跳过该操作，根据向导下载HarmonyOS SDK即可。 进入用户的users目录，打开.npmrc文件。修改npm代理信息，在proxy和https-proxy中，增加user和password字段，具体取值请以实际代理信息为准。示例如下所示：proxy=http://user:password@proxy.server.com:80https-proxy=http://user:password@proxy.server.com:80说明如果password中存在特殊字符，如@、#、*等符号，可能导致配置不生效，建议将特殊字符替换为ASCII码，并在ASCII码前加百分号%。常用符号替换为ASCII码对照表如下： !：%21@：%40#：%23￥：%24&amp;：%26*：%2A代理设置完成后，打开命令行工具，执行如下命令进行验证网络是否正常。npm info express执行结果如下图所示，则说明代理设置成功。 点击放大 网络设置完成后，根据DevEco Studio向导下载HarmonyOS SDK。设置Gradle代理打开“此电脑”，在文件夹地址栏中输入%userprofile%（Mac系统请点击前往 &gt; 个人），进入个人用户界面。点击放大 创建一个文件夹，命名为.gradle。如果已有.gradle文件夹，请跳过此操作。说明macOS系统创建.gradle文件夹前，请将系统设置为“显示隐藏文件”。 进入.gradle文件夹，新建一个文本文档，命名为gradle，并修改后缀为.properties。打开gradle.properties文件中，添加如下脚本，然后保存。其中代理服务器、端口、用户名、密码和不使用代理的域名，请根据实际代理情况进行修改。其中不使用代理的“nonProxyHosts”的配置间隔符是 “|”。systemProp.http.proxyHost=proxy.server.comsystemProp.http.proxyPort=8080systemProp.http.nonProxyHosts=.company.com|10.|100.*systemProp.http.proxyUser=userIdsystemProp.http.proxyPassword=passwordsystemProp.https.proxyHost=proxy.server.comsystemProp.https.proxyPort=8080systemProp.https.nonProxyHosts=.company.com|10.|100.*systemProp.https.proxyUser=userIdsystemProp.https.proxyPassword=password","categories":[{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"https://visen123.github.io/categories/HarmonyOS/"}],"tags":[],"keywords":[{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"https://visen123.github.io/categories/HarmonyOS/"}]},{"title":"使用Java语言开发鸿蒙","slug":"categories/HarmonyOS/使用Java语言开发鸿蒙","date":"2021-08-05T11:26:42.000Z","updated":"2021-09-03T14:55:38.251Z","comments":true,"path":"2021/08/05/categories/HarmonyOS/使用Java语言开发鸿蒙/","link":"","permalink":"https://visen123.github.io/2021/08/05/categories/HarmonyOS/%E4%BD%BF%E7%94%A8Java%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E9%B8%BF%E8%92%99/","excerpt":"","text":"使用Java语言开发更新时间: 2021-08-27 16:31编写第一个页面在Java UI框架中，提供了两种编写布局的方式：在XML中声明UI布局和在代码中创建布局。这两种方式创建出的布局没有本质差别，为了熟悉两种方式，我们将通过XML的方式编写第一个页面，通过代码的方式编写第二个页面。 在Project窗口，点击“entry &gt; src &gt; main &gt; resources &gt; base &gt; layout”，打开“ability_main.xml”文件。 （可选）在Project窗口，点击“entry &gt; src &gt; main &gt; resources &gt; base &gt; element”，打开“string.json”文件，可在此文件内声明所需引用的资源内容。关于取值为string类型的文本属性，可以直接设置文本字串，也可以引用string资源（推荐使用）。string.json的示例代码如下：{ “string”:[ { “name”:”entry_MainAbility”, “value”:”entry_MainAbility” }, { “name”:”mainability_description”, “value”:”Java_Empty Ability” }, { “name”:”mainability_HelloWorld”, “value”:”Hello World” }, { “name”:”button_Next”, “value”:”Next” } ]}第一个页面内有一个文本和一个按钮，使用DependentLayout布局，通过Text和Button组件来实现，其中vp和fp分别表示虚拟像素和字体像素。本次示例展示两个组件的显示文本分别采用直接设置文本字串、引用string资源（推荐使用）的方式。“ability_main.xml”的示例代码如下： 按钮的背景是蓝色胶囊样式，可以通过graphic目录下的XML文件来设置。右键点击“graphic”文件夹，选择“New &gt; File”，命名为“background_button.xml”，单击回车键。 “background_button.xml”的示例代码如下： 在layout目录下的“ability_main.xml”文件中，使用background_element=”$graphic:background_button”的方式引用“background_button.xml”文件： &lt;DependentLayout … 在XML文件中添加组件后，需要在Java代码中加载XML布局。在Project窗口，选择“entry &gt; src &gt; main &gt; java &gt; com.example.myapplication &gt; slice” ，打开“MainAbilitySlice.java”文件，使用setUIContent方法加载“ability_main.xml”布局。此外，运行代码前需采用import（可使用Alt+Enter快捷键）引入对应类，否则会产生报错提示。说明HarmonyOS提供了Ability和AbilitySlice两个基础类，一个有界面的Ability可以由一个或多个AbilitySlice构成，AbilitySlice主要用于承载单个页面的具体逻辑实现和界面UI，是应用显示、运行和跳转的最小单元。 本文档以同一个Ability内的两个AbilitySlice之间的跳转为例，如果开发者希望实现两个Ability之间的跳转，请参考不同Page间导航。 “MainAbilitySlice.java”的示例代码如下：//请根据实际工程/包名引入package com.example.myapplication.slice; import com.example.myapplication.ResourceTable; import ohos.aafwk.ability.AbilitySlice;import ohos.aafwk.content.Intent; public class MainAbilitySlice extends AbilitySlice { @Override public void onStart(Intent intent) { super.onStart(intent); super.setUIContent(ResourceTable.Layout_ability_main); // 加载layout目录下的XML布局 }}使用预览器或模拟器运行项目，效果如下图所示： 创建另一个页面在上一节中，我们用XML的方式编写了一个包含文本和按钮的页面。为了帮助开发者熟悉在代码中创建布局的方式，接下来我们使用代码的方式编写第二个页面。 在Project窗口，打开“entry &gt; src &gt; main &gt; java &gt; com.example.myapplication”，右键点击“slice”文件夹，选择“New &gt; Java Class”，命名为“SecondAbilitySlice”，单击回车键。第二个页面上有一个文本。打开“SecondAbilitySlice”文件，添加一个Text，示例代码如下：//请根据实际工程/包名引入package com.example.myapplication.slice; import ohos.aafwk.ability.AbilitySlice;import ohos.aafwk.content.Intent;import ohos.agp.colors.RgbColor;import ohos.agp.components.DependentLayout;import ohos.agp.components.Text;import ohos.agp.components.element.ShapeElement;import ohos.agp.utils.Color;import ohos.agp.components.DependentLayout.LayoutConfig; public class SecondAbilitySlice extends AbilitySlice { @Override public void onStart(Intent intent) { super.onStart(intent); // 声明布局 DependentLayout myLayout = new DependentLayout(this); // 设置布局宽高 myLayout.setWidth(LayoutConfig.MATCH_PARENT); myLayout.setHeight(LayoutConfig.MATCH_PARENT); // 设置布局背景为白色 ShapeElement background = new ShapeElement(); background.setRgbColor(new RgbColor(255, 255, 255)); myLayout.setBackground(background); // 创建一个文本 Text text = new Text(this); text.setText(&quot;Hi there&quot;); text.setWidth(LayoutConfig.MATCH_PARENT); text.setTextSize(100); text.setTextColor(Color.BLACK); // 设置文本的布局 DependentLayout.LayoutConfig textConfig = new DependentLayout.LayoutConfig(LayoutConfig.MATCH_CONTENT, LayoutConfig.MATCH_CONTENT); textConfig.addRule(LayoutConfig.CENTER_IN_PARENT); text.setLayoutConfig(textConfig); myLayout.addComponent(text); super.setUIContent(myLayout); &#125; }实现页面跳转打开第一个页面的“MainAbilitySlice.java”文件，添加按钮的响应逻辑，实现点击按钮跳转到下一页，示例代码如下：//请根据实际工程/包名引入package com.example.myapplication.slice; import com.example.myapplication.ResourceTable; import ohos.aafwk.ability.AbilitySlice;import ohos.aafwk.content.Intent;import ohos.agp.components.Button; public class MainAbilitySlice extends AbilitySlice { @Override public void onStart(Intent intent) { super.onStart(intent); super.setUIContent(ResourceTable.Layout_ability_main); Button button = (Button) findComponentById(ResourceTable.Id_button); // 点击按钮跳转至第二个页面 button.setClickedListener(listener -&gt; present(new SecondAbilitySlice(), new Intent())); &#125; }说明setClickedListener用于注册监听相关组件的点击事件，present用于实现页面间的导航。关于页面跳转的更多详细用法，可参考AbilitySlice间导航。 再次使用预览器或模拟器运行项目，效果如下图所示：点击放大 恭喜你，至此已成功完成HarmonyOS快速入门-使用JAVA语言开发。","categories":[{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"https://visen123.github.io/categories/HarmonyOS/"}],"tags":[],"keywords":[{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"https://visen123.github.io/categories/HarmonyOS/"}]},{"title":"HarmonyOS开发工具下载安装","slug":"categories/HarmonyOS/HarmonyOS开发工具下载安装","date":"2021-08-01T11:26:42.000Z","updated":"2021-09-03T07:00:58.664Z","comments":true,"path":"2021/08/01/categories/HarmonyOS/HarmonyOS开发工具下载安装/","link":"","permalink":"https://visen123.github.io/2021/08/01/categories/HarmonyOS/HarmonyOS%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85/","excerpt":"","text":"开发准备开始前请参考下载与安装软件、配置开发环境，完成DevEco Studio的安装和开发环境配置。DevEco Studio支持Windows和macOS系统，下面将针对两种操作系统的软件安装方式进行介绍。 Windows环境 运行环境要求 为保证DevEco Studio正常运行，建议电脑配置满足如下要求： 操作系统：Windows10 64位 内存：8GB及以上 硬盘：100GB及以上 分辨率：1280*800像素及以上 下载和安装DevEco Studio DevEco Studio的编译构建依赖JDK，DevEco Studio预置了Open JDK，版本为1.8，安装过程中会自动安装JDK。 进入HUAWEI DevEco Studio产品页，点击下载列表后的按钮，下载DevEco Studio。 说明 如果下载DevEco Studio Beta版本，则需要注册并登录华为开发者帐号。 下载完成后，双击下载的“deveco-studio-xxxx.exe”，进入DevEco Studio安装向导，在如下安装选项界面勾选64-bit launcher后，点击Next，直至安装完成。 macOS环境 运行环境要求 为保证DevEco Studio正常运行，建议电脑配置满足如下要求： 操作系统：macOS 10.14/10.15/11.2.2 内存：8GB及以上 硬盘：100GB及以上 分辨率：1280*800像素及以上 下载和安装DevEco Studio DevEco Studio的编译构建依赖JDK，DevEco Studio预置了Open JDK，版本为1.8，安装过程中会自动安装JDK。 进入HUAWEI DevEco Studio产品页，点击下载列表后的按钮，下载DevEco Studio。 说明 如果下载DevEco Studio Beta版本，则需要注册并登录华为开发者帐号。 下载完成后，双击下载的“deveco-studio-xxxx.dmg”软件包。 在安装界面中，将“DevEco-Studio.app”拖拽到“Applications”中，等待安装完成。 安装完成后，接下来请根据配置开发环境，检查和配置开发环境。 开发环境配置完成后，请参考创建和运行Hello World创建工程，设备类型以“Phone”为例： 使用Java语言开发，模板选择“Empty Ability(Java)” 使用JS语言开发，模板选择“Empty Ability(JS)” 使用可视化开发，模板选择“Empty Ability(JS)” 工程创建完成后，使用预览器或Phone模拟器运行该工程。 华为鸿蒙OS开发工具下载地址：https://developer.harmonyos.com/cn/develop/deveco-studio#download","categories":[{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"https://visen123.github.io/categories/HarmonyOS/"}],"tags":[],"keywords":[{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"https://visen123.github.io/categories/HarmonyOS/"}]},{"title":"Android常用传感器用法一览","slug":"categories/Android/Android常用传感器用法一览","date":"2021-07-06T07:06:08.000Z","updated":"2021-09-03T14:38:55.828Z","comments":true,"path":"2021/07/06/categories/Android/Android常用传感器用法一览/","link":"","permalink":"https://visen123.github.io/2021/07/06/categories/Android/Android%E5%B8%B8%E7%94%A8%E4%BC%A0%E6%84%9F%E5%99%A8%E7%94%A8%E6%B3%95%E4%B8%80%E8%A7%88/","excerpt":"","text":"1、传感器入门自从苹果公司在2007年发布第一代iPhone以来，以前看似和手机挨不着边的传感器也逐渐成为手机硬件的重要组成部分。如果读者使用过iPhone、HTC Dream、HTC Magic、HTC Hero以及其他的Android手机，会发现通过将手机横向或纵向放置，屏幕会随着手机位置的不同而改变方向。这种功能就需要通过重力传感器来实现，除了重力传感器，还有很多其他类型的传感器被应用到手机中，例如磁阻传感器就是最重要的一种传感器。虽然手机可以通过GPS来判断方向，但在GPS信号不好或根本没有GPS信号的情况下，GPS就形同虚设。这时通过磁阻传感器就可以很容易判断方向（东、南、西、北）。有了磁阻传感器，也使罗盘（俗称指向针）的电子化成为可能。在Android应用程序中使用传感器要依赖于android.hardware.SensorEventListener接口。通过该接口可以监听传感器的各种事件。SensorEventListener接口的代码如下：package android.hardware;public interface SensorEventListener{ public voidonSensorChanged(SensorEvent event); public voidonAccuracyChanged(Sensor sensor, int accuracy);}复制代码 在SensorEventListener接口中定义了两个方法：onSensorChanged和onAccuracyChanged。当传感器的值发生变化时，例如磁阻传感器的方向改变时会调用onSensorChanged方法。当传感器的精度变化时会调用onAccuracyChanged方法。onSensorChanged方法只有一个SensorEvent类型的参数event，其中SensorEvent类有一个values变量非常重要，该变量的类型是float[]。但该变量最多只有3个元素，而且根据传感器的不同，values变量中元素所代表的含义也不同。 在解释values变量中元素的含义之前，先来介绍一下Android的坐标系统是如何定义X、Y、Z轴的。 X轴的方向是沿着屏幕的水平方向从左向右。如果手机不是正方形的话，较短的边需要水平放置，较长的边需要垂直放置。Y轴的方向是从屏幕的左下角开始沿着屏幕的垂直方向指向屏幕的顶端。将手机平放在桌子上，Z轴的方向是从手机里指向天空。 下面是values变量的元素在主要的传感器中所代表的含义。 1.1方向传感器在方向传感器中values变量的3个值都表示度数，它们的含义如下： values[0]：该值表示方位，也就是手机绕着Z轴旋转的角度。0表示北（North）；90表示东（East）；180表示南（South）；270表示西（West）。如果values[0]的值正好是这4个值，并且手机是水平放置，表示手机的正前方就是这4个方向。可以利用这个特性来实现电子罗盘，实例76将详细介绍电子罗盘的实现过程。 values[1]：该值表示倾斜度，或手机翘起的程度。当手机绕着X轴倾斜时该值发生变化。values[1]的取值范围是-180≤values[1]≤180。假设将手机屏幕朝上水平放在桌子上，这时如果桌子是完全水平的，values[1]的值应该是0（由于很少有桌子是绝对水平的，因此，该值很可能不为0，但一般都是-5和5之间的某个值）。这时从手机顶部开始抬起，直到将手机沿X轴旋转180度（屏幕向下水平放在桌面上）。在这个旋转过程中，values[1]会在0到-180之间变化，也就是说，从手机顶部抬起时，values[1]的值会逐渐变小，直到等于-180。如果从手机底部开始抬起，直到将手机沿X轴旋转180度，这时values[1]会在0到180之间变化。也就是values[1]的值会逐渐增大，直到等于180。可以利用values[1]和下面要介绍的values[2]来测量桌子等物体的倾斜度。 values[2]：表示手机沿着Y轴的滚动角度。取值范围是-90≤values[2]≤90。假设将手机屏幕朝上水平放在桌面上，这时如果桌面是平的，values[2]的值应为0。将手机左侧逐渐抬起时，values[2]的值逐渐变小，直到手机垂直于桌面放置，这时values[2]的值是-90。将手机右侧逐渐抬起时，values[2]的值逐渐增大，直到手机垂直于桌面放置，这时values[2]的值是90。在垂直位置时继续向右或向左滚动，values[2]的值会继续在-90至90之间变化。 1.2加速传感器该传感器的values变量的3个元素值分别表示X、Y、Z轴的加速值。例如，水平放在桌面上的手机从左侧向右侧移动，values[0]为负值；从右向左移动，values[0]为正值。读者可以通过本节的例子来体会加速传感器中的值的变化。要想使用相应的传感器，仅实现SensorEventListener接口是不够的，还需要使用下面的代码来注册相应的传感器。 // 获得传感器管理器 SensorManager sm = (SensorManager) getSystemService(SENSOR_SERVICE); // 注册方向传感器 sm.registerListener(this,sm.getDefaultSensor(Sensor.TYPE_ORIENTATION), SensorManager.SENSOR_DELAY_FASTEST); 如果想注册其他的传感器，可以改变getDefaultSensor方法的第1个参数值，例如，注册加速传感器可以使用Sensor.TYPE_ACCELEROMETER。在Sensor类中还定义了很多传感器常量，但要根据手机中实际的硬件配置来注册传感器。如果手机中没有相应的传感器硬件，就算注册了相应的传感器也不起任何作用。getDefaultSensor方法的第2个参数表示获得传感器数据的速度。SensorManager.SENSOR_DELAY_ FASTEST表示尽可能快地获得传感器数据。除了该值以外，还可以设置3个获得传感器数据的速度值，这些值如下： SensorManager.SENSOR_DELAY_NORMAL：默认的获得传感器数据的速度。SensorManager.SENSOR_DELAY_GAME：如果利用传感器开发游戏，建议使用该值。SensorManager.SENSOR_DELAY_UI：如果使用传感器更新UI中的数据，建议使用该值。 1.3重力感应器加速度传感器的类型常量是Sensor.TYPE_GRAVITY。重力传感器与加速度传感器使用同一套坐标系。values数组中三个元素分别表示了X、Y、Z轴的重力大小。Android SDK定义了一些常量，用于表示星系中行星、卫星和太阳表面的重力。下面就来温习一下天文知识，将来如果在地球以外用Android手机，也许会用得上。public static final float GRAVITY_SUN= 275.0f;public static final float GRAVITY_MERCURY= 3.70f;public static final float GRAVITY_VENUS= 8.87f;public static final float GRAVITY_EARTH= 9.80665f;public static final float GRAVITY_MOON= 1.6f;public static final float GRAVITY_MARS= 3.71f;public static final float GRAVITY_JUPITER= 23.12f;public static final float GRAVITY_SATURN= 8.96f;public static final float GRAVITY_URANUS= 8.69f;public static final float GRAVITY_NEPTUNE= 11.0f;public static final float GRAVITY_PLUTO= 0.6f;public static final float GRAVITY_DEATH_STAR_I= 0.000000353036145f;public static final float GRAVITY_THE_ISLAND= 4.815162342f; 1.4 光线传感器光线传感器的类型常量是Sensor.TYPE_LIGHT。values数组只有第一个元素（values[0]）有意义。表示光线的强度。最大的值是120000.0f。Android SDK将光线强度分为不同的等级，每一个等级的最大值由一个常量表示，这些常量都定义在SensorManager类中，代码如下：public static final float LIGHT_SUNLIGHT_MAX =120000.0f;public static final float LIGHT_SUNLIGHT=110000.0f;public static final float LIGHT_SHADE=20000.0f;public static final float LIGHT_OVERCAST= 10000.0f;public static final float LIGHT_SUNRISE= 400.0f;public static final float LIGHT_CLOUDY= 100.0f;public static final float LIGHT_FULLMOON= 0.25f;public static final float LIGHT_NO_MOON= 0.001f; 上面的八个常量只是临界值。读者在实际使用光线传感器时要根据实际情况确定一个范围。例如，当太阳逐渐升起时，values[0]的值很可能会超过LIGHT_SUNRISE，当values[0]的值逐渐增大时，就会逐渐越过LIGHT_OVERCAST，而达到LIGHT_SHADE，当然，如果天特别好的话，也可能会达到LIGHT_SUNLIGHT，甚至更高。 1.5陀螺仪传感器 陀螺仪传感器的类型常量是Sensor.TYPE_GYROSCOPE。values数组的三个元素表示的含义如下：values[0]：延X轴旋转的角速度。values[1]：延Y轴旋转的角速度。values[2]：延Z轴旋转的角速度。当手机逆时针旋转时，角速度为正值，顺时针旋转时，角速度为负值。陀螺仪传感器经常被用来计算手机已转动的角度，代码如下：private static final float NS2S = 1.0f / 1000000000.0f;private float timestamp;public void onSensorChanged(SensorEvent event){ if (timestamp != 0) { // event.timesamp表示当前的时间，单位是纳秒（1百万分之一毫秒） final float dT = (event.timestamp - timestamp) * NS2S; angle[0] += event.values[0] * dT; angle[1] += event.values[1] * dT; angle[2] += event.values[2] * dT; } timestamp = event.timestamp;} 上面代码中通过陀螺仪传感器相邻两次获得数据的时间差（dT）来分别计算在这段时间内手机延X、 Y、Z轴旋转的角度，并将值分别累加到angle数组的不同元素上。 1.6其他传感器其他传感器在前面几节介绍了加速度传感器、重力传感器、光线传感器、陀螺仪传感器以及方向传感器。除了这些传感器外，Android SDK还支持如下的几种传感器。关于这些传感器的使用方法以及与这些传感器相关的常量、方法，读者可以参阅官方文档。 近程传感器（Sensor.TYPE_PROXIMITY）线性加速度传感器（Sensor.TYPE_LINEAR_ACCELERATION）旋转向量传感器（Sensor.TYPE_ROTATION_VECTOR）磁场传感器（Sensor.TYPE_MAGNETIC_FIELD）压力传感器（Sensor.TYPE_PRESSURE）温度传感器（Sensor.TYPE_TEMPERATURE） 虽然AndroidSDK定义了十多种传感器，但并不是每一部手机都完全支持这些传感器。例如，Google Nexus S支持其中的9种传感器（不支持压力和温度传感器），而HTC G7只支持其中的5种传感器。如果使用了手机不支持的传感器，一般不会抛出异常，但也无法获得传感器传回的数据。读者在使用传感器时最好先判断当前的手机是否支持所使用的传感器。","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"Python常用工具包汇总","slug":"categories/工具/Python常用工具汇总","date":"2021-06-29T13:18:28.000Z","updated":"2021-09-07T13:59:16.116Z","comments":true,"path":"2021/06/29/categories/工具/Python常用工具汇总/","link":"","permalink":"https://visen123.github.io/2021/06/29/categories/%E5%B7%A5%E5%85%B7/Python%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/","excerpt":"","text":"一、Python中常用的科学计算工具包： 我们最了解的科学计算工具可能是Matlab，它能进行集数值计算，可视化工具及交互于一身，可惜的是它是一个商业产品。开源方面除了GNU Octave在尝试做一个类似Matlab的工具包外，Python的这几个工具包集合到一起也可以替代Matlab的相应功能：NumPy+SciPy+Matplotlib+iPython。同时，这几个工具包，特别是NumPy和SciPy，也是很多Python文本处理 &amp; 机器学习 &amp; 数据挖掘工具包的基础，非常重要。 Numpy： Numpy是使用Python进行科学计算的基础库，主要提供高性能的N维数组实现以及计算能力，还提供了和其它语言如C/C++集成的能力，此外还实现了一些基础的数学算法，如线性代数相关、傅里叶变换及随机数生成等。NumPy提供了两种基本的对象：ndarray（N-dimensional array object）和 ufunc（universal function object）。ndarray是存储单一数据类型的多维数组，而ufunc则是能够对数组进行处理的函数。 官方主页：http://www.numpy.org/ SciPy：Scientific Computing Tools for Python “SciPy是一个开源的Python算法库和数学工具包，SciPy包含的模块有最优化、线性代数、积分、插值、特殊函数、快速傅里叶变换、信号处理和图像处理、常微分方程求解和其他科学与工程中常用的计算。其功能与软件MATLAB、Scilab和GNU Octave类似。 Numpy和Scipy常常结合着使用，Python大多数机器学习库都依赖于这两个模块。”—-引用自“Python机器学习库” 官方主页：http://www.scipy.org/ 3.Matplotlib Matplotlib是python数据可视化工具包。是python最著名的绘图库，它提供了一整套和matlab相似的命令API，十分适合交互式地进行制图。而且也可以方便地将它作为绘图控件，嵌入GUI应用程序中。Matplotlib可以配合ipython shell使用，提供不亚于Matlab的绘图体验，总之用过了都说好。 在IPython控制台使用Matplotlib，可以使用ipython–matplotlib命令来启动IPython控制台程序；如果要在IPython notebook里使用Matplotlib，则在notebook的开始位置插入%matplotlib inline魔术命令即可。 IPython为Matplotlib专门提供了特殊的交互模式。IPython的Matplotlib模式有两个优点，一是提供了非阻塞的画图操作，二是不需要显示地调用show（）方法来显示画出来的图片。 官方主页：http://matplotlib.org/ 二. Python 机器学习 &amp; 数据挖掘常用工具包 机器学习和数据挖掘这两个概念不太好区分，这里就放到一起了。这方面的开源Python工具包有很多，这里先从熟悉的讲起，再补充其他来源的资料，也欢迎大家补充。 2.1 scikit-learn: Machine Learning in Python 首先是scikit-learn，scikit-learn是一个基于NumPy, SciPy, Matplotlib的开源机器学习工具包，主要涵盖分类，回归和聚类算法，例如SVM， 逻辑回归，朴素贝叶斯，随机森林，k-means等算法，代码和文档都非常不错，在许多Python项目中都有应用。例如在我们熟悉的NLTK中。scikit-learn提供了一致的调用接口。它基于Numpy和scipy等Python数值计算库，提供了高效的算法实现。总结起来，scikit-learn工具包有以下几个优点。 一、文档齐全：官方文档齐全，更新及时。 二、接口易用：针对所有算法提供了一致的接口调用规则，不管是KNN、K-Means还是PCA. 三、算法全面：涵盖主流机器学习任务的算法，包括回归算法、分类算法、聚类分析、数据降维处理等。 缺点是scikit-learn不支持分布式计算，不适合用来处理超大型数据。 官方主页：http://scikit-learn.org/ 2.2 Pandas: Python Data Analysis Library Pandas是一个强大的时间序列数据处理工具包，Pandas是基于Numpy构建的，比Numpy的使用更简单。最初开发的目的是为了分析财经数据，现在已经广泛应用在Python数据分析领域中。Pandas，最基础的数据结构是Series，用它来表达一行数据，可以理解为一维的数组。另一个关键的数据结构为DataFrame，它表示的是二维数组 Pandas是基于NumPy和Matplotlib开发的，主要用于数据分析和数据可视化，它的数据结构DataFrame和R语言里的data.frame很像，特别是对于时间序列数据有自己的一套分析机制。有一本书《Python for Data Analysis》，作者是Pandas的主力开发，依次介绍了iPython, NumPy, Pandas里的相关功能，数据可视化，数据清洗和加工，时间数据处理等，案例包括金融股票数据挖掘等，相当不错。 官方主页：http://pandas.pydata.org/ 2.3 mlpy – Machine Learning Python Mlpy是基于NumPy/SciPy的Python机器学习模块，它是Cython的扩展应用。包含的机器学习算法很多，有时间单独写一篇记录 官方主页：http://mlpy.sourceforge.net/ 2.4 PyBrain “PyBrain(Python-Based Reinforcement Learning, Artificial Intelligence and Neural Network)是Python的一个机器学习模块，它的目标是为机器学习任务提供灵活、易应、强大的机器学习算法。（这名字很霸气） PyBrain正如其名，包括神经网络、强化学习(及二者结合)、无监督学习、进化算法。因为目前的许多问题需要处理连续态和行为空间，必须使用函数逼近(如神经网络)以应对高维数据。PyBrain以神经网络为核心，所有的训练方法都以神经网络为一个实例。” 2.5 Theano “Theano 是一个 Python 库，用来定义、优化和模拟数学表达式计算，用于高效的解决多维数组的计算问题。Theano的特点：紧密集成Numpy；高效的数据密集型GPU计算；高效的符号微分运算；高速和稳定的优化；动态生成c代码；广泛的单元测试和自我验证。自2007年以来，Theano已被广泛应用于科学运算。theano使得构建深度学习模型更加容易，可以快速实现多种模型。PS：Theano，一位希腊美女，Croton最有权势的Milo的女儿，后来成为了毕达哥拉斯的老婆。” 2.6 NLTK NLTK(Natural Language Toolkit)是Python的自然语言处理模块，包括一系列的字符处理和语言统计模型。NLTK 常用于学术研究和教学，应用的领域有语言学、认知科学、人工智能、信息检索、机器学习等。 NLTK提供超过50个语料库和词典资源，文本处理库包括分类、分词、词干提取、解析、语义推理。可稳定运行在Windows, Mac OS X和Linux平台上. 项目主页： http://sourceforge.net/projects/nltk/ https://pypi.python.org/pypi/nltk/ http://nltk.org/ 2.7 Pylearn2 “Pylearn2建立在theano上，部分依赖scikit-learn上，目前Pylearn2正处于开发中，将可以处理向量、图像、视频等数据，提供MLP、RBM、SDA等深度学习模型。” 官方主页：http://deeplearning.net/software/pylearn2/ 三. Python网页爬虫工具 一个真实的项目，一定是从获取数据开始的。无论文本处理，机器学习和数据挖掘，都需要数据，除了通过一些渠道购买或者下载的专业数据外，常常需要自己动手爬数据，这个时候，爬虫就显得格外重要了，幸好，Python提供了一批很不错的网页爬虫工具框架，既能爬取数据，也能获取和清洗数据，以前爬过一些火影和海贼的数据来玩： 3.1 Scrapy 鼎鼎大名的Scrapy，相信不少同学都有耳闻，课程图谱中的很多课程都是依靠Scrapy抓去的，这方面的介绍文章有很多，推荐大牛pluskid早年的一篇文章：《Scrapy 轻松定制网络爬虫》，历久弥新。 官方主页：http://scrapy.org/ Github代码页: https://github.com/scrapy/scrapy 3.2 Beautiful Soup 客观的说，Beautifu Soup不完全是一套爬虫工具，需要配合urllib使用，而是一套HTML / XML数据分析，清洗和获取工具。 官方主页：http://www.crummy.com/software/BeautifulSoup/ 3.3 Python-Goose Goose最早是用Java写得，后来用Scala重写，是一个Scala项目。Python-Goose用Python重写，依赖了Beautiful Soup。前段时间用过，感觉很不错，给定一个文章的URL, 获取文章的标题和内容很方便。 Github主页：https://github.com/grangier/python-goose 四. Python文本处理工具 获取文本数据之后，依据任务的不同，就需要进行基本的文本处理了，譬如对于英文来说，需要基本的tokenize，对于中文，则需要常见的中文分词，进一步的话，无论英文中文，还可以词性标注，句法分析，关键词提取，文本分类，情感分析等等。这个方面，特别是面向英文领域，有很多优秀的工具包，我们一一道来。 4.1 NLTK — Natural Language Toolkit 搞自然语言处理的同学应该没有人不知道NLTK吧，这里也就不多说了。不过推荐两本书籍给刚刚接触NLTK或者需要详细了解NLTK的同学: 一个是官方的《Natural Language Processing with Python》，以介绍NLTK里的功能用法为主，同时附带一些Python知识，同时国内陈涛同学友情翻译了一个中文版，这里可以看到：推荐《用Python进行自然语言处理》中文翻译-NLTK配套书；另外一本是《Python Text Processing with NLTK 2.0 Cookbook》，这本书要深入一些，会涉及到NLTK的代码结构，同时会介绍如何定制自己的语料和模型等，相当不错。 官方主页：http://www.nltk.org/ Github代码页：https://github.com/nltk/nltk 4.2 Pattern Pattern由比利时安特卫普大学CLiPS实验室出品，客观的说，Pattern不仅仅是一套文本处理工具，它更是一套web数据挖掘工具，囊括了数据抓取模块（包括Google, Twitter, 维基百科的API，以及爬虫和HTML分析器），文本处理模块（词性标注，情感分析等），机器学习模块(VSM, 聚类，SVM）以及可视化模块等，可以说，Pattern的这一整套逻辑也是这篇文章的组织逻辑，不过这里我们暂且把Pattern放到文本处理部分。我个人主要使用的是它的英文处理模块Pattern.en, 有很多很不错的文本处理功能，包括基础的tokenize, 词性标注，句子切分，语法检查，拼写纠错，情感分析，句法分析等，相当不错。 官方主页：http://www.clips.ua.ac.be/pattern 4.3 TextBlob: Simplified Text Processing TextBlob是一个很有意思的Python文本处理工具包，它其实是基于上面两个Python工具包NLKT和Pattern做了封装（TextBlob stands on the giant shoulders of NLTK and pattern, and plays nicely with both），同时提供了很多文本处理功能的接口，包括词性标注，名词短语提取，情感分析，文本分类，拼写检查等，甚至包括翻译和语言检测，不过这个是基于Google的API的，有调用次数限制。TextBlob相对比较年轻，有兴趣的同学可以关注。 官方主页：http://textblob.readthedocs.org/en/dev/ Github代码页：https://github.com/sloria/textblob 4.4 MBSP for Python MBSP与Pattern同源，同出自比利时安特卫普大学CLiPS实验室，提供了Word Tokenization, 句子切分，词性标注，Chunking, Lemmatization，句法分析等基本的文本处理功能，感兴趣的同学可以关注。 官方主页：http://www.clips.ua.ac.be/pages/MBSP 4.5 Gensim: Topic modeling for humans Gensim是一个相当专业的主题模型Python工具包，无论是代码还是文档，我们曾经用《如何计算两个文档的相似度》介绍过Gensim的安装和使用过程，这里就不多说了。 官方主页：http://radimrehurek.com/gensim/index.html github代码页：https://github.com/piskvorky/gensim 4.6 langid.py: Stand-alone language identification system 语言检测是一个很有意思的话题，不过相对比较成熟，这方面的解决方案很多，也有很多不错的开源工具包，不过对于Python来说，我使用过langid这个工具包，也非常愿意推荐它。langid目前支持97种语言的检测，提供了很多易用的功能，包括可以启动一个建议的server，通过json调用其API，可定制训练自己的语言检测模型等，可以说是“麻雀虽小，五脏俱全”。 Github主页：https://github.com/saffsd/langid.py 4.7 Jieba Jieba做最好的Python中文分词组件 “Jieba” (Chinese for “to stutter”) Chinese text segmentation: built to be the best Python Chinese word segmentation module.好了，终于可以说一个国内的Python文本处理工具包了：结巴分词，其功能包括支持三种分词模式（精确模式、全模式、搜索引擎模式），支持繁体分词，支持自定义词典等，是目前一个非常不错的Python中文分词解决方案。 Github主页：https://github.com/fxsjy/jieba","categories":[{"name":"工具","slug":"工具","permalink":"https://visen123.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[],"keywords":[{"name":"工具","slug":"工具","permalink":"https://visen123.github.io/categories/%E5%B7%A5%E5%85%B7/"}]},{"title":"Python画小猪佩奇","slug":"categories/Python/Python画小猪佩奇","date":"2021-06-26T02:26:42.000Z","updated":"2021-09-07T13:37:36.478Z","comments":true,"path":"2021/06/26/categories/Python/Python画小猪佩奇/","link":"","permalink":"https://visen123.github.io/2021/06/26/categories/Python/Python%E7%94%BB%E5%B0%8F%E7%8C%AA%E4%BD%A9%E5%A5%87/","excerpt":"","text":"小猪佩奇代码实现如下：import turtle as t t.begin_fill()t.pensize(4)t.hideturtle()t.colormode(255)t.color((255, 155, 192), “pink”)t.setup(840, 500)t.speed(10) 写字#设置字体颜色t.pencolor(“PINK”)#起笔t.penup()#设定坐标t.goto(-10,190)#设置写字内容和字体、字号t.write(“2021/06/16”, move=False, align=’center’, font=(“微软雅黑”, 26, ‘normal’)) 鼻子t.pu()t.goto(-100, 100)t.pd()t.seth(-30)#填充颜色t.begin_fill()a = 0.4for i in range(120): if 0 &lt;= i &lt; 30 or 60 &lt;= i &lt; 90: a = a + 0.08 t.lt(3) # 向左转3度 t.fd(a) # 向前走a的步长 else: a = a - 0.08 t.lt(3) t.fd(a)#结束填充t.end_fill() t.pu()t.seth(90)t.fd(25)t.seth(0)t.fd(10)t.pd()t.pencolor(255, 155, 192)t.seth(10)t.begin_fill()t.circle(5)t.color(160, 82, 45)t.end_fill() t.pu()t.seth(0)t.fd(20)t.pd()t.pencolor(255, 155, 192)t.seth(10)t.begin_fill()t.circle(5)t.color(160, 82, 45)t.end_fill() 头t.color((255, 155, 192), “pink”)t.pu()t.seth(90)t.fd(41)t.seth(0)t.fd(0)t.pd()t.begin_fill()t.seth(180)t.circle(300, -30)t.circle(100, -60)t.circle(80, -100)t.circle(150, -20)t.circle(60, -95)t.seth(161)t.circle(-300, 15)t.pu()t.goto(-100, 100)t.pd()t.seth(-30)a = 0.4for i in range(60): if 0 &lt;= i &lt; 30 or 60 &lt;= i &lt; 90: a = a + 0.08 t.lt(3) # 向左转3度 t.fd(a) # 向前走a的步长 else: a = a - 0.08 t.lt(3) t.fd(a)t.end_fill() 耳朵t.color((255, 155, 192), “pink”)t.pu()t.seth(90)t.fd(-7)t.seth(0)t.fd(70)t.pd()t.begin_fill()t.seth(100)t.circle(-50, 50)t.circle(-10, 120)t.circle(-50, 54)t.end_fill() t.pu()t.seth(90)t.fd(-12)t.seth(0)t.fd(30)t.pd()t.begin_fill()t.seth(100)t.circle(-50, 50)t.circle(-10, 120)t.circle(-50, 56)t.end_fill() 眼睛t.color((255, 155, 192), “white”)t.pu()t.seth(90)t.fd(-20)t.seth(0)t.fd(-95)t.pd()t.begin_fill()t.circle(15)t.end_fill() t.color(“black”)t.pu()t.seth(90)t.fd(12)t.seth(0)t.fd(-3)t.pd()t.begin_fill()t.circle(3)t.end_fill() t.color((255, 155, 192), “white”)t.pu()t.seth(90)t.fd(-25)t.seth(0)t.fd(40)t.pd()t.begin_fill()t.circle(15)t.end_fill() t.color(“black”)t.pu()t.seth(90)t.fd(12)t.seth(0)t.fd(-3)t.pd()t.begin_fill()t.circle(3)t.end_fill() 腮t.color((255, 155, 192))t.pu()t.seth(90)t.fd(-95)t.seth(0)t.fd(65)t.pd()t.begin_fill()t.circle(30)t.end_fill() 嘴t.color(239, 69, 19)t.pu()t.seth(90)t.fd(15)t.seth(0)t.fd(-100)t.pd()t.seth(-80)t.circle(30, 40)t.circle(40, 80) 身体t.color(“red”, (255, 99, 71))t.pu()t.seth(90)t.fd(-20)t.seth(0)t.fd(-78)t.pd()t.begin_fill()t.seth(-130)t.circle(100, 10)t.circle(300, 30)t.seth(0)t.fd(230)t.seth(90)t.circle(300, 30)t.circle(100, 3)t.color((255, 155, 192), (255, 100, 100))t.seth(-135)t.circle(-80, 63)t.circle(-150, 24)t.end_fill() 手t.color((255, 155, 192))t.pu()t.seth(90)t.fd(-40)t.seth(0)t.fd(-27)t.pd()t.seth(-160)t.circle(300, 15)t.pu()t.seth(90)t.fd(15)t.seth(0)t.fd(0)t.pd()t.seth(-10)t.circle(-20, 90) t.pu()t.seth(90)t.fd(30)t.seth(0)t.fd(237)t.pd()t.seth(-20)t.circle(-300, 15)t.pu()t.seth(90)t.fd(20)t.seth(0)t.fd(0)t.pd()t.seth(-170)t.circle(20, 90) 脚t.pensize(10)t.color((240, 128, 128))t.pu()t.seth(90)t.fd(-75)t.seth(0)t.fd(-180)t.pd()t.seth(-90)t.fd(40)t.seth(-180)t.color(“black”)t.pensize(15)t.fd(20) t.pensize(10)t.color((240, 128, 128))t.pu()t.seth(90)t.fd(40)t.seth(0)t.fd(90)t.pd()t.seth(-90)t.fd(40)t.seth(-180)t.color(“black”)t.pensize(15)t.fd(20) 尾巴t.pensize(4)t.color((255, 155, 192))#画笔抬起，不留下痕迹t.pu()t.seth(90)t.fd(70)t.seth(0)t.fd(95)#画笔落下，留下痕迹t.pd()t.seth(0)#画圆，第一个数字是半径，第二个数字是角度t.circle(70, 20)t.circle(10, 330)t.circle(70, 30)t.end_fill()#结束绘画t.done()","categories":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}],"tags":[],"keywords":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}]},{"title":"Python例子-复制文件","slug":"categories/Python/Python复制文件","date":"2021-06-24T13:26:30.000Z","updated":"2021-09-03T14:48:40.213Z","comments":true,"path":"2021/06/24/categories/Python/Python复制文件/","link":"","permalink":"https://visen123.github.io/2021/06/24/categories/Python/Python%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6/","excerpt":"","text":"代码实现如下：按照用户输入的文件文件名字，新建一个文件，在文件里面写入内容，然后复制文件1,先按照用户的输入，新建一个old_file文件，并写入内容 2，以用户输入的名字，构造一个复制文件new_file的名字 3，把old_file的内容读出来并写入到new_file里面取 old_file_name = input(‘请输入文件名:’)old_file = open(old_file_name,’w’)old_file.write(‘1,hello world\\n2,hello world\\n3,hello world’)old_file.close()file_flag_num = old_file_name.rfind(‘.’)if file_flag_num &gt; 0: file_name = old_file_name[:file_flag_num] file_flag = old_file_name[file_flag_num:] new_file_name = file_name + ‘附件’ + file_flagelse: print(‘输入的文件名有错！’) new_file_name = Nonenew_file = open(new_file_name,’w’)old_file = open(old_file_name,’r’) # 要重新打开一次，不然是读取的没有内容的文件contents = old_file.readlines()for con in contents: new_file.write(con) 关闭文件old_file.close()new_file.close()","categories":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}],"tags":[],"keywords":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}]},{"title":"Python画动漫海贼王","slug":"categories/Python/Python画动漫海贼王","date":"2021-06-23T08:26:42.000Z","updated":"2021-09-07T13:35:03.867Z","comments":true,"path":"2021/06/23/categories/Python/Python画动漫海贼王/","link":"","permalink":"https://visen123.github.io/2021/06/23/categories/Python/Python%E7%94%BB%E5%8A%A8%E6%BC%AB%E6%B5%B7%E8%B4%BC%E7%8E%8B/","excerpt":"","text":"代码实现如下：import turtle as t “”” t.hideturtle()t.bgcolor(‘white’) “”” t.setup(800,500) # 创建画布并使其位于屏幕中心t.pensize(2) # 画笔粗细t.colormode(255) # 色彩模式t.speed(10) # 绘画速度t.color(‘black’,(255,228,181)) # 画笔颜色与填充色t.shape(‘turtle’) # 画笔的形状t.speed(10) #画笔速度t.showturtle() # 使画笔显现 移动画笔def move(x, y, angle): t.pu() t.goto(x, y) t.seth(angle) t.pd() 画圆填充颜色def draw_circle(x, y, r, color): t.color(color) t.pu() t.goto(x, y) t.seth(-90) t.fd(r) t.seth(0) t.pd t.begin_fill() t.circle(r) t.end_fill() pass 画圆不填充颜色def draw_circle_normal(x, y, r): t.pu() t.goto(x, y) t.seth(-90) t.fd(r) t.seth(0) t.pd() t.circle(r) pass 画脸def draw_face(): t.color(‘black’, ‘white’) move(0, -103, 0) t.begin_fill() t.circle(103, 90) t.seth(180) t.fd(103*2) t.seth(-90) t.circle(103, 90) t.end_fill() pass 画眼睛、鼻子def draw_eyes(): t.color(‘black’) move(-40, 0, 180) t.begin_fill() t.circle(30) t.end_fill() move(40, 0, 180) t.begin_fill() t.circle(30) t.end_fill() move(0, -61, 180) t.begin_fill() t.circle(13) t.end_fill() 画帽子def draw_hat(): t.color(‘black’, ‘#fcd462’) move(0, 0, 0) t.begin_fill() t.fd(175) t.circle(15, 180) t.fd(175*2) t.circle(15, 180) t.fd(175) t.end_fill() pass move(0, 0, 17) t.color(‘#fcd462’) t.pu() t.fd(103) p1 = t.position() t.left(90) t.pd() t.begin_fill() t.circle(103, 147) t.seth(0) p2 = t.position() t.goto(p1) t.end_fill() pass t.color(‘#fe0202’) t.seth(107) t.begin_fill() t.circle(103, 15) p3 = t.position() t.pu() t.right(180) t.circle(-103, 15) t.seth(180) t.pd() t.goto(p2) t.seth(77) t.circle(-103, 15) t.goto(p3) t.end_fill() pass 画嘴巴def draw_mouth(): move(0, -90, 180) t.color(‘black’, ‘white’) t.begin_fill() t.circle(50) t.end_fill() pass draw_circle_normal(0, 0, 160) draw_circle_normal(0, 0, 130) move(0,-103,-90) t.fd(57) p4=t.position() t.seth(0) t.pu() t.circle(160,10) t.seth(100) t.pd() t.fd(57) t.pu() t.goto(p4) t.seth(180) t.pd() t.circle(-160,10) t.seth(80) t.fd(57) pass 画骨头十字架def draw_bone(): t.color(‘black’,’white’) move(-132,155,-42) t.fd(404) t.left(90) t.circle(-20,270) t.right(180) t.circle(-20,270) t.seth(138) t.fd(404) t.left(90) t.circle(-20,270) t.left(180) t.circle(-20,270) pass move(-132,-155,48) t.fd(404) t.right(90) t.circle(20,270) t.right(180) t.circle(20,270) t.seth(228) t.fd(404) t.right(90) t.circle(20,270) t.left(180) t.circle(20,270) pass t.pensize(5)draw_bone()t.pensize(2)draw_circle(0,0,160,’black’)draw_mouth()draw_face()draw_eyes()draw_hat()t.done()","categories":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}],"tags":[],"keywords":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}]},{"title":"Python例子-九九乘法表","slug":"categories/Python/Python九九乘法表","date":"2021-06-23T08:26:30.000Z","updated":"2021-09-03T14:46:53.479Z","comments":true,"path":"2021/06/23/categories/Python/Python九九乘法表/","link":"","permalink":"https://visen123.github.io/2021/06/23/categories/Python/Python%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E8%A1%A8/","excerpt":"","text":"代码实现如下：Python例子-用python语言实现九九乘法表 Python例子-用python语言实现九九乘法表i = 1while i &lt;= 9: j = 1 while j &lt;= i: print(‘%d*%d=%d’ % (j, i, ij) ,end=’ ‘) j += 1 print() i += 1‘’’输出结果11=112=2 22=413=3 23=6 33=914=4 24=8 34=12 44=1615=5 25=10 35=15 45=20 55=2516=6 26=12 36=18 46=24 56=30 66=3617=7 27=14 37=21 47=28 57=35 67=42 77=4918=8 28=16 38=24 48=32 58=40 68=48 78=56 88=6419=9 29=18 39=27 49=36 59=45 69=54 79=63 89=72 99=81‘’’","categories":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}],"tags":[],"keywords":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}]},{"title":"Python画哆啦A梦","slug":"categories/Python/Python画哆啦A梦","date":"2021-06-21T12:26:42.000Z","updated":"2021-09-07T13:31:32.107Z","comments":true,"path":"2021/06/21/categories/Python/Python画哆啦A梦/","link":"","permalink":"https://visen123.github.io/2021/06/21/categories/Python/Python%E7%94%BB%E5%93%86%E5%95%A6A%E6%A2%A6/","excerpt":"","text":"实现代码如下：import turtle def flyTo(x, y): turtle.penup() turtle.goto(x, y) turtle.pendown() def drawEye(): turtle.tracer(False) a = 2.5 for i in range(120): if 0 &lt;= i &lt; 30 or 60 &lt;= i &lt; 90: a -= 0.05 else: a += 0.05 turtle.left(3) turtle.fd(a) turtle.tracer(True) def beard(): “”” 画胡子， 一共六根 “”” # 左边第一根胡子 flyTo(-37, 135) turtle.seth(165) turtle.fd(60) # 左边第二根胡子 flyTo(-37, 125) turtle.seth(180) turtle.fd(60) # 左边第三根胡子 flyTo(-37, 115) turtle.seth(193) turtle.fd(60) # 右边第一根胡子 flyTo(37, 135) turtle.seth(15) turtle.fd(60) # 右边第二根胡子 flyTo(37, 125) turtle.seth(0) turtle.fd(60) # 右边第三根胡子 flyTo(37, 115) turtle.seth(-13) turtle.fd(60) def drawRedScarf(): “”” 画围巾 “”” turtle.fillcolor(“red”) # 填充颜色 turtle.begin_fill() turtle.seth(0) # 朝向右 turtle.fd(200) # 前进10个单位 turtle.circle(-5, 90) turtle.fd(10) turtle.circle(-5, 90) turtle.fd(207) turtle.circle(-5, 90) turtle.fd(10) turtle.circle(-5, 90) turtle.end_fill() def drawMouse(): flyTo(5, 148) turtle.seth(270) turtle.fd(100) turtle.seth(0) turtle.circle(120, 50) turtle.seth(230) turtle.circle(-120, 100) def drawRedNose(): flyTo(-10, 158) turtle.fillcolor(“red”) # 填充颜色 turtle.begin_fill() turtle.circle(20) turtle.end_fill() def drawBlackdrawEye(): turtle.seth(0) flyTo(-20, 195) turtle.fillcolor(“#000000”) # 填充颜色 turtle.begin_fill() turtle.circle(13) turtle.end_fill() turtle.pensize(6) flyTo(20, 205) turtle.seth(75) turtle.circle(-10, 150) turtle.pensize(3) flyTo(-17, 200) turtle.seth(0) turtle.fillcolor(“#ffffff”) turtle.begin_fill() turtle.circle(5) turtle.end_fill() flyTo(0, 0) def drawFace(): “”” “”” turtle.forward(183) # 前行183个单位 turtle.fillcolor(“white”) # 填充颜色为白色 turtle.begin_fill() # 开始填充 turtle.left(45) # 左转45度 turtle.circle(120, 100) # 右边那半边脸 turtle.seth(90) # 朝向向上 drawEye() # 画右眼睛 turtle.seth(180) # 朝向左 turtle.penup() # 抬笔 turtle.fd(60) # 前行60 turtle.pendown() # 落笔 turtle.seth(90) # 朝向上 drawEye() # 画左眼睛 turtle.penup() # 抬笔 turtle.seth(180) # 朝向左 turtle.fd(64) # 前进64 turtle.pendown() # 落笔 turtle.seth(215) # 修改朝向 turtle.circle(120, 100) # 左边那半边脸 turtle.end_fill() # def drawHead(): “”” 画了一个被切掉下半部分的圆 “”” turtle.penup() # 抬笔 turtle.circle(150, 40) # 画圆, 半径150，圆周角40 turtle.pendown() # 落笔 turtle.fillcolor(“#00a0de”) # 填充色 turtle.begin_fill() # 开始填充 turtle.circle(150, 280) # 画圆，半径150, 圆周角280 turtle.end_fill() def drawAll(): drawHead() drawRedScarf() drawFace() drawRedNose() drawMouse() beard() flyTo(0, 0) turtle.seth(0) turtle.penup() turtle.circle(150, 50) turtle.pendown() turtle.seth(30) turtle.fd(40) turtle.seth(70) turtle.circle(-30, 270) turtle.fillcolor(“#00a0de”) turtle.begin_fill() turtle.seth(230) turtle.fd(80) turtle.seth(90) turtle.circle(1000, 1) turtle.seth(-89) turtle.circle(-1000, 10) turtle.seth(180) turtle.fd(70) turtle.seth(90) turtle.circle(30, 180) turtle.seth(180) turtle.fd(70) turtle.seth(100) turtle.circle(-1000, 9) turtle.seth(-86) turtle.circle(1000, 2) turtle.seth(230) turtle.fd(40) turtle.circle(-30, 230) turtle.seth(45) turtle.fd(81) turtle.seth(0) turtle.fd(203) turtle.circle(5, 90) turtle.fd(10) turtle.circle(5, 90) turtle.fd(7) turtle.seth(40) turtle.circle(150, 10) turtle.seth(30) turtle.fd(40) turtle.end_fill() # 左手 turtle.seth(70) turtle.fillcolor(&quot;#FFFFFF&quot;) turtle.begin_fill() turtle.circle(-30) turtle.end_fill() # 脚 flyTo(103.74, -182.59) turtle.seth(0) turtle.fillcolor(&quot;#FFFFFF&quot;) turtle.begin_fill() turtle.fd(15) turtle.circle(-15, 180) turtle.fd(90) turtle.circle(-15, 180) turtle.fd(10) turtle.end_fill() flyTo(-96.26, -182.59) turtle.seth(180) turtle.fillcolor(&quot;#FFFFFF&quot;) turtle.begin_fill() turtle.fd(15) turtle.circle(15, 180) turtle.fd(90) turtle.circle(15, 180) turtle.fd(10) turtle.end_fill() # 右手 flyTo(-133.97, -91.81) turtle.seth(50) turtle.fillcolor(&quot;#FFFFFF&quot;) turtle.begin_fill() turtle.circle(30) turtle.end_fill() # 口袋 flyTo(-103.42, 15.09) turtle.seth(0) turtle.fd(38) turtle.seth(230) turtle.begin_fill() turtle.circle(90, 260) turtle.end_fill() flyTo(5, -40) turtle.seth(0) turtle.fd(70) turtle.seth(-90) turtle.circle(-70, 180) turtle.seth(0) turtle.fd(70) # 铃铛 flyTo(-103.42, 15.09) turtle.fd(90) turtle.seth(70) turtle.fillcolor(&quot;#ffd200&quot;) turtle.begin_fill() turtle.circle(-20) turtle.end_fill() turtle.seth(170) turtle.fillcolor(&quot;#ffd200&quot;) turtle.begin_fill() turtle.circle(-2, 180) turtle.seth(10) turtle.circle(-100, 22) turtle.circle(-2, 180) turtle.seth(180 - 10) turtle.circle(100, 22) turtle.end_fill() flyTo(-13.42, 15.09) turtle.seth(250) turtle.circle(20, 110) turtle.seth(90) turtle.fd(15) turtle.dot(10) flyTo(0, -150) drawBlackdrawEye() def main(): turtle.screensize(800, 6000, “#F0F0F0”) turtle.pensize(3) turtle.speed(9) drawAll() if name == “main“: main() turtle.mainloop()","categories":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}],"tags":[],"keywords":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}]},{"title":"教你如何使用Bugly修复线上安卓APP存在的bug","slug":"categories/Android/教你如何使用Bugly修复线上安卓APP存在的bug","date":"2021-06-21T09:33:40.000Z","updated":"2021-09-01T04:56:09.967Z","comments":true,"path":"2021/06/21/categories/Android/教你如何使用Bugly修复线上安卓APP存在的bug/","link":"","permalink":"https://visen123.github.io/2021/06/21/categories/Android/%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Bugly%E4%BF%AE%E5%A4%8D%E7%BA%BF%E4%B8%8A%E5%AE%89%E5%8D%93APP%E5%AD%98%E5%9C%A8%E7%9A%84bug/","excerpt":"","text":"热更新能力是Bugly为解决开发者紧急修复线上bug，而无需重新发版让用户无感知就能把问题修复的一项能力。 Bugly目前采用微信Tinker的开源方案，开发者只需要集成腾讯官网提供的Bugly SDK就可以实现自动下载补丁包、合成、并应用补丁的功能，而且可以通过管理后台让开发者对每个版本补丁进行管理。 教你如何使用Bugly修复线上安卓APP存在的bug_bugly 为什么使用Bugly热更新呢？因为Bugly热更新有如下好处1、无需关注Tinker是如何合成补丁的2、无需自己搭建补丁管理后台3、无需考虑后台下发补丁策略的任何事情4、无需考虑补丁下载合成的时机，处理后台下发的策略5、提供了更加方便集成Tinker的方式6、通过HTTPS及签名校验等机制保障补丁下发的安全性7、丰富的下发维度控制，有效控制补丁影响范围8、提供了应用升级一站式解决方案 接下来教你如何使用Bugly热更新，具体操作如下 第一步：添加插件依赖工程根目录下“build.gradle”文件中添加： buildscript { repositories { jcenter() } dependencies { // tinkersupport插件, 其中lastest.release指拉取最新版本，也可以指定明确版本号，例如1.0.4 classpath “com.tencent.bugly:tinker-support:latest.release” }} 第二步：集成SDKgradle配置 在app module的“build.gradle”文件中添加（示例配置）： android { defaultConfig { ndk { //设置支持的SO库架构 abiFilters ‘armeabi’ //, ‘x86’, ‘armeabi-v7a’, ‘x86_64’, ‘arm64-v8a’ } } } dependencies { compile “com.android.support:multidex:1.0.1” // 多dex配置 //注释掉原有bugly的仓库 //compile ‘com.tencent.bugly:crashreport:latest.release’//其中latest.release指代最新版本号，也可以指定明确的版本号，例如2.3.2 compile ‘com.tencent.bugly:crashreport_upgrade:latest.release’//其中latest.release指代最新版本号，也可以指定明确的版本号，例如1.2.0 compile ‘com.tencent.bugly:nativecrashreport:latest.release’ //其中latest.release指代最新版本号，也可以指定明确的版本号，例如2.2.0 } 在app module的“build.gradle”文件中添加： // 依赖插件脚本apply from: ‘tinker-support.gradle’tinker-support.gradle内容如下所示（示例配置）： apply plugin: ‘com.tencent.bugly.tinker-support’ def bakPath = file(“${buildDir}/bakApk/“)/*在本类中需要修改： 1.baseApkDir 2-4名称的修改 2.baseApk 3.baseApkProguardMapping 4.baseApkResourceMapping 5.tinkerId 编号必须一致 //* 此处填写每次构建生成的基准包目录 app/build/bakApk/app-0621-21-10-33 /def baseApkDir = “app-0621-21-10-33” /** 对于插件各参数的详细解析请参考 /tinkerSupport { // 开启tinker-support插件，默认值true enable = true // 指定归档目录，默认值当前module的子目录tinker autoBackupApkDir = “${bakPath}” // 是否启用覆盖tinkerPatch配置功能，默认值false // 开启后tinkerPatch配置不生效，即无需添加tinkerPatch overrideTinkerPatchConfiguration = true // 编译补丁包时，必需指定基线版本的apk，默认值为空 // 如果为空，则表示不是进行补丁包的编译 // @{link tinkerPatch.oldApk } baseApk = “${bakPath}/${baseApkDir}/app-release.apk” // 对应tinker插件applyMapping baseApkProguardMapping = “${bakPath}/${baseApkDir}/app-release-mapping.txt” // 对应tinker插件applyResourceMapping baseApkResourceMapping = “${bakPath}/${baseApkDir}/app-release-R.txt” // 构建基准包和补丁包都要指定不同的tinkerId，并且必须保证唯一性 base patch tinkerId = “base-1.0.3” //base-1.0.3 错误版本 patch-1.0.3 补丁版本 （1.0.3基准包和补丁包版本要一致） // 构建多渠道补丁时使用 // buildAllFlavorsDir = “${bakPath}/${baseApkDir}” // 是否开启反射Application模式 enableProxyApplication = false//使用SampleApplication和SampleApplicationLike //enableProxyApplication = true//使用MyApplication } /** 一般来说,无需对下面的参数做任何的修改 对于各参数的详细介绍请参考: https://github.com/Tencent/tinker/wiki/Tinker-%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97 /tinkerPatch { //oldApk =”${bakPath}/${appName}/app-release.apk” ignoreWarning = false useSign = true dex { dexMode = &quot;jar&quot; pattern = [&quot;classes*.dex&quot;] loader = [] } lib { pattern = [&quot;lib/*/*.so&quot;] } res { pattern = [&quot;res/*&quot;, &quot;r/*&quot;, &quot;assets/*&quot;, &quot;resources.arsc&quot;, &quot;AndroidManifest.xml&quot;] ignoreChange = [] largeModSize = 100 } packageConfig { } sevenZip { zipArtifact = &quot;com.tencent.mm:SevenZip:1.1.10&quot; // path = “/usr/local/bin/7za” } buildConfig { keepDexApply = false //tinkerId = &quot;1.0.1-base&quot; //applyMapping = &quot;$&#123;bakPath&#125;/$&#123;appName&#125;/app-release-mapping.txt&quot; // 可选，设置mapping文件，建议保持旧apk的proguard混淆方式 //applyResourceMapping = &quot;$&#123;bakPath&#125;/$&#123;appName&#125;/app-release-R.txt&quot; // 可选，设置R.txt文件，通过旧apk文件保持ResId的分配 }} 第三步：初始化SDKenableProxyApplication = false 的情况这是Tinker推荐的接入方式，一定程度上会增加接入成本，但具有更好的兼容性。 集成Bugly升级SDK之后，需要按照以下方式自定义ApplicationLike来实现Application的代码（以下是示例）： 自定义Application public class SampleApplication extends TinkerApplication { public SampleApplication() { super(ShareConstants.TINKER_ENABLE_ALL, “xxx.xxx.SampleApplicationLike”, “com.tencent.tinker.loader.TinkerLoader”, false); }} 注意：这个类集成TinkerApplication类，这里面不做任何操作，所有Application的代码都会放到ApplicationLike继承类当中参数解析参数1：tinkerFlags 表示Tinker支持的类型 dex only、library only or all suuport，default: TINKER_ENABLE_ALL参数2：delegateClassName Application代理类 这里填写你自定义的ApplicationLike参数3：loaderClassName Tinker的加载器，使用默认即可参数4：tinkerLoadVerifyFlag 加载dex或者lib是否验证md5，默认为false———————————————— 需要您将以前的Applicaton配置为继承TinkerApplication的类： 教你如何使用Bugly修复线上安卓APP存在的bug_Bugly使用_02 自定义ApplicationLike public class SampleApplicationLike extends DefaultApplicationLike { public static final String TAG = &quot;Tinker.SampleApplicationLike&quot;; public SampleApplicationLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag, long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent) &#123; super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent); &#125; @Override public void onCreate() &#123; super.onCreate(); // 这里实现SDK初始化，appId替换成你的在Bugly平台申请的appId // 调试时，将第三个参数改为true Bugly.init(getApplication(), &quot;900029763&quot;, false); &#125; @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) @Override public void onBaseContextAttached(Context base) &#123; super.onBaseContextAttached(base); // you must install multiDex whatever tinker is installed! MultiDex.install(base); // 安装tinker // TinkerManager.installTinker(this); 替换成下面Bugly提供的方法 Beta.installTinker(this); &#125; @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) public void registerActivityLifecycleCallback(Application.ActivityLifecycleCallbacks callbacks) &#123; getApplication().registerActivityLifecycleCallbacks(callbacks); &#125; } 注意：tinker需要你开启MultiDex,你需要在dependencies中进行配置compile “com.android.support:multidex:1.0.1”才可以使用MultiDex.install方法； SampleApplicationLike这个类是Application的代理类，以前所有在Application的实现必须要全部拷贝到这里，在onCreate方法调用SDK的初始化方法，在onBaseContextAttached中调用Beta.installTinker(this);。 enableProxyApplication = true 的情况 public class MyApplication extends Application { @Override public void onCreate() &#123; super.onCreate(); // 这里实现SDK初始化，appId替换成你的在Bugly平台申请的appId // 调试时，将第三个参数改为true 900029763自己申请的ID Bugly.init(this, &quot;900029763&quot;, false); &#125; @Override protected void attachBaseContext(Context base) &#123; super.attachBaseContext(base); // you must install multiDex whatever tinker is installed! MultiDex.install(base); // 安装tinker Beta.installTinker(); &#125; } 第四步：AndroidManifest.xml配置 权限配置 第五步：混淆配置为了避免混淆SDK，在Proguard混淆文件中增加以下配置： -dontwarn com.tencent.bugly.**-keep public class com.tencent.bugly.**{*;} 如果你使用了support-v4包，你还需要配置以下混淆规则： -keep class android.support.**{*;} bugly地址：https://bugly.qq.com/docs/user-guide/instruction-manual-android-hotfix/?v=20170322165254Github Demohttps://github.com/BuglyDevTeam/Bugly-Android-Demo ##普通打包##1、编译基准包配置基准包的tinkerId 教你如何使用Bugly修复线上安卓APP存在的bug_热更新_03 inkerId最好是一个唯一标识，例如git版本号、versionName等等。 如果你要测试热更新，你需要对基线版本进行联网上报。 这里强调一下，基线版本配置一个唯一的tinkerId，而这个基线版本能够应用补丁的前提是集成过热更新SDK，并启动上报过联网，这样后台会将这个tinkerId对应到一个目标版本，例如tinkerId= “bugly_1.0.0” 对应了一个目标版本是1.0.0，基于这个版本打的补丁包就能匹配到目标版本。 执行assembleRelease编译生成基准包： 教你如何使用Bugly修复线上安卓APP存在的bug_Bugly使用_04 这个会在build/outputs/bakApk路径下生成每次编译的基准包、混淆配置文件、资源Id文件，如下图所示： 教你如何使用Bugly修复线上安卓APP存在的bug_bugly_05 实际应用中，请注意保存线上发布版本的基准apk包、mapping文件、R.txt文件，如果线上版本有bug，就可以借助tinker-support插件进行补丁包的生成。 启动apk，上报联网数据 每次冷启动都会请求补丁策略，会上报当前版本号和tinkerId，这样后台就能将这个唯一的tinkerId对应到一个版本，大家测试的时候可以打开logcat查看的日志，如下图所示： 教你如何使用Bugly修复线上安卓APP存在的bug_bugly_06 如果看不到log，您需要将bugly初始化的第三个参数设置为true才能看到。##2、对基线版本的bug修复未修复前 教你如何使用Bugly修复线上安卓APP存在的bug_bugly_07 这个类有一个会造成空指针的方法。 修复后 教你如何使用Bugly修复线上安卓APP存在的bug_bugly_08 对产生bug的类进行修复，作为补丁下次覆盖基线版本的类。 ##3、根据基线版本生成补丁包修改待修复apk路径、mapping文件路径、resId文件路径 教你如何使用Bugly修复线上安卓APP存在的bug_安卓开发_09 执行构建补丁包的task 教你如何使用Bugly修复线上安卓APP存在的bug_Bugly使用_10 如果你要生成不同编译环境的补丁包，只需要执行TinkerSupport插件生成的task，比如buildTinkerPatchRelease就能生成release编译环境的补丁包。 注：TinkerSupport插件版本低于1.0.4的，需要使用tinkerPatchRelease来生成补丁包 。 生成的补丁包在build/outputs/patch目录下： 教你如何使用Bugly修复线上安卓APP存在的bug_bugly_11 大家这里可能会有一个疑问，补丁版本是怎么匹配到目标版本的，可以双击patch包，提供的插件会在tinker生成的patch包基础上插入一个MF文件： 教你如何使用Bugly修复线上安卓APP存在的bug_线上修复bug_12 教你如何使用Bugly修复线上安卓APP存在的bug_线上修复bug_13 ##4、上传补丁包到平台上传补丁包到平台并下发编辑规则 教你如何使用Bugly修复线上安卓APP存在的bug_线上修复bug_14 教你如何使用Bugly修复线上安卓APP存在的bug_线上修复bug_15 教你如何使用Bugly修复线上安卓APP存在的bug_热更新_16 点击发布新补丁，上传前面生成的patch包，平台会自动为你匹配到目标版本，你可以选择下发范围（开发设备、全量设备、自定义），填写完备注之后，点击立即下发让补丁生效，这样你就可以在客户端当中收到的策略，SDK会自动帮你把补丁包下到本地。 ##5、测试补丁应用效果启动app应用patch 教你如何使用Bugly修复线上安卓APP存在的bug_安卓开发_17 如果匹配到目标版本，后台就会下发补丁策略，可以在logcat看到如下日志： 教你如何使用Bugly修复线上安卓APP存在的bug_热更新_18 下载成功之后，会立即去合成补丁，可以看到patch合成的日志： 教你如何使用Bugly修复线上安卓APP存在的bug_bugly_19 ##重启app查看效果 教你如何使用Bugly修复线上安卓APP存在的bug_线上修复bug_20 注：方案是基于Tinker方案的实现，需要下次启动才能让补丁生效 ##多渠道打包 tinker是支持打多渠道的，建议大家按照以下步骤进行最佳实践： ##1. 配置productFlavors android { … // 多渠道打包（示例配置） productFlavors &#123; xiaomi &#123; applicationId &#39;com.tencent.bugly.hotfix.xiaomi&#39; &#125; yyb &#123; applicationId &#39;com.tencent.bugly.hotfix.yyb&#39; &#125; &#125; … } ##2. 执行assembleRelease生成基线apk按照普通打包方式正常配置基线版本的tinkerId，然后执行assembleRelease生成不同渠道的apk，会在工程中build/bakApk/生成如下图所示文件： 教你如何使用Bugly修复线上安卓APP存在的bug_bugly_21 ##3. 打渠道补丁包配置 教你如何使用Bugly修复线上安卓APP存在的bug_安卓开发_22 4.执行buildAllFlavorsTinkerPatchRelease生成所有渠道补丁包如下图所示： 教你如何使用Bugly修复线上安卓APP存在的bug_热更新_23 5.测试应用补丁包与普通打包一致。 加固打包（仅支持tinker 1.7.5及以下） tinker的一般模式需要Dex的合成，它并不支持加固，一定要使用加固的app可以使用usePreGeneratedPatchDex模式。由于加固会改变apk的dex结构，所以生成补丁包时务必要使用加固前的apk。但是需要注意的是，某些加固工具会将非exported的四大组件的类名替换，对于这部分类即使使用usePreGeneratedPatchDex也无法修改。对于360加固，MainActivity由于被提前加载，也无法修复。大家对于加固的情况，请仔细测试，能否支持与加固的方式有关联。 1.提前生成dex配置tinker是支持加固模式的，但需要你回退到Qzone方案 ，将usePreGeneratedPatchDex设置为true。 教你如何使用Bugly修复线上安卓APP存在的bug_安卓开发_24 是否提前生成dex，而非合成的方式。这套方案即回退成Qzone的方案，对于需要使用加固或者多flavor打包(建议使用其他方式生成渠道包)的用户可使用。但是这套方案需要插桩，会造成Dalvik下性能损耗以及Art补丁包可能过大的问题，务必谨慎使用。另外一方面，这种方案在AndroidN之后可能会产生问题，建议过滤N之后的用户。 2.将基准包进行加固如果你的app需要进行加固，你需要将你打出的基准包上传到具体的加固平台进行加固，例如乐固，加固完成之后需要对apk进行重签名： jarsigner -verbose -keystore -signedjar 以上命令说明：-verbose：指定生成详细输出-keystore：指定证书存储路径-signedjar：改选项的三个参数分别为签名后的apk包、未签名的apk包、数字证书别名 3.根据加固的基准包生成补丁包打patch包的操作跟普通打包方式一致。 buglySDK下载地址：https://bugly.qq.com/v2/sdkDownload bugly热更新使用指南文档：https://bugly.qq.com/docs/user-guide/api-hotfix/?v=20200622202242","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"Android Studio中代码做混淆方法","slug":"categories/Android/Android Studio中代码做混淆方法","date":"2021-06-20T07:33:40.000Z","updated":"2021-09-01T04:47:49.308Z","comments":true,"path":"2021/06/20/categories/Android/Android Studio中代码做混淆方法/","link":"","permalink":"https://visen123.github.io/2021/06/20/categories/Android/Android%20Studio%E4%B8%AD%E4%BB%A3%E7%A0%81%E5%81%9A%E6%B7%B7%E6%B7%86%E6%96%B9%E6%B3%95/","excerpt":"","text":"##在bulid.gradle文件中： ###设置如下 buildTypes { release &#123; minifyEnabled true proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39; &#125; &#125; 在proguard-rules.pro文件中加入以下代码： ##使用butterknife注入会导致ProGuard 认为变量未被使用，因此，需要在ProGuard 中加入如下字段 -dontwarn butterknife.internal.** -keep class **$$ViewInjector { *; } -keepnames class * { @butterknife.InjectView *;} ##==================gson========================== -dontwarn com.google.** -keep class com.google.gson.**{*;} ##==================protobuf======================- -dontwarn com.google.** -keep class com.google.protobuf.** {*;} ##集成百度地图SDK的应用，在打包混淆的时候，需要注意与地图SDK相关的方法不可被混淆，否则会出现网络不可用等运行时异常。混淆方法如下： -keep class com.baidu.** {*;} -keep class vi.com.** {*;} -dontwarn com.baidu.** -dontwarn com.baidu.mapapi.** -keep class com.baidu.mapapi.** {*; } -keep class assets.** {*; } -keep class vi.com.gdi.bgl.** {*; } ##下面是常见的proguard.cfg配置项 ##指定代码的压缩级别 -optimizationpasses 5 ##包名不混合大小写 -dontusemixedcaseclassnames ##不去忽略非公共的库类 -dontskipnonpubliclibraryclasses ##优化 不优化输入的类文件 -dontoptimize ##预校验 -dontpreverify ##混淆时是否记录日志 -verbose ##混淆时所采用的算法 -optimizations !code/simplification/arithmetic,!field/,!class/merging/ ##保护注解 -keepattributes Annotation 保持哪些类不被混淆-keep public class * extends android.app.Fragment -keep public class * extends android.app.Activity -keep public class * extends android.app.Application -keep public class * extends android.app.Service -keep public class * extends android.content.BroadcastReceiver -keep public class * extends android.content.ContentProvider -keep public class * extends android.app.backup.BackupAgentHelper -keep public class * extends android.preference.Preference -keep public class * extends android.support.v4.** -keep public class com.android.vending.licensing.ILicensingService ##如果有引用v4包可以添加下面这行 -keep public class * extends android.support.v4.app.Fragment ##########JS接口类不混淆，否则执行不了 -dontwarn com.android.JsInterface.** -keep class com.android.JsInterface.** {*; } ##极光推送和百度lbs android sdk一起使用proguard 混淆的问题#http的类被混淆后，导致apk定位失败，保持apache 的http类不被混淆就好了 -dontwarn org.apache.** -keep class org.apache.**{ *; } ##忽略警告 -ignorewarning ##记录生成的日志数据,gradle build时在本项目根目录输出## ##apk 包内所有 class 的内部结构 -dump class_files.txt ##未混淆的类和成员-printseeds seeds.txt ##列出从 apk 中删除的代码 -printusage unused.txt ##混淆前后的映射-printmapping mapping.txt ########记录生成的日志数据，gradle build时 在本项目根目录输出-end##### ######混淆保护自己项目的部分代码以及引用的第三方jar包library######## ##如果引用了v4或者v7包 -dontwarn android.support.** ####混淆保护自己项目的部分代码以及引用的第三方jar包library-end#### -keep public class * extends android.view.View { public (android.content.Context); public (android.content.Context, android.util.AttributeSet); public (android.content.Context, android.util.AttributeSet, int); public void set*(…); } #保持 native 方法不被混淆 -keepclasseswithmembernames class * { native ; } #保持自定义控件类不被混淆 -keepclasseswithmembers class * { public (android.content.Context, android.util.AttributeSet); } #保持自定义控件类不被混淆 -keepclassmembers class * extends android.app.Activity { public void *(android.view.View); } #保持 Parcelable 不被混淆 -keep class * implements android.os.Parcelable { public static final android.os.Parcelable$Creator *; } #保持 Serializable 不被混淆 -keepnames class * implements java.io.Serializable #保持 Serializable 不被混淆并且enum 类也不被混淆 -keepclassmembers class * implements java.io.Serializable { static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; !static !transient &lt;fields&gt;; !private &lt;fields&gt;; !private &lt;methods&gt;; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve(); } #保持枚举 enum 类不被混淆 如果混淆报错，建议直接使用上面的 -keepclassmembers class * implements java.io.Serializable即可 -keepclassmembers enum * { public static **[] values(); public static ** valueOf(java.lang.String); } -keepclassmembers class * { public void *ButtonClicked(android.view.View); } #不混淆资源类 -keepclassmembers class **.R$* { public static &lt;fields&gt;; } #避免混淆泛型 如果混淆报错建议关掉 #–keepattributes Signature #如果用到Gson解析包的，直接添加下面这几行就能成功混淆，不然会报错 #gson #-libraryjars libs/gson-2.2.2.jar -keepattributes Signature Gson specific classes-keep class sun.misc.Unsafe { *; } Application classes that will be serialized/deserialized over Gson-keep class com.google.gson.examples.android.model.** { *; } #客户端代码中的JavaBean(实体类)的类名与其字段名称全部变成了a、b、c、d等等字符串，这与服务端返回的json字符串中的不一致，导致解析失败。所以，解决的办法是：在进行混淆编译进行打包apk的时候，过滤掉存放所有JavaBean（实体类)的包不进行混淆编译 -keep class com.android.model.** {*;}","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"Python年份是否是闰年","slug":"categories/Python/Python年份是否是闰年","date":"2021-06-19T13:26:42.000Z","updated":"2021-09-03T14:45:25.964Z","comments":true,"path":"2021/06/19/categories/Python/Python年份是否是闰年/","link":"","permalink":"https://visen123.github.io/2021/06/19/categories/Python/Python%E5%B9%B4%E4%BB%BD%E6%98%AF%E5%90%A6%E6%98%AF%E9%97%B0%E5%B9%B4/","excerpt":"","text":"代码实现如下：请用Python语言实现一个判断用户输入的年份是否是闰年的程序 提示： 1.能被400整除的年份 2.能被4整除，同时不能被100整除的年份 以上2种方法满足一种即为闰年 ‘’’请用Python语言实现一个判断用户输入的年份是否是闰年的程序提示：1.能被400整除的年份2.能被4整除，同时不能被100整除的年份以上2种方法满足一种即为闰年‘’’while True: year = int(input(‘请输入一个年份:’)) if (year % 400 == 0) or ((year % 4 == 0) and (year % 100 != 0)): print(‘%d是闰年’ % year) else: print(‘%d不是闰年’ % year)","categories":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}],"tags":[],"keywords":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}]},{"title":"Python例子-urllib模拟游览器","slug":"categories/Python/Python例子urllib模拟游览器","date":"2021-06-19T09:26:26.000Z","updated":"2021-09-03T14:42:19.148Z","comments":true,"path":"2021/06/19/categories/Python/Python例子urllib模拟游览器/","link":"","permalink":"https://visen123.github.io/2021/06/19/categories/Python/Python%E4%BE%8B%E5%AD%90urllib%E6%A8%A1%E6%8B%9F%E6%B8%B8%E8%A7%88%E5%99%A8/","excerpt":"","text":"代码实现如下： import urllib.requestimport randomurl = ‘http://www.baidu.com&#39; 方法1，模拟请求头,字典常见请求头https://blog.csdn.net/mouday/article/details/80182397 https://www.cnblogs.com/zrmw/p/9332801.htmlheaders = { ‘Accept’:’application/json,application/javascript,/;q=0.01’, ‘X-Requested-With’:’XMLHttpRequest’, ‘User-Agent’:’Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36’, ‘Content-Type’:’application/x-www-form-urlencoded;charset=utf-8’} 设置一个请求体req = urllib.request.Request(url,headers=headers) 发起请求response = urllib.request.urlopen(req)data = response.read().decode(‘utf-8’) print(type(data)) # &lt;class ‘str’&gt;print(data) # 打印出来的就是百度首页的内容方法2agentList = [ “Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50”, “Mozilla/5.0 (Windows; U; Windows NT 6.1; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50”, “Mozilla/5.0 (Windows NT 10.0; WOW64; rv:38.0) Gecko/20100101 Firefox/38.0”, ]agentStr = random.choice(agentList) # 随机拿一个 print(agentStr)req = urllib.request.Request(url)req.add_header(‘User-Agent’,agentStr) # 逗号，不是冒号response = urllib.request.urlopen(req)data = response.read().decode(‘utf-8’)print(type(data))print(data)","categories":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}],"tags":[],"keywords":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}]},{"title":"Python乱码解码为中文","slug":"categories/Python/Python上公交车并且可以有座位坐下","date":"2021-06-17T11:26:42.000Z","updated":"2021-09-03T07:10:47.976Z","comments":true,"path":"2021/06/17/categories/Python/Python上公交车并且可以有座位坐下/","link":"","permalink":"https://visen123.github.io/2021/06/17/categories/Python/Python%E4%B8%8A%E5%85%AC%E4%BA%A4%E8%BD%A6%E5%B9%B6%E4%B8%94%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%BA%A7%E4%BD%8D%E5%9D%90%E4%B8%8B/","excerpt":"","text":"情节描述：上公交车，并且可以有座位坐下 业务逻辑：输入公交卡当前的余额，只要不低于2元，就可以上公交车；如果车上有空座位，就可以坐下 代码实现如下：while True: CardCash = int(input(‘请输入您的公交卡余额：’)) if CardCash &gt;= 2: print(‘余额足够，您可以上车了’) IsSeat = input(‘车上是否有空座位(有/没有)？’) if IsSeat == ‘有’: print(‘您可以坐下’) else: print(‘没有座位，只能站着’) else: print(‘余额不够，您不能上车’)","categories":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}],"tags":[],"keywords":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}]},{"title":"Python画爱心","slug":"categories/Python/Python画爱心","date":"2021-06-16T11:26:42.000Z","updated":"2021-09-03T07:30:23.516Z","comments":true,"path":"2021/06/16/categories/Python/Python画爱心/","link":"","permalink":"https://visen123.github.io/2021/06/16/categories/Python/Python%E7%94%BB%E7%88%B1%E5%BF%83/","excerpt":"","text":"python 编程画爱心代码实现如下： import time words = input(&#39;Please input the words you want to say!:&#39;) # 例子：words = &quot;Dear lili, Happy Valentine&#39;s Day! Lyon Will Always Love You Till The End! ♥ Forever! ♥&quot; for item in words.split(): # 要想实现打印出字符间的空格效果，此处添加：item = item+&#39; &#39; letterlist = [] # letterlist是所有打印字符的总list，里面包含y条子列表list_X for y in range(12, -12, -1): list_X = [] # list_X是X轴上的打印字符列表，里面装着一个String类的letters letters = &#39;&#39; # letters即为list_X内的字符串，实际是本行要打印的所有字符 for x in range(-40, 40): # *是乘法，**是幂次方 expression = ((x*0.04)**2+(y*0.1)**2-1)**3-(x*0.04)**2*(y*0.1)**3 if expression &lt;= 0: letters += item[(x-y) % len(item)] else: letters += &#39; &#39; list_X.append(letters) letterlist += list_X print(&#39;\\n&#39;.join(letterlist)) time.sleep(1.5) 执行打印爱心结果如下所示： ♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥ ♥","categories":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}],"tags":[],"keywords":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}]},{"title":"Python乱码解码为中文","slug":"categories/Python/乱码解码为中文","date":"2021-06-13T11:26:42.000Z","updated":"2021-09-03T07:02:16.178Z","comments":true,"path":"2021/06/13/categories/Python/乱码解码为中文/","link":"","permalink":"https://visen123.github.io/2021/06/13/categories/Python/%E4%B9%B1%E7%A0%81%E8%A7%A3%E7%A0%81%E4%B8%BA%E4%B8%AD%E6%96%87/","excerpt":"","text":"requests.get(url,headers = headers).text解码为中文今天在使用python3爬虫时，遇到一个关于字符编码的问题，经过网上查找，终于解决了问题，下面记录下来。 1,用requests.get(url)爬取的到数据，中文显示则是乱码，如： æä¾çåå®¹ä»ç¨äºå­¦ä¹ ï¼æµè¯åå¹è®­ãå®ä¾å¯è½ä¸ºäºæ´å®¹æçè§£èç®åãæä»¬ä¸ç´å¯¹æç¨ï¼åèæåï¼å¨çº¿å®ä¾ä¿æä¿®è®¢ï¼ä½æ¯æä»¬ä¸è½ä¿è¯ææåå®¹å¨é¨æ­£ç¡®ãéè¿ä½¿ç¨æ¬ç«è¿è¡å­¦ä¹ éä¹èæ¥çé£é©ä¸æ¬ç«æ å³ãå½ä½¿ç¨æ¬ç«æ¶ï¼ä»£è¡¨æ¨å·²æ¥åäºæ¬ç«çä½¿ç¨æ¡æ¬¾åé，那么，使用content.encode(‘raw_unicode_escape’).decode()就可以用print查看汉字了。 import requestsurl = ‘http://www.python-china.com/&#39;headers = { ‘User-Agent’: ‘Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36’ }contents = requests.get(url,headers = headers).textcn_contents = contents.encode(‘raw_unicode_escape’).decode()print(cn_contents) # 输出了正常的中文文字2,爬到的数据通常是bytes类型，如requests.get的content属性。这时候，我们使用str(content, ‘utf8’)就可以把\\xb7\\xaf\\xe5\\xb8\\xa6\\xe9\\xa3\\x8e这样的内容转化成汉字了。","categories":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}],"tags":[],"keywords":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}]},{"title":"Python例子-图片验证码","slug":"categories/Python/Python例子图片验证码","date":"2021-06-12T12:26:42.000Z","updated":"2021-09-03T07:07:22.830Z","comments":true,"path":"2021/06/12/categories/Python/Python例子图片验证码/","link":"","permalink":"https://visen123.github.io/2021/06/12/categories/Python/Python%E4%BE%8B%E5%AD%90%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81/","excerpt":"","text":"代码实现如下：class ImageCodeView(View): def get(self,request): im = Image.new(&#39;RGB&#39;, (125, 50)) # 图片大小 draw = ImageDraw.Draw(im) font = ImageFont.truetype(settings.BASE_DIR+&#39;/html/static/simhei.ttf&#39;, 55) # 字体位置，字体大小 def random_color1(): &quot;&quot;&quot;随机颜色1（用于填充字体）&quot;&quot;&quot; return random.randint(10, 80), random.randint(10, 80), random.randint(10, 80) def random_color2(): &quot;&quot;&quot;随即颜色2（用于填充背景）&quot;&quot;&quot; return random.randint(100, 255), random.randint(100, 255), random.randint(100, 255) for x in range(125): for y in range(50): draw.point((x, y), fill=random_color2()) # 对每个像素点进行填充 draw.text((10, -2), &#39;ABCD&#39;, font=font,fill=random_color1()) # 10左偏移位置，0上偏移位置 out = BytesIO() im.save(out, format=&#39;png&#39;) # 保存为PNG图片 # out.getvalue()图片的二进制，返回前端游览器 return HttpResponse(out.getvalue(),content_type=&#39;image/png&#39;)","categories":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}],"tags":[],"keywords":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}]},{"title":"Python例子-读取远程页面并写入本地页面","slug":"categories/Python/Python读取远程页面并写入本地页面","date":"2021-06-06T06:26:42.000Z","updated":"2021-09-03T14:44:23.471Z","comments":true,"path":"2021/06/06/categories/Python/Python读取远程页面并写入本地页面/","link":"","permalink":"https://visen123.github.io/2021/06/06/categories/Python/Python%E8%AF%BB%E5%8F%96%E8%BF%9C%E7%A8%8B%E9%A1%B5%E9%9D%A2%E5%B9%B6%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E9%A1%B5%E9%9D%A2/","excerpt":"","text":"import urllib.requestresponse = urllib.request.urlopen(‘http://www.baidu.com&#39;)‘’’ 方法1 读取文件的全部内容，把读取到的数据赋值给一个字符串变量data = response.read() print(type(data)) # &lt;class ‘bytes’&gt;print(data)with open(‘baidu.html’,’wb’) as f: f.write(data)‘’’ 读取文件的全部内容，每行的内容作为列表的一个元素方法2data = response.readlines() #if response.getcode() == 200 or response.getcode() == 304: # 判断是否请求成功 # print(type(data)) # &lt;class ‘list’&gt; # print(type(data[100])) # &lt;class ‘bytes’&gt; 列表每个元素的类型 # print(data) # print(len(data)) with open(‘baidu.html’,’wb’) as f: for con in data: f.write(con)else: print(‘请求失败’) 方法3，一句话就搞定了urllib.request.urlretrieve(‘http://www.baidu.com&#39;,filename=&#39;file2.html&#39;)","categories":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}],"tags":[],"keywords":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}]},{"title":"微信小程序开发工具常用快捷键","slug":"categories/小程序/微信小程序开发常用快捷键","date":"2021-05-18T07:16:42.000Z","updated":"2021-09-03T15:14:26.743Z","comments":true,"path":"2021/05/18/categories/小程序/微信小程序开发常用快捷键/","link":"","permalink":"https://visen123.github.io/2021/05/18/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"格式调整 Ctrl+S：保存文件 Ctrl+[， Ctrl+]：代码行缩进 Ctrl+Shift+[， Ctrl+Shift+]：折叠打开代码块 Ctrl+C Ctrl+V：复制粘贴，如果没有选中任何文字则复制粘贴一行 Shift+Alt+F：代码格式化 Alt+Up，Alt+Down：上下移动一行 Shift+Alt+Up，Shift+Alt+Down：向上向下复制一行 Ctrl+Shift+Enter：在当前行上方插入一行 光标相关 Ctrl+End：移动到文件结尾 Ctrl+Home：移动到文件开头 Ctrl+i：选中当前行 Shift+End：选择从光标到行尾 Shift+Home：选择从行首到光标处 Ctrl+Shift+L：选中所有匹配 Ctrl+D：选中匹配 Ctrl+U：光标回退","categories":[{"name":"小程序","slug":"小程序","permalink":"https://visen123.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[],"keywords":[{"name":"小程序","slug":"小程序","permalink":"https://visen123.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"导航栏navigation-bar","slug":"categories/小程序/导航栏navigation-bar","date":"2021-05-17T07:26:42.000Z","updated":"2021-09-03T15:07:37.804Z","comments":true,"path":"2021/05/17/categories/小程序/导航栏navigation-bar/","link":"","permalink":"https://visen123.github.io/2021/05/17/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%AF%BC%E8%88%AA%E6%A0%8Fnavigation-bar/","excerpt":"","text":"navigation-bar基础库 2.9.0 开始支持，低版本需做兼容处理。 页面导航条配置节点，用于指定导航栏的一些属性。只能是 page-meta 组件内的第一个节点，需要配合它一同使用。 通过这个节点可以获得类似于调用 wx.setNavigationBarTitle wx.setNavigationBarColor 等接口调用的效果。 属性 类型 默认值 必填 说明 最低版本title string 否 导航条标题 2.9.0loading boolean false 否 是否在导航条显示 loading 加载提示 2.9.0front-color string 否 导航条前景颜色值，包括按钮、标题、状态栏的颜色，仅支持 #ffffff 和 #000000 2.9.0background-color string 否 导航条背景颜色值，有效值为十六进制颜色 2.9.0color-animation-duration number 0 否 改变导航栏颜色时的动画时长，默认为 0 （即没有动画效果） 2.9.0color-animation-timing-func string “linear” 否 改变导航栏颜色时的动画方式，支持 linear 、 easeIn 、 easeOut 和 easeInOut 2.9.0示例代码 Page({ data: { nbFrontColor: ‘#000000’, nbBackgroundColor: ‘#ffffff’, }, onLoad() { this.setData({ nbTitle: ‘新标题’, nbLoading: true, nbFrontColor: ‘#ffffff’, nbBackgroundColor: ‘#000000’, }) }})","categories":[{"name":"小程序","slug":"小程序","permalink":"https://visen123.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[],"keywords":[{"name":"小程序","slug":"小程序","permalink":"https://visen123.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"媒体组件image","slug":"categories/小程序/媒体组件image","date":"2021-05-15T09:26:42.000Z","updated":"2021-09-03T15:07:13.167Z","comments":true,"path":"2021/05/15/categories/小程序/媒体组件image/","link":"","permalink":"https://visen123.github.io/2021/05/15/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%AA%92%E4%BD%93%E7%BB%84%E4%BB%B6image/","excerpt":"","text":"image基础库 1.0.0 开始支持，低版本需做兼容处理。 图片。支持 JPG、PNG、SVG、WEBP、GIF 等格式，2.3.0 起支持云文件ID。 属性 类型 默认值 必填 说明 最低版本src string 否 图片资源地址 1.0.0mode string scaleToFill 否 图片裁剪、缩放的模式 1.0.0webp boolean false 否 默认不解析 webP 格式，只支持网络资源 2.9.0lazy-load boolean false 否 图片懒加载，在即将进入一定范围（上下三屏）时才开始加载 1.5.0show-menu-by-longpress boolean false 否 长按图片显示发送给朋友、收藏、保存图片、搜一搜、打开名片/前往群聊/打开小程序（若图片中包含对应二维码或小程序码）的菜单 2.7.0binderror eventhandle 否 当错误发生时触发，event.detail = {errMsg} 1.0.0bindload eventhandle 否 当图片载入完毕时触发，event.detail = {height, width} 1.0.0mode 的合法值 值 说明 最低版本scaleToFill 缩放模式，不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素aspectFit 缩放模式，保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。aspectFill 缩放模式，保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方向是完整的，另一个方向将会发生截取。widthFix 缩放模式，宽度不变，高度自动变化，保持原图宽高比不变heightFix 缩放模式，高度不变，宽度自动变化，保持原图宽高比不变 2.10.3top 裁剪模式，不缩放图片，只显示图片的顶部区域bottom 裁剪模式，不缩放图片，只显示图片的底部区域center 裁剪模式，不缩放图片，只显示图片的中间区域left 裁剪模式，不缩放图片，只显示图片的左边区域right 裁剪模式，不缩放图片，只显示图片的右边区域top left 裁剪模式，不缩放图片，只显示图片的左上边区域top right 裁剪模式，不缩放图片，只显示图片的右上边区域bottom left 裁剪模式，不缩放图片，只显示图片的左下边区域bottom right 裁剪模式，不缩放图片，只显示图片的右下边区域Bug &amp; Tiptip：image组件默认宽度320px、高度240pxtip：image组件中二维码/小程序码图片不支持长按识别。仅在wx.previewImage中支持长按识别","categories":[{"name":"小程序","slug":"小程序","permalink":"https://visen123.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[],"keywords":[{"name":"小程序","slug":"小程序","permalink":"https://visen123.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"视图容器cover-view","slug":"categories/小程序/视图容器cover-view","date":"2021-05-14T07:32:42.000Z","updated":"2021-09-03T15:03:09.884Z","comments":true,"path":"2021/05/14/categories/小程序/视图容器cover-view/","link":"","permalink":"https://visen123.github.io/2021/05/14/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E8%A7%86%E5%9B%BE%E5%AE%B9%E5%99%A8cover-view/","excerpt":"","text":"cover-view基础库 1.4.0 开始支持，低版本需做兼容处理。 覆盖在原生组件之上的文本视图。 目前原生组件均已支持同层渲染，建议使用 view 替代。可覆盖的原生组件包括 map、video、canvas、camera、live-player、live-pusher 只支持嵌套 cover-view、cover-image，可在 cover-view 中使用 button。组件属性的长度单位默认为px，2.4.0起支持传入单位(rpx/px)。 属性 类型 默认值 必填 说明 最低版本scroll-top number/string 否 设置顶部滚动偏移量，仅在设置了 overflow-y: scroll 成为滚动元素后生效 2.1.0Bug &amp; Tiptip: cover-view和cover-image的aria-role仅可设置为button，读屏模式下才可以点击，并朗读出“按钮”；为空时可以聚焦，但不可点击tip: 基础库 2.2.4 起支持 touch 相关事件，也可使用 hover-class 设置点击态tip: 基础库 2.1.0 起支持设置 scale rotate 的 css 样式，包括 transition 动画tip: 基础库 1.9.90 起 cover-view 支持 overflow: scroll，但不支持动态更新 overflowtip: 基础库 1.9.90 起最外层 cover-view 支持 position: fixedtip: 基础库 1.9.0 起支持插在 view 等标签下。在此之前只可嵌套在原生组件map、video、canvas、camera内，避免嵌套在其他组件内。tip: 基础库 1.6.0 起支持css transition动画，transition-property只支持transform (translateX, translateY)与opacity。tip: 基础库 1.6.0 起支持css opacity。tip: 事件模型遵循冒泡模型，但不会冒泡到原生组件。tip: 文本建议都套上cover-view标签，避免排版错误。tip: 只支持基本的定位、布局、文本样式。不支持设置单边的border、background-image、shadow、overflow: visible等。tip: 建议子节点不要溢出父节点tip: 支持使用 z-index 控制层级tip: 默认设置的样式有：white-space: nowrap; line-height: 1.2; display: block;bug: 自定义组件嵌套 cover-view 时，自定义组件的 slot 及其父节点暂不支持通过 wx:if 控制显隐，否则会导致 cover-view 不显示","categories":[{"name":"小程序","slug":"小程序","permalink":"https://visen123.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[],"keywords":[{"name":"小程序","slug":"小程序","permalink":"https://visen123.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"微信小程序项目设置","slug":"categories/小程序/微信小程序项目设置","date":"2021-05-10T02:00:16.000Z","updated":"2021-09-03T15:02:36.525Z","comments":true,"path":"2021/05/10/categories/小程序/微信小程序项目设置/","link":"","permalink":"https://visen123.github.io/2021/05/10/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"项目页卡主要有三大功能基本信息包括图标、AppID、第三方平台名（只有第三方平台的开发小程序才会显示）、目录信息、上次提交代码的时间以及代码包大小。 基础库版本切换开发者可以在此选择任意基础库版本，用于开发和调试旧版本兼容问题。 clientlib 显示基础库支持的客户端版本工具1.02.2002252或以上版本，开发者可以在此查看任意基础库支持的微信客户端版本范围 clientlibversion 显示灰度中的基础库正式版本的基础库全量发布前，会有一个灰度的过程。 工具1.02.2002252或以上版本，开发者可以在此查看正在灰度中的基础库版本 canaryclientlib 下发测试基础库注意：该功能只能下发到登录开发者工具的微信号的客户端，并会影响到该客户端所有小程序 工具1.02.2003112或以上版本，开发者可以在此选择任意基础库版本并下发到客户端 pushcommonlib 微信客户端对开发版小程序打开调试，可以查看下发测试基础库的生效时间以及版本 pushcommonlibtime pushcommonlibversion 本地设置上传代码时样式自动补全在预览、真机调试、上传时使用 autoprefixer 对 wxss 文件中的样式类自动补全前缀，以对不同的浏览器内核的真机做样式兼容性适配 autoprefixer 的 browsers 参数为 [ ‘iOS &gt;= 8’, ‘Chrome &gt;= 37’, ]，勾选此项会增大代码包体积。 上传代码时自动压缩样式在预览、真机调试、上传时使用 cssnano 对 wxss 文件进行压缩 上传代码时自动压缩混淆在预览、真机调试、上传时使用 UglifyJS 或者 Terser 对 js 文件进行压缩混淆 上传时进行代码保护开启此选项，开发者工具会尝试对项目代码进行保护，主要是对文件进行扁平化处理并替换 require 引用的文件名，以下情况不适合使用此功能 对于小程序只有简单页面的情况下，开启此功能效果不佳有文件超过 500kb，且其中有使用 require 引用项目中的文件的情况，在运行时可能会报文件没有找到动态引用的情况，如 var a = ‘somefile.js’; require(a);将 require 函数赋值给其他变量的情况，如 var a = require; a(‘somefile.js’);将 require 作为二元运算符的参数的情况，如 require + 1;使用 … 运算符且未开启 ES6 转 ES5 的情况自动运行体验评分开启后，模拟器运行时，调试器-Audit 面板将自动运行体验评分检测 auto audit 不校验合法域名、web-view(业务域名)、TLS 版本以及 HTTPS 证书正式发布的小程序的网络请求是需要校验网络请求（wx.request, wx.connectSocket、wx.downloadFile, wx.uploadFile）、 组件允许加载的业务域名是否已经配置成为合法域名，以及域名的 TLS 版本、HTTPS 证书有效性， 其中服务器域名和 业务域名可以在 mp 管理后台 开发-开发管理-开发设置 中进行配置。 在开发过程中可以开启此选项，开发工具将不会校验安全域名、 业务域名，以及 TLS 版本、HTTPS 证书，帮助在开发过程中更方便的完成调试工作。 启用数据预拉取开启后模拟器每次编译都会先同步预拉取数据，详见数据预拉取 启用代码自动热重载开启后，修改代码文件，模拟器可以在不刷新的情况下生效变更。 进入热重载模式后，会在模拟器区域有个显示的提示，该功能在 2.12.0 及以上的基础库生效 注意: App.onLaunch 因没有触发场景无法生效热重载，需要重新点击编译；Page.onLoad 需要重新进入页面热重载的变更才能生效 启用多核心编译开启后开发者工具将使用 node cluster 多核能力进行本地代码编译， 注意：对于双核四线程 CPU 的机器不建议开启该功能 启用自定义处理命令开启后，工具在编译前、预览前、上传前这三个时机调用开发者自定义的命令， 开发者可以去对代码进行一些预处理或者上报的逻辑 项目设置域名信息将显示小程序的安全域名信息，合法域名可在 mp 管理后台 开发-开发管理-开发设置 中进行设置。 host 高级设置将显示小程序代码包允许的大小等其他配置信息","categories":[{"name":"小程序","slug":"小程序","permalink":"https://visen123.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[],"keywords":[{"name":"小程序","slug":"小程序","permalink":"https://visen123.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"微信小程序开发工具下载安装","slug":"categories/小程序/微信小程序开发工具下载安装","date":"2021-05-06T11:26:42.000Z","updated":"2021-09-03T15:02:36.553Z","comments":true,"path":"2021/05/06/categories/小程序/微信小程序开发工具下载安装/","link":"","permalink":"https://visen123.github.io/2021/05/06/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85/","excerpt":"","text":"微信小程序开发工具下载地址如下：https://developers.weixin.qq.com/miniprogram/dev/devtools/stable.html 界面启动页 https://developers.weixin.qq.com/miniprogram/dev/devtools/page.html#独立窗口 登录页在登录页，可以使用微信扫码登录开发者工具，开发者工具将使用这个微信帐号的信息进行小程序的开发和调试。 登录 项目列表登录成功后，会看到已经存在的项目列表和代码片段列表， 在项目列表可以选择公众号网页调试，进入到公众号网页调试模式 项目列表 新建项目当符合以下条件时，可以在本地创建一个小程序项目 需要一个小程序的 AppID；如没有 AppID，可以选择申请使用测试号。登录的微信号需要是该 AppID 的开发者；需要选择一个空目录，或者选择的非空目录下存在 app.json 或者 project.config.json。当选择空目录时，可以选择是否在该目录下生成一个简单的项目。新建项目 多开项目工具支持同时打开多个项目，每次打开项目时会从新窗口打开，入口有以下几种： 从项目选择页打开项目，处于项目窗口时可以从菜单栏的项目 -&gt; 查看所有项目打开项目选择页从菜单栏的最近打开项目列表中打开的项目会从新窗口打开新建项目命令行或 HTTP 调用工具打开项目管理项目对本地项目进行删除和批量删除 管理项目 主界面开发者工具主界面，从上到下，从左到右，分别为：菜单栏、工具栏、模拟器、目录树、编辑区、调试器 六大部分。 菜单栏微信web开发者工具 切换帐号：快速切换登录用户 关于：关于开发者工具 检查更新：检查版本更新 开发者论坛：前往开发者论坛 开发者文档：前往开发者文档 调试：调试开发者工具、调试编辑器；如果遇到疑似开发者工具或者编辑器的 bug，可以打开调试工具查看是否有出错日志，欢迎在论坛上反馈相关问题 更换开发模式：快速切换公众号网页调试和小程序调试 退出：退出开发者工具 项目 新建项目：快速新建项目 打开最近：可以查看最近打开的项目列表，并选择是否进入对应项目 查看所有项目：新窗口打开启动页的项目列表页 关闭当前项目：关闭当前项目，回到启动页的项目列表页 文件 新建文件 保存 保存所有 关闭文件 编辑：可以查看编辑相关的操作和快捷键 工具 编译：编译当前小程序项目 刷新：与编译的功能一致，由于历史原因保留对应的快捷键 ctrl(⌘) + R 编译配置：可以选择普通编译或自定义编译条件 前后台切换：模拟客户端小程序进入后台运行和返回前台的操作 清除缓存：清除文件缓存、数据缓存、以及授权数据 界面：控制主界面窗口模块的显示与隐藏 设置： 外观设置：控制编辑器的配色主题、字体、字号、行距 编辑设置：控制文件保存的行为，编辑器的表现 代理设置：选择直连网络、系统代理和手动设置代理 通知设置：设置是否接受某种类型的通知 工具栏点击用户头像可以打开个人中心，在这里可以便捷的切换用户和查看开发者工具收到的消息。 用户头像右侧是控制主界面模块显示/隐藏的按钮。至少需要有一个模块显示。 工具栏中间，可以选择普通编译，也可以新建并选择自定义条件进行编译和预览。 通过切后台按钮，可以模拟小程序进入后台的情况 工具栏上提供了清缓存的快速入口。可以便捷的清除工具上的文件缓存、数据缓存、还有后台的授权数据，方便开发者调试。 工具栏右侧是开发辅助功能的区域，在这里可以上传代码、版本管理、查看项目详情 工具栏管理在工具栏上点击鼠标右键，可以打开工具栏管理 模拟器模拟器可以模拟小程序在微信客户端的表现。小程序的代码通过编译后可以在模拟器上直接运行。 开发者可以选择不同的设备，也可以添加自定义设备来调试小程序在不同尺寸机型上的适配问题。 在模拟器底部的状态栏，可以直观地看到当前运行小程序的场景值，页面路径及页面参数 独立窗口点击 模拟器/调试器 右上角的按钮可以使用独立窗口显示 模拟器/调试器","categories":[{"name":"小程序","slug":"小程序","permalink":"https://visen123.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[],"keywords":[{"name":"小程序","slug":"小程序","permalink":"https://visen123.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"Java后端开发常用的一些开源工具包","slug":"categories/工具/Java后端开发常用的一些开源工具包","date":"2021-04-28T07:26:42.000Z","updated":"2021-09-07T13:59:16.116Z","comments":true,"path":"2021/04/28/categories/工具/Java后端开发常用的一些开源工具包/","link":"","permalink":"https://visen123.github.io/2021/04/28/categories/%E5%B7%A5%E5%85%B7/Java%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7%E5%8C%85/","excerpt":"","text":"Redis（Remote Dictionary Server )，是一个内存数据库，可持久存储在磁盘上。 数据模型是键值，但支持许多不同类型的值：字符串，列表，集合，排序集合，哈希。 用于数据缓存（比如用于验证短信验证存储），主要用于处理大量数据的高访问负载。异常快 - Redis非常快，每秒可执行大约110000次的设置(SET)操作，每秒大约可执行81000次的读取/获取(GET)操作。支持丰富的数据类型 - Redis支持开发人员常用的大多数数据类型，例如列表，集合，排序集和散列等等。可用于多种用例，如：缓存，消息队列(Redis本地支持发布/订阅)，应用程序中的任何短期数据，例如，web应用程序中的会话，网页命中计数等。启动命令：redis-server.exe redis.windows.conf Minio Server：对象存储服务器，用于存储非结构化数据。对于中小型企业，不存储到云（比如阿里云OSS），可以创建bucket，上传文件。 Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。 *Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的机器上，也可以实现虚拟化。 Elasticsearch是一个基于Lucene的搜索引擎。它提供了一个开源、分布式多用户能力的全文搜索引擎。 RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。 微服务：一种软件开发技术—— 面向服务的体系结构（SOA）架构样式的一种变体，将应用程序构造为一组松散耦合的服务。 AXURE RP9:原型设计，用于设计人员和开发人员交接。 项目搭建步骤： 功能需求-&gt;原型构建-&gt;建表-&gt;根据前端需要展现的功能进行接口编写 Spring+Mybatis-plus搭建骨架：Mybaitis-plus（MyBatis升级版），可以直接生成实体类等代码。","categories":[{"name":"工具","slug":"工具","permalink":"https://visen123.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[],"keywords":[{"name":"工具","slug":"工具","permalink":"https://visen123.github.io/categories/%E5%B7%A5%E5%85%B7/"}]},{"title":"Android机子屏幕适配最简单最全面方案","slug":"categories/Android/Android机子屏幕适配最简单最全面方案","date":"2020-08-25T06:38:49.000Z","updated":"2021-09-01T04:22:01.484Z","comments":true,"path":"2020/08/25/categories/Android/Android机子屏幕适配最简单最全面方案/","link":"","permalink":"https://visen123.github.io/2020/08/25/categories/Android/Android%E6%9C%BA%E5%AD%90%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E6%9C%80%E7%AE%80%E5%8D%95%E6%9C%80%E5%85%A8%E9%9D%A2%E6%96%B9%E6%A1%88/","excerpt":"","text":"调试布局会发现，每款手机显示的布局效果有时候不尽人意，这是因为我们在写代码时，只针对了调试机型屏幕做了设计，而没有考虑到每个手机适配的问题，虽然大家都知道使用dp，但是并没能完全解决问题，而且在美工小伙伴也不会设计dp的图出来给你作为参考。今天就给大家介绍一款适配，来自鸿洋大神之手的工具AutoLayout：https://github.com/hongyangAndroid/AndroidAutoLayout 相信很多同学是知道这个库的，就是不知道怎么使用，什么导入module，什么注明之类的，今天写给大家的方法，绝对最简单，最方便！ 在build.gradle添加依赖 compile ‘com.zhy:autolayout:1.4.5’ 在AndroidManifest清单文件中注明你要设计的初始屏幕尺寸 也就是在你的项目的中注明你的设计稿（美工给你的）的尺寸。 最后使用让你的Activity继承AutoLayoutActivity 现在你就可以安心的使用UI设计图了！可以在布局中直接写px，而不用再担心去换算dp的问题了！","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"分享Android短视频制作","slug":"categories/Android/分享Android短视频制作","date":"2020-08-21T08:38:34.000Z","updated":"2020-08-22T16:01:31.628Z","comments":true,"path":"2020/08/21/categories/Android/分享Android短视频制作/","link":"","permalink":"https://visen123.github.io/2020/08/21/categories/Android/%E5%88%86%E4%BA%ABAndroid%E7%9F%AD%E8%A7%86%E9%A2%91%E5%88%B6%E4%BD%9C/","excerpt":"","text":"如何制作短视频APP，具体做法如下介绍： 准备材料并配置项目工程： 1、去下载七牛云播放器SDK 2、然后把pldroid-player-2.1.6.jar包拷贝到你项目lib文件里，详情如下图所示： 3、把整个jniLibs文件夹里面的所有内容都拷贝到你项目src/main/里，详情如下图所示： 4、然后在你项目build.gradle进行关联 android { sourceSets { main { jniLibs.srcDirs = [‘src/main/jniLibs’] } } } dependencies { implementation files(‘libs/pldroid-player-2.1.6.jar’) implementation ‘com.bugsnag:bugsnag-android-ndk:1.1.2’ implementation ‘com.android.support:appcompat-v7:27.1.0’ implementation ‘com.journeyapps:zxing-android-embedded:3.0.2@aar’ implementation ‘com.google.zxing:core:3.2.0’ } 5、然后在你项目xml布局里添加如下代码，PLVideoView控件： 6、最后去在你Activity里找到这个控件并配置播放器代码： mVideoView = findViewById(R.id.VideoView);AVOptionsoptions = newAVOptions(); options.setInteger(AVOptions.KEY_PREPARE_TIMEOUT,10*1000); options.setInteger(AVOptions.KEY_MEDIACODEC,AVOptions.MEDIA_CODEC_SW_DECODE); options.setInteger(AVOptions.KEY_LIVE_STREAMING,1); options.setInteger(AVOptions.KEY_LOG_LEVEL,0); mVideoView.setAVOptions(options);// Set some listenersmVideoView.setOnInfoListener(mOnInfoListener); mVideoView.setOnVideoSizeChangedListener(mOnVideoSizeChangedListener); mVideoView.setOnBufferingUpdateListener(mOnBufferingUpdateListener); mVideoView.setOnCompletionListener(mOnCompletionListener); mVideoView.setOnErrorListener(mOnErrorListener); mVideoView.setOnVideoFrameListener(mOnVideoFrameListener); mVideoView.setOnAudioFrameListener(mOnAudioFrameListener); mVideoView.setVideoPath(videoPath); mVideoView.setDisplayAspectRatio(mDisplayAspectRatio); mVideoView.setLooping(true);// You can also use a custom MediaController widgetmMediaController = new MediaController(this, !mIsLiveStreaming, mIsLiveStreaming); mMediaController.setOnClickSpeedAdjustListener(mOnClickSpeedAdjustListener); mVideoView.setMediaController(mMediaController); 最后展示一下效果： 最后附上代码下载地址：https://github.com/Visen123/ShortVideo如果觉得使用方便，请给我的github 点个赞，谢谢！","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"Android 高效的SQLite型数据库greenDAO使用","slug":"categories/Android/Android-高效的SQLite型数据库greenDAO使用","date":"2020-08-20T13:30:04.000Z","updated":"2020-08-21T07:10:18.174Z","comments":true,"path":"2020/08/20/categories/Android/Android-高效的SQLite型数据库greenDAO使用/","link":"","permalink":"https://visen123.github.io/2020/08/20/categories/Android/Android-%E9%AB%98%E6%95%88%E7%9A%84SQLite%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93greenDAO%E4%BD%BF%E7%94%A8/","excerpt":"","text":"使用：在你project项目的build.gradle配置如下：buildscript {repositories {mavenCentral()}dependencies {classpath ‘org.greenrobot:greendao-gradle-plugin:3.2.2’}} // 使用数据库升级辅助GreenDaoUpgradeHelper时添加allprojects {repositories {maven { url “https://jitpack.io&quot; }}} 在你的modules 里app/build.gradle里配置如下： apply plugin: ‘org.greenrobot.greendao’ dependencies {compile ‘org.greenrobot:greendao:3.2.2’ // 使用数据库加密时添加compile ‘net.zetetic:android-database-sqlcipher:3.5.6’ // 使用数据库升级辅助GreenDaoUpgradeHelper时添加compile ‘com.github.yuweiguocn:GreenDaoUpgradeHelper:v2.0.1’ } greendao {schemaVersion 1daoPackage ‘com.greendao.dbtargetGenDir ‘src/main/java’} 首先，新建datamodel包，用以包含DaoMaster、DaoSession、bean和beanDao等。br/&gt; 然后新建Area实体类，代码如下： @Entitypublic class Area {br/&gt;@Idprivate String AreaCode;private String AreaName;} 最后，Build-&gt;Make Module ‘app’，即可自动生成DaoMaster、DaoSession、Area和AreaDao。此时Area实体类的代码如下：br/&gt;@Entitypublic class Area {br/&gt;@Idprivate String AreaCode;private String AreaName;@Generated(hash = 262290694)public Area(String AreaCode, String AreaName) {this.AreaCode = AreaCode;this.AreaName = AreaName;}@Generated(hash = 179626505)public Area() {}public String getAreaCode() {return this.AreaCode;}public void setAreaCode(String AreaCode) {this.AreaCode = AreaCode;}public String getAreaName() {return this.AreaName;}public void setAreaName(String AreaName) {this.AreaName = AreaName;}} 添加其他实体类的方法与Area一样。需要注意的是，不要手动修改DaoMaster、DaoSession、bean和beanDao的代码，因为每一次编译项目，都会重新生成一次DaoMaster、DaoSession、bean和beanDao。如果修改的话，就会被覆盖掉。 为了便于数据的读取和添加，新建GreenDaoHelper辅助类，代码如下：public class GreenDaoHelper extends Application {private GreenDaoHelper Instance;private static DaoMaster daoMaster;private static DaoSession daoSession; public GreenDaoHelper getInstance() { if (Instance == null) { Instance = this; } return Instance;} /** 获取DaoMaster @param context @return /public static DaoMaster getDaoMaster(Context context) { if (daoMaster == null) { try&#123; DaoMaster.OpenHelper helper = new DaoMaster.DevOpenHelper(context,&quot;test.db&quot;,null); daoMaster = new DaoMaster(helper.getWritableDatabase()); //获取未加密的数据库 &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; } return daoMaster;} /** 获取DaoSession对象 @param context @return /public static DaoSession getDaoSession(Context context) { if (daoSession == null) { if (daoMaster == null) &#123; getDaoMaster(context); &#125; daoSession = daoMaster.newSession(); } return daoSession;} } 在读写数据库之前，要添加读写权限： 在MainActivity.java中添加读写代码：public class MainActivity extends AppCompatActivity { private TextView textview;private DaoSession session; @Overrideprotected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textview=(TextView)findViewById(R.id.textview); session = GreenDaoHelper.getDaoSession(this); session.getAreaDao().deleteAll();//清空所有记录 //添加记录 Area area = new Area(&quot;01&quot;,&quot;北京&quot;); Area area1 = new Area(&quot;02&quot;,&quot;天津&quot;); session.getAreaDao().insert(area); session.getAreaDao().insert(area1); //查询记录 StringBuilder stringBuilder = new StringBuilder(); List&lt;Area&gt; areas = session.getAreaDao().loadAll(); for (int i = 0,n = areas.size();i&lt;n;++i)&#123; stringBuilder.append(&quot;地区编码：&quot;).append(areas.get(i).getAreaCode()) .append(&quot;，地区名称：&quot;).append(areas.get(i).getAreaName()).append(&quot;\\n&quot;); &#125; textview.setText(stringBuilder); } } 运行结果如下图所示： 修改数据库文件路径： 默认情况下，新创建的数据存储在data的包名目录下，设备如果不root的话，是无法查看SQLite数据库文件的。而实际应用中，我们往往需要copy数据库，或借用第三方工具查阅或编辑数据库内容。此时我们可以通过重写Context的getDatabasePath(String name)、openOrCreateDatabase(String name, int mode, CursorFactory factory)、openOrCreateDatabase(String name, int mode, CursorFactory factory, DatabaseErrorHandler errorHandler)等三个方法来修改SQLite文件的存储路径。 public class GreenDaoHelper extends Application {private GreenDaoHelper Instance;private static DaoMaster daoMaster;private static DaoSession daoSession; public GreenDaoHelper getInstance() { if (Instance == null) { Instance = this; } return Instance;} /** 获取DaoMaster @param context @return /public static DaoMaster getDaoMaster(Context context) { if (daoMaster == null) { try&#123; ContextWrapper wrapper = new ContextWrapper(context) &#123; /** * 获得数据库路径，如果不存在，则创建对象对象 * * @param name */ @Override public File getDatabasePath(String name) &#123; // 判断是否存在sd卡 boolean sdExist = android.os.Environment.MEDIA_MOUNTED.equals(android.os.Environment.getExternalStorageState()); if (!sdExist) &#123;// 如果不存在, Log.e(&quot;SD卡管理：&quot;, &quot;SD卡不存在，请加载SD卡&quot;); return null; &#125; else &#123;// 如果存在 // 获取sd卡路径 String dbDir = android.os.Environment.getExternalStorageDirectory().getAbsolutePath(); dbDir += &quot;/Android&quot;;// 数据库所在目录 String dbPath = dbDir + &quot;/&quot; + name;// 数据库路径 // 判断目录是否存在，不存在则创建该目录 File dirFile = new File(dbDir); if (!dirFile.exists()) dirFile.mkdirs(); // 数据库文件是否创建成功 boolean isFileCreateSuccess = false; // 判断文件是否存在，不存在则创建该文件 File dbFile = new File(dbPath); if (!dbFile.exists()) &#123; try &#123; isFileCreateSuccess = dbFile.createNewFile();// 创建文件 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; else isFileCreateSuccess = true; // 返回数据库文件对象 if (isFileCreateSuccess) return dbFile; else return super.getDatabasePath(name); &#125; &#125; /** * 重载这个方法，是用来打开SD卡上的数据库的，android 2.3及以下会调用这个方法。 * * @param name * @param mode * @param factory */ @Override public SQLiteDatabase openOrCreateDatabase(String name, int mode, SQLiteDatabase.CursorFactory factory) &#123; return SQLiteDatabase.openOrCreateDatabase(getDatabasePath(name), null); &#125; /** * Android 4.0会调用此方法获取数据库。 * * @see android.content.ContextWrapper#openOrCreateDatabase(java.lang.String, * int, * android.database.sqlite.SQLiteDatabase.CursorFactory, * android.database.DatabaseErrorHandler) * @param name * @param mode * @param factory * @param errorHandler */ @Override public SQLiteDatabase openOrCreateDatabase(String name, int mode, SQLiteDatabase.CursorFactory factory, DatabaseErrorHandler errorHandler) &#123; return SQLiteDatabase.openOrCreateDatabase(getDatabasePath(name), null); &#125; &#125;; DaoMaster.OpenHelper helper = new DaoMaster.DevOpenHelper(wrapper,&quot;test.db&quot;,null); daoMaster = new DaoMaster(helper.getWritableDatabase()); //获取未加密的数据库 &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; } return daoMaster;} /** 获取DaoSession对象 @param context @return /public static DaoSession getDaoSession(Context context) { if (daoSession == null) { if (daoMaster == null) &#123; getDaoMaster(context); &#125; daoSession = daoMaster.newSession(); } return daoSession;} } 版本升级更新比如需要在实体类加一个字段 或者 改变字段属性等 就需要版本更新来保存以前的数据了； public class Helper extends DaoMaster.OpenHelper{ private static DaoMaster daoMaster;private static DaoSession daoSession; public static final String DBNAME = “greendao.db”; public Helper(Context context){ super(context,DBNAME,null);} @Overridepublic void onUpgrade(Database db, int oldVersion, int newVersion) { super.onUpgrade(db, oldVersion, newVersion); Log.i(“version”, oldVersion + “—先前和更新之后的版本—“ + newVersion); if (oldVersion &lt; newVersion) { Log.i(“version”, oldVersion + “—先前和更新之后的版本—“ + newVersion); MigrationHelper.getInstance().migrate(db, UserDao.class); //更改过的实体类(新增的不用加) 更新UserDao文件 可以添加多个 XXDao.class 文件 // MigrationHelper.getInstance().migrate(db, UserDao.class,XXDao.class);}} /** 取得DaoMaster @param context @return /public static DaoMaster getDaoMaster(Context context) { if (daoMaster == null) { DaoMaster.OpenHelper helper = new DaoMaster.DevOpenHelper(context, DBNAME, null); daoMaster = new DaoMaster(helper.getWritableDatabase()); } return daoMaster;} /** 取得DaoSession @param context @return /public static DaoSession getDaoSession(Context context) { if (daoSession == null) { if (daoMaster == null) &#123; daoMaster = getDaoMaster(context); &#125; daoSession = daoMaster.newSession(); } return daoSession;} } public class GreenApplication extends Application {private DaoMaster.DevOpenHelper mHelper;//private Helper mHelper;private SQLiteDatabase db;private DaoMaster mDaoMaster;private DaoSession mDaoSession;public static GreenApplication instances;@Override public void onCreate() {super.onCreate();instances = this;setDatabase();}public static GreenApplication getInstances(){return instances;} /**•设置greenDao*/private void setDatabase() {// 通过 DaoMaster 的内部类 DevOpenHelper，你可以得到一个便利的 SQLiteOpenHelper 对象。// 可能你已经注意到了，你并不需要去编写「CREATE TABLE」这样的 SQL 语句，因为 greenDAO 已经帮你做了。// 注意：默认的 DaoMaster.DevOpenHelper 会在数据库升级时，删除所有的表，意味着这将导致数据的丢失。// 所以，在正式的项目中，你还应该做一层封装，来实现数据库的安全升级。 mHelper = new Helper(new GreenDaoUtils(this)); //mHelper = new DaoMaster.DevOpenHelper(this, “notes-db”, null);db = mHelper.getWritableDatabase();// 注意：该数据库连接属于 DaoMaster，所以多个 Session 指的是相同的数据库连接。mDaoMaster = new DaoMaster(db);mDaoSession = mDaoMaster.newSession();}public DaoSession getDaoSession() {return mDaoSession;}public SQLiteDatabase getDb() {return db;}}","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"android自定义优雅日历","slug":"categories/Android/android自定义优雅日历","date":"2020-08-20T07:56:55.000Z","updated":"2020-08-21T07:10:18.017Z","comments":true,"path":"2020/08/20/categories/Android/android自定义优雅日历/","link":"","permalink":"https://visen123.github.io/2020/08/20/categories/Android/android%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BC%98%E9%9B%85%E6%97%A5%E5%8E%86/","excerpt":"","text":"Adroid自定义优雅、性能高效的日历控件，完美支持周视图，支持标记、自定义颜色、农历等，任意控制月视图显示、任意日期拦截条件、自定义周起始等。Canvas绘制，极速性能、占用内存低，，支持简单定制即可实现任意自定义布局、自定义UI，支持收缩展开、性能非常高效， 这个控件内存和效率优势相当明显，而且真正做到收缩+展开，适配多种场景，支持同时多种颜色标记日历事务，支持多点触控，你真的想不到日历还可以如此优雅！更多参考用法请移步Demo，Demo实现了4个精美的自定义效果。 dependencies { implementation ‘com.github.Visen123:CalendarView:V1.0’ } 混淆proguard-rules-keepclasseswithmembers class * {public (android.content.Context);}或者针对性的使用混淆-keep class your project path.MonthView {public (android.content.Context);}-keep class your project path.WeekBar {public (android.content.Context);}-keep class your project path.WeekView {public (android.content.Context);} 特别的，请注意不要复制这三个路径，自行替换您自己的自定义路径 app:month_view=”com.yanyiyun.calendarviewproject.simple.SimpleCalendarCardView”app:week_view=”com.yanyiyun.calendarviewproject.simple.SimpleWeekView”app:week_bar_view=”com.yanyiyun.calendarviewproject.EnglishWeekBar”使用方法 &lt;com.yanyiyun.calendarview.CalendarLayout android:layout_width=”match_parent” android:layout_height=”match_parent” android:orientation=”vertical” app:default_status=”shrink” app:calendar_show_mode=”only_week_view” app:calendar_content_view_id=”@+id/recyclerView”&gt; &lt;com.yanyiyun.calendarview.CalendarView android:id=&quot;@+id/calendarView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#fff&quot; app:month_view=&quot;com.yanyiyun.calendarviewproject.simple.SimpleCalendarCardView&quot; app:week_view=&quot;com.yanyiyun.calendarviewproject.simple.SimpleWeekView&quot; app:week_bar_view=&quot;com.yanyiyun.calendarviewproject.EnglishWeekBar&quot; app:calendar_height=&quot;50dp&quot; app:current_month_text_color=&quot;#333333&quot; app:current_month_lunar_text_color=&quot;#CFCFCF&quot; app:min_year=&quot;2004&quot; app:other_month_text_color=&quot;#e1e1e1&quot; app:scheme_text=&quot;假&quot; app:scheme_text_color=&quot;#333&quot; app:scheme_theme_color=&quot;#333&quot; app:selected_text_color=&quot;#fff&quot; app:selected_theme_color=&quot;#333&quot; app:week_start_with=&quot;mon&quot; app:week_background=&quot;#fff&quot; app:month_view_show_mode=&quot;mode_only_current&quot; app:week_text_color=&quot;#111&quot; /&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/recyclerView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#d4d4d4&quot; /&gt; &lt;/com.yanyiyun.calendarview.CalendarLayout&gt; CalendarView attrs &lt;attr name=&quot;calendar_padding&quot; format=&quot;dimension&quot; /&gt;&lt;!--日历内部左右padding--&gt; &lt;attr name=&quot;month_view&quot; format=&quot;color&quot; /&gt; &lt;!--自定义类日历月视图路径--&gt; &lt;attr name=&quot;week_view&quot; format=&quot;string&quot; /&gt; &lt;!--自定义类周视图路径--&gt; &lt;attr name=&quot;week_bar_height&quot; format=&quot;dimension&quot; /&gt; &lt;!--星期栏的高度--&gt; &lt;attr name=&quot;week_bar_view&quot; format=&quot;color&quot; /&gt; &lt;!--自定义类周栏路径，通过自定义则 week_text_color week_background xml设置无效，当仍可java api设置--&gt; &lt;attr name=&quot;week_line_margin&quot; format=&quot;dimension&quot; /&gt;&lt;!--线条margin--&gt; &lt;attr name=&quot;week_line_background&quot; format=&quot;color&quot; /&gt;&lt;!--线条颜色--&gt; &lt;attr name=&quot;week_background&quot; format=&quot;color&quot; /&gt; &lt;!--星期栏的背景--&gt; &lt;attr name=&quot;week_text_color&quot; format=&quot;color&quot; /&gt; &lt;!--星期栏文本颜色--&gt; &lt;attr name=&quot;week_text_size&quot; format=&quot;dimension&quot; /&gt;&lt;!--星期栏文本大小--&gt; &lt;attr name=&quot;current_day_text_color&quot; format=&quot;color&quot; /&gt; &lt;!--今天的文本颜色--&gt; &lt;attr name=&quot;current_day_lunar_text_color&quot; format=&quot;color&quot; /&gt;&lt;!--今天的农历文本颜色--&gt; &lt;attr name=&quot;calendar_height&quot; format=&quot;string&quot; /&gt; &lt;!--日历每项的高度，56dp--&gt; &lt;attr name=&quot;day_text_size&quot; format=&quot;string&quot; /&gt; &lt;!--天数文本大小--&gt; &lt;attr name=&quot;lunar_text_size&quot; format=&quot;string&quot; /&gt; &lt;!--农历文本大小--&gt; &lt;attr name=&quot;scheme_text&quot; format=&quot;string&quot; /&gt; &lt;!--标记文本--&gt; &lt;attr name=&quot;scheme_text_color&quot; format=&quot;color&quot; /&gt; &lt;!--标记文本颜色--&gt; &lt;attr name=&quot;scheme_month_text_color&quot; format=&quot;color&quot; /&gt; &lt;!--标记天数文本颜色--&gt; &lt;attr name=&quot;scheme_lunar_text_color&quot; format=&quot;color&quot; /&gt; &lt;!--标记农历文本颜色--&gt; &lt;attr name=&quot;scheme_theme_color&quot; format=&quot;color&quot; /&gt; &lt;!--标记的颜色--&gt; &lt;attr name=&quot;selected_theme_color&quot; format=&quot;color&quot; /&gt; &lt;!--选中颜色--&gt; &lt;attr name=&quot;selected_text_color&quot; format=&quot;color&quot; /&gt; &lt;!--选中文本颜色--&gt; &lt;attr name=&quot;selected_lunar_text_color&quot; format=&quot;color&quot; /&gt; &lt;!--选中农历文本颜色--&gt; &lt;attr name=&quot;current_month_text_color&quot; format=&quot;color&quot; /&gt; &lt;!--当前月份的字体颜色--&gt; &lt;attr name=&quot;other_month_text_color&quot; format=&quot;color&quot; /&gt; &lt;!--其它月份的字体颜色--&gt; &lt;attr name=&quot;current_month_lunar_text_color&quot; format=&quot;color&quot; /&gt; &lt;!--当前月份农历节假日颜色--&gt; &lt;attr name=&quot;other_month_lunar_text_color&quot; format=&quot;color&quot; /&gt; &lt;!--其它月份农历节假日颜色--&gt; &lt;!-- 年视图相关 --&gt; &lt;attr name=&quot;year_view_month_text_size&quot; format=&quot;dimension&quot; /&gt; &lt;!-- 年视图月份字体大小 --&gt; &lt;attr name=&quot;year_view_day_text_size&quot; format=&quot;dimension&quot; /&gt; &lt;!-- 年视图月份日期字体大小 --&gt; &lt;attr name=&quot;year_view_month_text_color&quot; format=&quot;color&quot; /&gt; &lt;!-- 年视图月份字体颜色 --&gt; &lt;attr name=&quot;year_view_day_text_color&quot; format=&quot;color&quot; /&gt; &lt;!-- 年视图日期字体颜色 --&gt; &lt;attr name=&quot;year_view_scheme_color&quot; format=&quot;color&quot; /&gt; &lt;!-- 年视图标记颜色 --&gt; &lt;attr name=&quot;min_year&quot; format=&quot;integer&quot; /&gt; &lt;!--最小年份1900--&gt; &lt;attr name=&quot;max_year&quot; format=&quot;integer&quot; /&gt; &lt;!--最大年份2099--&gt; &lt;attr name=&quot;min_year_month&quot; format=&quot;integer&quot; /&gt; &lt;!--最小年份对应月份--&gt; &lt;attr name=&quot;max_year_month&quot; format=&quot;integer&quot; /&gt; &lt;!--最大年份对应月份--&gt; &lt;!--月视图是否可滚动--&gt; &lt;attr name=&quot;month_view_scrollable&quot; format=&quot;boolean&quot; /&gt; &lt;!--周视图是否可滚动--&gt; &lt;attr name=&quot;week_view_scrollable&quot; format=&quot;boolean&quot; /&gt; &lt;!--年视图是否可滚动--&gt; &lt;attr name=&quot;year_view_scrollable&quot; format=&quot;boolean&quot; /&gt; &lt;!--配置你喜欢的月视图显示模式模式--&gt; &lt;attr name=&quot;month_view_show_mode&quot;&gt; &lt;enum name=&quot;mode_all&quot; value=&quot;0&quot; /&gt; &lt;!--全部显示--&gt; &lt;enum name=&quot;mode_only_current&quot; value=&quot;1&quot; /&gt; &lt;!--仅显示当前月份--&gt; &lt;enum name=&quot;mode_fix&quot; value=&quot;2&quot; /&gt; &lt;!--自适应显示，不会多出一行，但是会自动填充--&gt; &lt;/attr&gt; &lt;!-- 自定义周起始 --&gt; &lt;attr name=&quot;week_start_with&quot;&gt; &lt;enum name=&quot;sun&quot; value=&quot;1&quot; /&gt; &lt;enum name=&quot;mon&quot; value=&quot;2&quot; /&gt; &lt;enum name=&quot;sat&quot; value=&quot;7&quot; /&gt; &lt;/attr&gt; &lt;!-- 自定义选择模式 --&gt; &lt;attr name=&quot;select_mode&quot;&gt; &lt;enum name=&quot;default_mode&quot; value=&quot;0&quot; /&gt; &lt;enum name=&quot;single_mode&quot; value=&quot;1&quot; /&gt; &lt;enum name=&quot;range_mode&quot; value=&quot;2&quot; /&gt; &lt;/attr&gt; &lt;!-- 当 select_mode=range_mode --&gt; &lt;attr name=&quot;min_select_range&quot; format=&quot;integer&quot; /&gt; &lt;attr name=&quot;max_select_range&quot; format=&quot;integer&quot; /&gt; CalendarView api public void setRange(int minYear, int minYearMonth, int minYearDay, int maxYear, int maxYearMonth, int maxYearDay) ;//置日期范围 public int getCurDay(); //今天public int getCurMonth(); //当前的月份public int getCurYear(); //今年 public boolean isYearSelectLayoutVisible();//年月份选择视图是否打开public void closeYearSelectLayout();//关闭年月视图选择布局public void showYearSelectLayout(final int year); //快速弹出年份选择月份 public void setOnMonthChangeListener(OnMonthChangeListener listener);//月份改变事件 public void setOnYearChangeListener(OnYearChangeListener listener);//年份切换事件 public void setOnCalendarSelectListener(OnCalendarSelectListener listener)//日期选择事件 public void setOnCalendarLongClickListener(OnCalendarLongClickListener listener);//日期长按事件 public void setOnCalendarLongClickListener(OnCalendarLongClickListener listener, boolean preventLongPressedSelect);//日期长按事件 public void setOnCalendarInterceptListener(OnCalendarInterceptListener listener);//日期拦截和日期有效性绘制 public void setSchemeDate(Map&lt;String, Calendar&gt; mSchemeDates);//标记日期 public void update();//动态更新 public Calendar getSelectedCalendar(); //获取选择的日期 /** 特别的，如果你需要自定义或者使用其它选择器，可以用以下方法进行和日历联动 /public void scrollToCurrent();//滚动到当前日期 public void scrollToCurrent(boolean smoothScroll);//滚动到当前日期 public void scrollToYear(int year);//滚动到某一年 public void scrollToPre();//滚动到上一个月 public void scrollToNext();//滚动到下一个月 public void scrollToCalendar(int year, int month, int day);//滚动到指定日期 public Calendar getMinRangeCalendar();//获得最小范围日期 public Calendar getMaxRangeCalendar();//获得最大范围日期 /** 设置背景色 @param monthLayoutBackground 月份卡片的背景色 @param weekBackground 星期栏背景色 @param lineBg 线的颜色 /public void setBackground(int monthLayoutBackground, int weekBackground, int lineBg) /** 设置文本颜色 @param curMonthTextColor 当前月份字体颜色 @param otherMonthColor 其它月份字体颜色 @param lunarTextColor 农历字体颜色 /public void setTextColor(int curMonthTextColor,int otherMonthColor,int lunarTextColor) /** 设置选择的效果 @param style 选中的style CalendarCardView.STYLE_FILL or CalendarCardView.STYLE_STROKE @param selectedThemeColor 选中的标记颜色 @param selectedTextColor 选中的字体颜色 /public void setSelectedColor(int style, int selectedThemeColor, int selectedTextColor) /** 设置标记的色 @param style 标记的style CalendarCardView.STYLE_FILL or CalendarCardView.STYLE_STROKE @param schemeColor 标记背景色 @param schemeTextColor 标记字体颜色 /public void setSchemeColor(int style, int schemeColor, int schemeTextColor) /** 设置星期栏的背景和字体颜色 @param weekBackground 背景色 @param weekTextColor 字体颜色 /public void setWeeColor(int weekBackground, int weekTextColor)CalendarLayout apipublic void expand(); //展开 public void shrink(); //收缩 public boolean isExpand();//是否展开了CalendarLayout attrs &lt;项目地址：https://github.com/Visen123/CalendarView&gt;","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"编写使用Android 系统自带的文字转语音代码","slug":"categories/Android/编写使用Android-系统自带的文字转语音代码","date":"2020-08-20T07:56:55.000Z","updated":"2020-08-21T07:10:18.127Z","comments":true,"path":"2020/08/20/categories/Android/编写使用Android-系统自带的文字转语音代码/","link":"","permalink":"https://visen123.github.io/2020/08/20/categories/Android/%E7%BC%96%E5%86%99%E4%BD%BF%E7%94%A8Android-%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%B8%A6%E7%9A%84%E6%96%87%E5%AD%97%E8%BD%AC%E8%AF%AD%E9%9F%B3%E4%BB%A3%E7%A0%81/","excerpt":"","text":"调用Android系统语音TextToSpeech实例对象 具体代码写法如下： TextToSpeech mTextToSpeech = new TextToSpeech(this, new TextToSpeech.OnInitListener() { @Override public void onInit(int status) { if (status==TextToSpeech.SUCCESS) { //设置语言朗读 int supported= mTextToSpeech.setLanguage(Locale.US); if ((supported!=TextToSpeech.LANG_AVAILABLE)&amp;&amp; (supported!=TextToSpeech.LANG_COUNTRY_AVAILABLE)) { Toast.makeText(this, &quot;不支持当前语言！&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; &#125; &#125;); mTextToSpeech.speak(“这里填入想要转成语音的文字”, TextToSpeech.QUEUE_FLUSH, null);","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"Hello World","slug":"categories/前端/hello-world","date":"2020-08-02T12:26:42.000Z","updated":"2021-09-01T04:04:08.587Z","comments":true,"path":"2020/08/02/categories/前端/hello-world/","link":"","permalink":"https://visen123.github.io/2020/08/02/categories/%E5%89%8D%E7%AB%AF/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"前端","slug":"前端","permalink":"https://visen123.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://visen123.github.io/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"Android开发图片开源框架","slug":"categories/Android/Android开发图片开源框架","date":"2020-07-27T06:20:40.000Z","updated":"2021-09-01T04:24:53.809Z","comments":true,"path":"2020/07/27/categories/Android/Android开发图片开源框架/","link":"","permalink":"https://visen123.github.io/2020/07/27/categories/Android/Android%E5%BC%80%E5%8F%91%E5%9B%BE%E7%89%87%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/","excerpt":"","text":"1、图片加载，缓存，处理 框架名称 ：Android Universal Image Loader 一个强大的加载，缓存，展示图片的库，已过时Picasso 一个强大的图片下载与缓存的库Fresco 一个用于管理图像和他们使用的内存的库Glide 一个图片加载和缓存的库，使用的App有：网易新闻GlidePalette Android Lollipop Palette is now easy to use with GlidePicassoPalette Android Lollipop Palette is now easy to use with Picasso !Picasso-transformations 一个为Picasso提供多种图片变换的库Glide-transformations 一个为Glide提供多种图片变换的库 2、图片裁剪 框架名称 ：uCrop Image Cropping Library for Android，使用的App有：薄荷，哔哩哔哩android-crop 图片裁剪，使用的App有：网易新闻，芒果TVcropper 图片裁剪开源框架Android-Image-Cropper Image Cropping Library for Android, optimized for Camera / GalleryPhotoCropper Android 大图片裁剪终极解决方案android-cropimage CropImage Activity from Gallery.apk packaged as a reusable Android libraryPhotoCrop A Library which can be used to crop images in Android similar to Facebook and Telegram，使用的App有：快手 3、图片选择框架名称 ：MultiImageSelector 图片选择，使用的App有：薄荷BGAPhotoPicker-Android Android 图片选择、预览、九宫格图片控件、拖拽排序九宫格图片控件TakePhoto 轻量级Android照片处理框架RxGalleryFinal Android图片单选/多选、拍照、裁剪、压缩。视频选择和录制。GalleryFinalboxing 一个多媒体选择器库，B站出品。可以选择一张或者多张图片，提供预览和裁剪功能。同样支持gif图，选择视频和图像压缩功能。 4、图片转换，压缩，滤镜 框架名称 ：Android-gpuimage 一个开源的基于GPU的图像处理库，提供各种各样的图像处理滤镜，并且支持照相机和摄像机的实时滤镜，使用的App有：快手photoview 使用的App有：薄荷,网易新闻circleimageview 圆形图片，使用的App有：薄荷RoundedImageView 圆形图片，使用的App有：薄荷SelectableRoundedImageView Android ImageView that supports different radii on each cornerandroid-gif-drawable gif图片，使用的App有：网易新闻，快手Luban 可能是最接近微信朋友圈的图片压缩算法Compressor Compressor is a lightweight and powerful android image compression library 5、高斯模糊，毛玻璃，图片模糊 框架名称 ：android-stackblur Android StackBlur is a library that can perform a blurry effect on a Bitmap based on a gradient or radius, and return the result. The library is based on the code of Mario Klingemann.Blurry Blurry is an easy blur library for Androidblurkit-android The missing Android blurring library. Fast blur-behind layout that parallels iOS.BlurView Dynamic iOS-like blur of underlying Views for AndroidImageBlurring Android blurring image(bitmap) by java and jni","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"解决在安卓8.0以上应用升级安装失败权限问题","slug":"categories/Android/解决在安卓8.0以上应用升级安装失败权限问题","date":"2020-07-12T11:36:40.000Z","updated":"2021-09-01T04:19:19.484Z","comments":true,"path":"2020/07/12/categories/Android/解决在安卓8.0以上应用升级安装失败权限问题/","link":"","permalink":"https://visen123.github.io/2020/07/12/categories/Android/%E8%A7%A3%E5%86%B3%E5%9C%A8%E5%AE%89%E5%8D%938.0%E4%BB%A5%E4%B8%8A%E5%BA%94%E7%94%A8%E5%8D%87%E7%BA%A7%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/","excerpt":"","text":"解决在安卓8.0、9.0机子上内部应用升级安装失败权限问题： 1、在AndroidManifest.xml 里配置安装权限 如下代码： 2、 在Application 配置如下代码//适配安卓8.0、9.0升级安装应用权限 ，请求权限允许安装未知应用权限public void allowUnKnowSrc(Context context){try {// todo 0代表禁止安装未知应用，1代表允许安装未知应用android.provider.Settings.Global.putInt(context.getContentResolver(),Settings.Secure.INSTALL_NON_MARKET_APPS, 1);}catch(SecurityException se){Log.e(“SecurityException==”,”安装未知应用权限问题”);}}","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"APP适配安卓手机刘海屏","slug":"categories/Android/APP适配安卓手机刘海屏","date":"2020-06-20T07:33:40.000Z","updated":"2021-09-01T04:20:26.633Z","comments":true,"path":"2020/06/20/categories/Android/APP适配安卓手机刘海屏/","link":"","permalink":"https://visen123.github.io/2020/06/20/categories/Android/APP%E9%80%82%E9%85%8D%E5%AE%89%E5%8D%93%E6%89%8B%E6%9C%BA%E5%88%98%E6%B5%B7%E5%B1%8F/","excerpt":"","text":"如果你想允许全屏界面内容显示到刘海区域 ，只要在AndroidManifest.xml文件里配置如下代码即可： &lt;!--适配华为（huawei）刘海屏--&gt; &lt;meta-data android:name=&quot;android.notch_support&quot; android:value=&quot;true&quot;/&gt; &lt;!--适配小米（xiaomi）刘海屏--&gt; &lt;meta-data android:name=&quot;notch.config&quot; android:value=&quot;portrait|landscape&quot; /&gt;","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"判断隐式intent跳转是否有判断有匹配的activity","slug":"categories/Android/判断隐式intent跳转是否有判断有匹配的activity","date":"2020-06-20T07:33:40.000Z","updated":"2024-07-16T08:26:39.954Z","comments":true,"path":"2020/06/20/categories/Android/判断隐式intent跳转是否有判断有匹配的activity/","link":"","permalink":"https://visen123.github.io/2020/06/20/categories/Android/%E5%88%A4%E6%96%AD%E9%9A%90%E5%BC%8Fintent%E8%B7%B3%E8%BD%AC%E6%98%AF%E5%90%A6%E6%9C%89%E5%88%A4%E6%96%AD%E6%9C%89%E5%8C%B9%E9%85%8D%E7%9A%84activity/","excerpt":"","text":"由于隐式intent并不会明确告知要打开哪些activity，有可能设备上就不会有合适的应用。这时候应用就会崩溃。为此我们在使用隐式intent之前，应该先进行安全检查，判断是否有合适的activity。 Intent intentpic = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); PackageManager pm=getPackageManager(); List activities=pm.queryIntentActivities(intentpic,0); if(activities.size()&lt;=0) { //不存在匹配跳转隐式intent的Activity ToastUtil.toastShow(PeopleDataActivity.this,”设备不支持拍照”); &#125; else&#123; //存在匹配跳转隐式intent的Activity ToastUtil.toastShow(PeopleDataActivity.this,&quot;设备支持拍照&quot;); &#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"RadioGroup结合RadioButton使用切换Fragment片段","slug":"categories/Android/RadioGroup结合RadioButton使用切换Fragment片段","date":"2020-05-22T06:33:40.000Z","updated":"2021-09-01T04:41:24.550Z","comments":true,"path":"2020/05/22/categories/Android/RadioGroup结合RadioButton使用切换Fragment片段/","link":"","permalink":"https://visen123.github.io/2020/05/22/categories/Android/RadioGroup%E7%BB%93%E5%90%88RadioButton%E4%BD%BF%E7%94%A8%E5%88%87%E6%8D%A2Fragment%E7%89%87%E6%AE%B5/","excerpt":"","text":"##界面布局activity_lan_qiu，代码xml设置如下： &lt;LinearLayout xmlns:android=”http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;include layout=&quot;@layout/tool_bar&quot;/&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@color/white&quot; android:orientation=&quot;vertical&quot;&gt; &lt;FrameLayout android:id=&quot;@+id/fragment_container&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot; android:background=&quot;@color/white&quot;&gt; &lt;/FrameLayout&gt; &lt;RadioGroup android:id=&quot;@+id/radioGroup&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;40dp&quot; android:orientation=&quot;horizontal&quot; android:background=&quot;@color/colorPrimary&quot; &gt; &lt;RadioButton android:text=&quot;首页&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:id=&quot;@+id/btn_homepage&quot; android:layout_weight=&quot;1&quot; android:button=&quot;@null&quot; android:gravity=&quot;center&quot; android:textColor=&quot;@color/selector_font_color&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;RadioButton android:text=&quot;社区&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:id=&quot;@+id/btn_message&quot; android:layout_weight=&quot;1&quot; android:button=&quot;@null&quot; android:gravity=&quot;center&quot; android:textColor=&quot;@color/selector_font_color&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;RadioButton android:text=&quot;运动&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:id=&quot;@+id/btn_service&quot; android:layout_weight=&quot;1&quot; android:button=&quot;@null&quot; android:gravity=&quot;center&quot; android:textColor=&quot;@color/selector_font_color&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;RadioButton android:text=&quot;个人&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:id=&quot;@+id/btn_my&quot; android:layout_weight=&quot;1&quot; android:button=&quot;@null&quot; android:gravity=&quot;center&quot; android:textColor=&quot;@color/selector_font_color&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;/RadioGroup&gt; &lt;/LinearLayout&gt; ##android java 类LanQiuActivity 代码如下： public class LanQiuActivity extends FragmentActivity implements RadioGroup.OnCheckedChangeListener { private RadioGroup radioGroup; private RadioButton btn_homepage, btn_message, btn_service, btn_my; public static final String fragment1Tag = &quot;fragment1&quot;; public static final String fragment2Tag = &quot;fragment2&quot;; public static final String fragment3Tag = &quot;fragment3&quot;; public static final String fragment4Tag = &quot;fragment4&quot;; private AMapLocationClient locationClient = null; private AMapLocationClientOption locationOption = null; private TextView tvshare; private TextView iv_back; String city; public static boolean aa = true; private Toolbar toolbar; /** * 定位监听 */ AMapLocationListener locationListener = new AMapLocationListener() &#123; @Override public void onLocationChanged(AMapLocation location) &#123; if (null != location) &#123; StringBuffer sb = new StringBuffer(); if (location.getErrorCode() == 0) &#123; //解析定位结果， city = location.getLatitude() + &quot;:&quot; + location.getLongitude(); &#125; else &#123; sb.append(&quot;定位失败&quot; + &quot;\\n&quot;); sb.append(&quot;错误码:&quot; + location.getErrorCode() + &quot;\\n&quot;); &#125; Log.e(&quot;解析定位结果&quot;, city); iv_back.setText(location.getCity()); &#125; else &#123; iv_back.setText(&quot;定位失败&quot;); &#125; if (aa) &#123; XinzhiTianqiData(); aa = false; &#125; &#125; &#125;; /** * 开始定位 * * @author hongming.wang * @since 2.8.0 */ private void startLocation() &#123; //根据控件的选择，重新设置定位参数 // resetOption(); // 设置定位参数 locationClient.setLocationOption(locationOption); // 启动定位 locationClient.startLocation(); &#125; /** * 默认的定位参数 * * @author hongming.wang * @since 2.8.0 */ private AMapLocationClientOption getDefaultOption() &#123; AMapLocationClientOption mOption = new AMapLocationClientOption(); mOption.setLocationMode(AMapLocationClientOption.AMapLocationMode.Hight_Accuracy);//可选，设置定位模式，可选的模式有高精度、仅设备、仅网络。默认为高精度模式 mOption.setGpsFirst(false);//可选，设置是否gps优先，只在高精度模式下有效。默认关闭 mOption.setHttpTimeOut(30000);//可选，设置网络请求超时时间。默认为30秒。在仅设备模式下无效 mOption.setInterval(2000);//可选，设置定位间隔。默认为2秒 mOption.setNeedAddress(true);//可选，设置是否返回逆地理地址信息。默认是true mOption.setOnceLocation(false);//可选，设置是否单次定位。默认是false mOption.setOnceLocationLatest(false);//可选，设置是否等待wifi刷新，默认为false.如果设置为true,会自动变为单次定位，持续定位时不要使用 AMapLocationClientOption.setLocationProtocol(AMapLocationClientOption.AMapLocationProtocol.HTTP);//可选， 设置网络请求的协议。可选HTTP或者HTTPS。默认为HTTP mOption.setSensorEnable(false);//可选，设置是否使用传感器。默认是false mOption.setWifiScan(true); //可选，设置是否开启wifi扫描。默认为true，如果设置为false会同时停止主动刷新，停止以后完全依赖于系统刷新，定位位置可能存在误差 mOption.setLocationCacheEnable(true); //可选，设置是否使用缓存定位，默认为true return mOption; &#125; /** * 初始化定位 * * @author hongming.wang * @since 2.8.0 */ private void initLocation() &#123; //初始化client locationClient = new AMapLocationClient(getApplicationContext()); locationOption = getDefaultOption(); //设置定位参数 locationClient.setLocationOption(locationOption); // 设置定位监听 locationClient.setLocationListener(locationListener); // XinzhiTianqiData(); &#125; private void XinzhiTianqiData() &#123; RequestParams params = new RequestParams(); params.put(&quot;location&quot;, city); Log.e(&quot;天气XinzhiTianqiData&quot;, &quot;天气XinzhiTianqiData&quot;); AsyncHttpClientUtil.getInstance().get(Constants.XinzhiTianqi, params, new AsyncHttpResponseHandler() &#123; @Override public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) &#123; String s = new String(responseBody); // Log.e(“天气”, “”+s); XinzhiModle xinzhiModle = GsonUtils.parseJSON(s, XinzhiModle.class); List&lt;XinzhiModle.ResultsBean&gt; results = xinzhiModle.getResults(); String text = results.get(0).getNow().getText(); tvshare.setText(&quot;天气: &quot; + text); &#125; @Override public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) &#123; &#125; &#125;); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); if (savedInstanceState == null) &#123; FragmentManager fragmentManager = getSupportFragmentManager(); Fragment fragment = new HomeFragment(); fragmentManager.beginTransaction().replace(R.id.fragment_container, fragment, fragment1Tag).commit(); &#125; setContentView(R.layout.activity_lan_qiu); toolbar = (Toolbar) findViewById(R.id.tool_bar); TextView tool_bar_title = (TextView)findViewById(R.id.tool_bar_title); tool_bar_title.setVisibility(View.GONE); tvshare = (TextView)findViewById(R.id.tv_share1); iv_back = (TextView)findViewById(R.id.iv_back1); iv_back.setVisibility(View.VISIBLE); tvshare.setVisibility(View.VISIBLE); iv_back.setTextSize(22); tvshare.setTextSize(22); radioGroup = (RadioGroup) this.findViewById(R.id.radioGroup); btn_homepage = (RadioButton) this.findViewById(R.id.btn_homepage); btn_homepage.setSelected(true); btn_message = (RadioButton) this.findViewById(R.id.btn_message); btn_service = (RadioButton) this.findViewById(R.id.btn_service); btn_my = (RadioButton) this.findViewById(R.id.btn_my); initLocation(); startLocation(); radioGroup.setOnCheckedChangeListener(this); &#125; public static void start(Context context, SzBean szBean) &#123; Intent starter = new Intent(context, MainActivity.class); starter.putExtra(ParamsKey.EXTRA_SZBEAN, szBean); context.startActivity(starter); &#125; //选中首页界面RadioButton处理事件 private void HomePageSelect() &#123; btn_homepage.setSelected(true); btn_message.setSelected(false); btn_service.setSelected(false); btn_my.setSelected(false); &#125; //选中信息界面RadioButton处理事件 private void MessageSelect() &#123; btn_homepage.setSelected(false); btn_message.setSelected(true); btn_service.setSelected(false); btn_my.setSelected(false); &#125; ##//选中记录RadioButton处理事件 private void RecordSelect() &#123; btn_homepage.setSelected(false); btn_message.setSelected(false); btn_service.setSelected(true); btn_my.setSelected(false); &#125; ##//选中我的界面RadioButton处理事件 private void MySelect() &#123; btn_homepage.setSelected(false); btn_message.setSelected(false); btn_service.setSelected(false); btn_my.setSelected(true); &#125; ##//在RadioGroup中切换改变选中RadioButton事件，处理跳转到相应界面 @Override public void onCheckedChanged(RadioGroup radioGroup, int i) &#123; FragmentManager fm = getSupportFragmentManager(); FragmentTransaction ft = fm.beginTransaction(); Fragment fragment1 = fm.findFragmentByTag(fragment1Tag); Fragment fragment2 = fm.findFragmentByTag(fragment2Tag); Fragment fragment3 = fm.findFragmentByTag(fragment3Tag); Fragment fragment4 = fm.findFragmentByTag(fragment4Tag); if (fragment1 != null) &#123; ft.hide(fragment1); &#125; if (fragment2 != null) &#123; ft.hide(fragment2); &#125; if (fragment3 != null) &#123; ft.hide(fragment3); &#125; if (fragment4 != null) &#123; ft.hide(fragment4); &#125; switch (i) &#123; case R.id.btn_homepage: toolbar.setVisibility(View.VISIBLE); if (fragment1 == null) &#123; fragment1 = new HomeFragment(); ft.add(R.id.fragment_container, fragment1, fragment1Tag); &#125; else &#123; ft.show(fragment1); &#125; HomePageSelect(); break; case R.id.btn_message: toolbar.setVisibility(View.VISIBLE); if (fragment2 == null) &#123; fragment2 = new BBsFragment(); ft.add(R.id.fragment_container, fragment2, fragment2Tag); &#125; else &#123; ft.show(fragment2); &#125; MessageSelect(); break; case R.id.btn_service: toolbar.setVisibility(View.VISIBLE); if (fragment3 == null) &#123; fragment3 = new SportFragment(); ft.add(R.id.fragment_container, fragment3, fragment3Tag); &#125; else &#123; ft.show(fragment3); &#125; RecordSelect(); break; case R.id.btn_my: toolbar.setVisibility(View.GONE); if (fragment4 == null) &#123; fragment4 = new PersonalCenteFragment(); ft.add(R.id.fragment_container, fragment4, fragment4Tag); &#125; else &#123; ft.show(fragment4); &#125; MySelect(); break; &#125; ft.commit(); &#125; ##//app退到后台，我们去玩其他的app，过一段时间回来，这个时候我们的app已经被销毁，我们按多任务键切换回来，发现界面上多个Fragment出现了重叠的情况，这是因为多个Fragment同时显示了，出现了重叠的情况，解决的办法如下：重写Activity的onRestoreInstanceState方法 @Override protected void onRestoreInstanceState(Bundle savedInstanceState) &#123; super.onRestoreInstanceState(savedInstanceState); for (int i = 0; i &lt; radioGroup.getChildCount(); i++) &#123; RadioButton mTab = (RadioButton) radioGroup.getChildAt(i); FragmentManager fm = getSupportFragmentManager(); Fragment fragment = fm.findFragmentByTag((String) mTab.getTag()); FragmentTransaction ft = fm.beginTransaction(); if (fragment != null) &#123; if (!mTab.isChecked()) &#123; ft.hide(fragment); &#125; &#125; ft.commit(); &#125; &#125; private long mExitTime; ##//按back提示再按一次退出 public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_BACK) &#123; if ((System.currentTimeMillis() - mExitTime) &gt; 2000) &#123; Toast.makeText(getApplicationContext(), &quot;再按一次退出&quot;, Toast.LENGTH_SHORT).show(); mExitTime = System.currentTimeMillis(); &#125; else &#123; finish(); System.exit(0); &#125; return true; &#125; return super.onKeyDown(keyCode, event); &#125; }","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"APP适配安卓手机刘海屏","slug":"categories/Android/更新ui常用方法","date":"2020-05-20T07:33:40.000Z","updated":"2021-09-01T04:56:09.967Z","comments":true,"path":"2020/05/20/categories/Android/更新ui常用方法/","link":"","permalink":"https://visen123.github.io/2020/05/20/categories/Android/%E6%9B%B4%E6%96%B0ui%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"更新ui代码段在Main线程执行常用方法 1.runOnUiThread 2.view.post view.postDelay() 3.handler.post handler.postDelay()","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"拼图APP 隐私声明","slug":"categories/Android/拼图APP","date":"2019-10-28T15:20:17.000Z","updated":"2021-09-01T05:10:30.295Z","comments":true,"path":"2019/10/28/categories/Android/拼图APP/","link":"","permalink":"https://visen123.github.io/2019/10/28/categories/Android/%E6%8B%BC%E5%9B%BEAPP/","excerpt":"","text":"尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，”拼图”会按照本隐私权政策的规定使用和披露您的个人信息。但”拼图”将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，”拼图”不会将这些信息对外披露或向第三方提供。”拼图”会不时更新本隐私权政策。您在同意”拼图”服务使用协议之时，即视为您已经同意本隐私权政策全部内容。本隐私权政策属于”拼图”服务使用协议不可分割的一部分。 1.适用范围 (1)在您使用本应用网络服务，或访问本应用平台网页时，本应用自动接收并记录的您的浏览器； (2)本应用通过合法途径从商业伙伴处取得的用户个人数据。 您了解并同意，以下信息不适用本隐私权政策： (3)您在使用本应用平台提供的搜索服务时输入的关键字信息； (4)本应用收集到的您在本应用发布的有关信息数据，包括但不限于参与活动、成交信息及评价详情； (5)违反法律规定或违反本应用规则行为及本应用已对您采取的措施。 2.信息使用 (a)本应用不会向任何无关第三方提供、出售、出租、分享或交易您的个人信息，除非事先得到您的许可，或该第三方和本应用（含本应用关联公司）单独或共同为您提供服务，且在该服务结束后，其将被禁止访问包括其以前能够访问的所有这些资料。 (b)本应用亦不允许任何第三方以任何手段收集、编辑、出售或者无偿传播您的个人信息。任何本应用平台用户如从事上述活动，一经发现，本应用有权立即终止与该用户的服务协议。 (c)为服务用户的目的，本应用可能通过使用您的个人信息，向您提供您感兴趣的信息，包括但不限于向您发出产品和服务信息，或者与本应用合作伙伴共享信息以便他们向您发送有关其产品和服务的信息（后者需要您的事先同意）。 3.信息披露 在如下情况下，本应用将依据您的个人意愿或法律的规定全部或部分的披露您的个人信息： (a)经您事先同意，向第三方披露； (b)为提供您所要求的产品和服务，而必须和第三方分享您的个人信息； (c)根据法律的有关规定，或者行政或司法机构的要求，向第三方或者行政、司法机构披露； (d)如您出现违反中国有关法律、法规或者本应用服务协议或相关规则的情况，需要向4.第三方披露； (e)如您是适格的知识产权投诉人并已提起投诉，应被投诉人要求，向被投诉人披露，以便双方处理可能的权利纠纷； (f)在本应用平台上创建的某一交易中，如交易任何一方履行或部分履行了交易义务并提出信息披露请求的，本应用有权决定向该用户提供其交易对方的联络方式等必要信息，以促成交易的完成或纠纷的解决。 (g)其它本应用根据法律、法规或者网站政策认为合适的披露。 5.信息存储和交换 本应用收集的有关您的信息和资料将保存在本应用及（或）其关联公司的服务器上，这些信息和资料可能传送至您所在国家、地区或本应用收集信息和资料所在地的境外并在境外被访问、存储和展示。 6.Cookie的使用 (a)在您未拒绝接受cookies的情况下，本应用会在您的计算机上设定或取用cookies ，以便您能登录或使用依赖于cookies的本应用平台服务或功能。本应用使用cookies可为您提供更加周到的个性化服务，包括推广服务。 (b)您有权选择接受或拒绝接受cookies。您可以通过修改浏览器设置的方式拒绝接受cookies。但如果您选择拒绝接受cookies，则您可能无法登录或使用依赖于cookies的本应用网络服务或功能。 (c)通过本应用所设cookies所取得的有关信息，将适用本政策。 7.信息安全 (a)本应用帐号均有安全保护功能，请妥善保管您的用户名及密码信息。本应用将通过对用户密码进行加密等安全措施确保您的信息不丢失，不被滥用和变造。尽管有前述安全措施，但同时也请您注意在信息网络上不存在“完善的安全措施”。","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"猜歌APP 隐私声明","slug":"categories/Android/猜歌APP","date":"2019-09-10T14:22:22.000Z","updated":"2023-12-06T10:51:11.935Z","comments":true,"path":"2019/09/10/categories/Android/猜歌APP/","link":"","permalink":"https://visen123.github.io/2019/09/10/categories/Android/%E7%8C%9C%E6%AD%8CAPP/","excerpt":"","text":"尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，”猜歌”会按照本隐私权政策的规定使用和披露您的个人信息。但”猜歌”将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，”猜歌”不会将这些信息对外披露或向第三方提供。”猜歌”会不时更新本隐私权政策。您在同意”猜歌”服务使用协议之时，即视为您已经同意本隐私权政策全部内容。本隐私权政策属于”猜歌”服务使用协议不可分割的一部分。 1.适用范围 (1)在您使用本应用网络服务，或访问本应用平台网页时，本应用自动接收并记录的您的浏览器； (2)本应用通过合法途径从商业伙伴处取得的用户个人数据。 您了解并同意，以下信息不适用本隐私权政策： (3)您在使用本应用平台提供的搜索服务时输入的关键字信息； (4)本应用收集到的您在本应用发布的有关信息数据，包括但不限于参与活动、成交信息及评价详情； (5)违反法律规定或违反本应用规则行为及本应用已对您采取的措施。 2.信息使用 (a)本应用不会向任何无关第三方提供、出售、出租、分享或交易您的个人信息，除非事先得到您的许可，或该第三方和本应用（含本应用关联公司）单独或共同为您提供服务，且在该服务结束后，其将被禁止访问包括其以前能够访问的所有这些资料。 (b)本应用亦不允许任何第三方以任何手段收集、编辑、出售或者无偿传播您的个人信息。任何本应用平台用户如从事上述活动，一经发现，本应用有权立即终止与该用户的服务协议。 (c)为服务用户的目的，本应用可能通过使用您的个人信息，向您提供您感兴趣的信息，包括但不限于向您发出产品和服务信息，或者与本应用合作伙伴共享信息以便他们向您发送有关其产品和服务的信息（后者需要您的事先同意）。 3.信息披露 在如下情况下，本应用将依据您的个人意愿或法律的规定全部或部分的披露您的个人信息： (a)经您事先同意，向第三方披露； (b)为提供您所要求的产品和服务，而必须和第三方分享您的个人信息； (c)根据法律的有关规定，或者行政或司法机构的要求，向第三方或者行政、司法机构披露； (d)如您出现违反中国有关法律、法规或者本应用服务协议或相关规则的情况，需要向4.第三方披露； (e)如您是适格的知识产权投诉人并已提起投诉，应被投诉人要求，向被投诉人披露，以便双方处理可能的权利纠纷； (f)在本应用平台上创建的某一交易中，如交易任何一方履行或部分履行了交易义务并提出信息披露请求的，本应用有权决定向该用户提供其交易对方的联络方式等必要信息，以促成交易的完成或纠纷的解决。 (g)其它本应用根据法律、法规或者网站政策认为合适的披露。 5.信息存储和交换 本应用收集的有关您的信息和资料将保存在本应用及（或）其关联公司的服务器上，这些信息和资料可能传送至您所在国家、地区或本应用收集信息和资料所在地的境外并在境外被访问、存储和展示。 6.Cookie的使用 (a)在您未拒绝接受cookies的情况下，本应用会在您的计算机上设定或取用cookies ，以便您能登录或使用依赖于cookies的本应用平台服务或功能。本应用使用cookies可为您提供更加周到的个性化服务，包括推广服务。 (b)您有权选择接受或拒绝接受cookies。您可以通过修改浏览器设置的方式拒绝接受cookies。但如果您选择拒绝接受cookies，则您可能无法登录或使用依赖于cookies的本应用网络服务或功能。 (c)通过本应用所设cookies所取得的有关信息，将适用本政策。 7.信息安全 (a)本应用帐号均有安全保护功能，请妥善保管您的用户名及密码信息。本应用将通过对用户密码进行加密等安全措施确保您的信息不丢失，不被滥用和变造。尽管有前述安全措施，但同时也请您注意在信息网络上不存在“完善的安全措施”。","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"送祝福语APP 隐私声明","slug":"categories/Android/送祝福语APP","date":"2019-09-10T14:22:22.000Z","updated":"2021-09-01T05:10:06.387Z","comments":true,"path":"2019/09/10/categories/Android/送祝福语APP/","link":"","permalink":"https://visen123.github.io/2019/09/10/categories/Android/%E9%80%81%E7%A5%9D%E7%A6%8F%E8%AF%ADAPP/","excerpt":"","text":"尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，”送祝福语”会按照本隐私权政策的规定使用和披露您的个人信息。但”送祝福语”将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，”送祝福语”不会将这些信息对外披露或向第三方提供。”送祝福语”会不时更新本隐私权政策。您在同意”送祝福语”服务使用协议之时，即视为您已经同意本隐私权政策全部内容。本隐私权政策属于”送祝福语”服务使用协议不可分割的一部分。 1.适用范围 (1)在您使用本应用网络服务，或访问本应用平台网页时，本应用自动接收并记录的您的浏览器； (2)本应用通过合法途径从商业伙伴处取得的用户个人数据。 您了解并同意，以下信息不适用本隐私权政策： (3)您在使用本应用平台提供的搜索服务时输入的关键字信息； (4)本应用收集到的您在本应用发布的有关信息数据，包括但不限于参与活动、成交信息及评价详情； (5)违反法律规定或违反本应用规则行为及本应用已对您采取的措施。 2.信息使用 (a)本应用不会向任何无关第三方提供、出售、出租、分享或交易您的个人信息，除非事先得到您的许可，或该第三方和本应用（含本应用关联公司）单独或共同为您提供服务，且在该服务结束后，其将被禁止访问包括其以前能够访问的所有这些资料。 (b)本应用亦不允许任何第三方以任何手段收集、编辑、出售或者无偿传播您的个人信息。任何本应用平台用户如从事上述活动，一经发现，本应用有权立即终止与该用户的服务协议。 (c)为服务用户的目的，本应用可能通过使用您的个人信息，向您提供您感兴趣的信息，包括但不限于向您发出产品和服务信息，或者与本应用合作伙伴共享信息以便他们向您发送有关其产品和服务的信息（后者需要您的事先同意）。 3.信息披露 在如下情况下，本应用将依据您的个人意愿或法律的规定全部或部分的披露您的个人信息： (a)经您事先同意，向第三方披露； (b)为提供您所要求的产品和服务，而必须和第三方分享您的个人信息； (c)根据法律的有关规定，或者行政或司法机构的要求，向第三方或者行政、司法机构披露； (d)如您出现违反中国有关法律、法规或者本应用服务协议或相关规则的情况，需要向4.第三方披露； (e)如您是适格的知识产权投诉人并已提起投诉，应被投诉人要求，向被投诉人披露，以便双方处理可能的权利纠纷； (f)在本应用平台上创建的某一交易中，如交易任何一方履行或部分履行了交易义务并提出信息披露请求的，本应用有权决定向该用户提供其交易对方的联络方式等必要信息，以促成交易的完成或纠纷的解决。 (g)其它本应用根据法律、法规或者网站政策认为合适的披露。 5.信息存储和交换 本应用收集的有关您的信息和资料将保存在本应用及（或）其关联公司的服务器上，这些信息和资料可能传送至您所在国家、地区或本应用收集信息和资料所在地的境外并在境外被访问、存储和展示。 6.Cookie的使用 (a)在您未拒绝接受cookies的情况下，本应用会在您的计算机上设定或取用cookies ，以便您能登录或使用依赖于cookies的本应用平台服务或功能。本应用使用cookies可为您提供更加周到的个性化服务，包括推广服务。 (b)您有权选择接受或拒绝接受cookies。您可以通过修改浏览器设置的方式拒绝接受cookies。但如果您选择拒绝接受cookies，则您可能无法登录或使用依赖于cookies的本应用网络服务或功能。 (c)通过本应用所设cookies所取得的有关信息，将适用本政策。 7.信息安全 (a)本应用帐号均有安全保护功能，请妥善保管您的用户名及密码信息。本应用将通过对用户密码进行加密等安全措施确保您的信息不丢失，不被滥用和变造。尽管有前述安全措施，但同时也请您注意在信息网络上不存在“完善的安全措施”。","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]}]}