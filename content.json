{"meta":{"title":"清风明月博客","subtitle":"瞧那片蓝天白云多美好呀","description":"欢迎你的到来","author":"清风明月","url":"https://Visen123.github.io"},"pages":[],"posts":[{"title":"Android开发工程师必备工具","slug":"categories/工具/Android开发工程师必备工具","date":"2021-09-02T10:00:13.000Z","updated":"2021-09-07T13:59:22.729Z","comments":true,"path":"2021/09/02/categories/工具/Android开发工程师必备工具/","link":"","permalink":"https://visen123.github.io/2021/09/02/categories/%E5%B7%A5%E5%85%B7/Android%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7/","excerpt":"","text":"1.Android StudioAndroid程序员的吃饭工具，可以说现在绝大部分的安卓项目都是跑在Android Studio上面的。Android Studio 是基于 IntelliJ IDEA 且适用于开发 Android 应用的官方集成开发环境 (IDE)，功能非常强大，使用体验相当好，从我的使用感觉来说比Visual Studio要好。 最新版本: 稳定版4.2.2(20210725记录)下载地址: https://developer.android.google.cn/studio2.必备的网站作为一名程序员，查看文档不可避免，遇到问题要懂得从文档中查找解决方法，也需要搜索下别人的解决方案，下面是安卓日常开发中打开频率最高的网站。 安卓开发指南，https://developer.android.google.cn/guideJava文档，https://docs.oracle.com/javase/8/docs/api/kotlin文档，https://www.kotlincn.net/开源项目查找，https://github.com/安卓源码在线查看，http://aospxref.com/编程问答，https://stackoverflow.com/在线画流程与UML图，https://www.processon.com/3.PxCookUI是安卓开发中必不可少的元素，如何将UI设计图完美地实现呢？有一种做法是UI将各个元素的距离标注出来的，然后开发者再将数值在布局中写入，以此来达到还原设计图稿的目的。但只要有了PxCook这个神器，UI会开心地蹦起来的，从此元素布局就是如此地简单。能标注每个元素的大小，能自动生成参考xml，如果安装了PhotoShop还能切图，UI设计师只要给一个psd文件就完成工作了，皆大欢喜。 下载地址：https://www.fancynode.com.cn/pxcook4.jd-gui在开发过程中如果想查看某个下载到的开源库里边源代码，那就需要一个反编译工具，大部分源码是以jar包的形式存在的，jd-gui就是一个强大的反编译工具，使用也很方便，直接把jar包拖入窗口即能看到源码。下载地址：http://java-decompiler.github.io/ 5.Total-Control手机投屏在调试过程中是一个相当便利的功能，如果在电脑上能直接操控调试的手机就方便许多了，不需要再到手机上点按钮走业务流程。Total-Control就是一个强大的投屏软件，能直接用鼠标操作手机，还能同时连接多部设备，非常实用。下载地址：http://tc.sigma-rt.com.cn/ 6.Visual Studio Code微软开源的一个文本编辑器，同时也可用以代码编辑，强大好用，也有插件拓展，适合用于平时快速打开和查看一些单独的代码文件下载地址：https://code.visualstudio.com/20210725注：这篇文章之前版本推荐的文本编辑器是notepad++,但是之前没发现notepad++软件的作者竟然在版本发布说明中夹带私货，对于xg的事情说三道四，详情可查看这里release7.8.9开始，希望大家以后不要再使用这个软件，以免助长notepad++作者的猖狂之志。我已卸载notepad++并且以后不再用。 7.Postman接口调试神器，支持GET,POST,PUT等各种HTTP操作，是用来测试后台接口相当实用的一个工具。下载地址：https://www.postman.com/downloads/ 8.SQLite Expert Personal安卓集成了一个轻量数据库SQLite,如果想要查看设备中生成的sqlite数据库数据，可以导出到电脑进行浏览，而SQLite Expert Personal就是一个免费的sqlite查看工具。下载地址：http://www.sqliteexpert.com/download.html 9.Typora一款界面简洁、功能强大的markdown编辑器，平时用以记录文档最合适不过。下载地址：https://www.typora.io/ 10.Xmind制作思维导图的工具，有结构层次地记录下一些想法或者是对业务流程的层次进行梳理，xmind的界面设计非常优秀，用起来很舒服。下载地址：https://www.xmind.cn/","categories":[{"name":"工具","slug":"工具","permalink":"https://visen123.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[],"keywords":[{"name":"工具","slug":"工具","permalink":"https://visen123.github.io/categories/%E5%B7%A5%E5%85%B7/"}]},{"title":"java后端技术","slug":"categories/后端/java后端技术","date":"2021-08-31T08:00:13.000Z","updated":"2021-08-31T15:29:58.387Z","comments":true,"path":"2021/08/31/categories/后端/java后端技术/","link":"","permalink":"https://visen123.github.io/2021/08/31/categories/%E5%90%8E%E7%AB%AF/java%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/","excerpt":"","text":"服务框架：Dubbo，zookeeper，Rest服务缓存：redis，ehcache消息中间件：ActiveMQ，kafka负责均衡：Nginx分布式文件：FastDFS安全框架：Apache shiro任务调度：quartz持久层框架：mybatis日志：log4j项目基础搭建。spring，springmvc，环境搭建：linux下，开发工具：eclipse。idea等服务器：tomcat，jetty等 目前系统主流搭建：Nginx+tomcat+mybatis+redis。针对不同的业务需求，我们会引用不同的技术。 这些主要定位于互联网企业架构 框架简介： 企业信息化系统基础功能和高效的代码生成工具，包括: 系统权限组件，数据权限组件，数据字典组件，核心工具组件，视图操作组件，工作流组件，代码生成等。采用分层设计，双重验证。提交数据安全编码，密码加密，访问验证，，数据权限验证、 平台简介： 是一个分布式的框架。提供项目模块化，服务化。热插拔的思想。高度封装安全性的java EE快速开发平台。 本身集成Dubbo服务管控，zookeeper注册中心。Redis分布式缓存技术。FastDFS分布式文件吸系统。ActiveMQ异步消息中间件，Nginx负责均衡等分布式技术。 使用maven做项目管理，项目模块化。提供项目的易开发性，扩展性。 以spring Framework为核心容器。SpringMVC为模型视图控制器，mybatis为数据访问层，Apache shiro为权限授权层。Ehcache对常用数据进行缓存。Activit为工作流引擎等。 前端集成bootstrap 框架。响应式 目前包括以下模块项目，后台系统管理系统。RestFull独立服务系统，Schedule定时调度系统，内容管理（CMS）系统，在线办公（OA）系统。我的待办（Task服务），我的收藏（bookmark服务） 提供了常用工具进行封装，包括日志工具、缓存工具、服务器端验证、数据字典、当前组织机构数据（用户、机构、区域）以及其它常用小工具等。另外 还提供一个强大的在线 代码生成 工具，此工具提供简单的单表、一对多、树结构功能的生成，如果对外观要求不是很高，生成的功能就可以用了。使用了基础框架，可以提高快速开发效 率。 内置功能(只列了一部分功能) 1.用户管理：用户是系统操作者，该功能主要完成系统用户配置。 2.机构管理：配置系统组织机构（公司、部门、小组），树结构展现，可随意调整上下级。 3.区域管理：系统城市区域模型，如：国家、省市、地市、区县的维护。 4.菜单管理：配置系统菜单，操作权限，按钮权限标识等。 5.角色管理：角色菜单权限分配、设置角色按机构进行数据范围权限划分。 6.字典管理：对系统中经常使用的一些较为固定的数据进行维护，如：是否、男女、类别、级别等。 7.操作日志：系统正常操作日志记录和查询；系统异常信息日志记录和查询。 8.连接池监视：监视当期系统数据库连接池状态，可进行分析SQL找出系统性能瓶颈。 9.工作流引擎：实现业务工单流转、在线流程设计器。 开发工具 1.Eclipse IDE：采用Maven项目管理，模块化。 2.代码生成：通过界面方式简单配置，自动生成相应代码，目前包括三种生成方式（增删改查）：单表、一对多、树结构。生成后的代码如果不需要注意美观程度，生成后即可用。 技术选型（只列了一部分技术） 1、后端 服务框架：Dubbo、zookeeper、Rest服务 缓存：Redis、ehcache 消息中间件：ActiveMQ 负载均衡：Nginx 分布式文件：FastDFS 数据库连接池：Alibaba Druid 1.0 核心框架：Spring framework 安全框架：Apache Shiro 1.2 视图框架：Spring MVC 4.0 服务端验证：Hibernate Validator 5.1 布局框架：SiteMesh 2.4 工作流引擎：Activiti 5.15 任务调度：quartz 1.8.5 持久层框架：MyBatis 3.2 日志管理：SLF4J 1.7、Log4j 工具类：Apache Commons、Jackson 2.2、Xstream 1.4、Dozer 5.3、POI 2、前端 JS框架：JQuery 1.9。 CSS框架： Bootstrap 4 metronic 客户端验证：JQuery Validation Plugin。 富文本：CKEcitor 文件管理：CKFinder 动态页签：Jerichotab 数据表格：jqGrid 对话框：jQuery jBox 树结构控件：jQuery zTree 其他组件：Bootstrap 4 metronic 3、支持 服务器中间件：Tomcat 6、7、Jboss 7、WebLogic 10、WebSphere 8 数据库支持：目前仅提供mysql数据库的支持，但不限于数据库，下个版本升级多数据源切换和数据库读写分离： 如：Oracle、SqlServer、H2等 支持开发环境：Eclipse、MyEclipse、Ras、Idea等","categories":[{"name":"后端","slug":"后端","permalink":"https://visen123.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"后端","slug":"后端","permalink":"https://visen123.github.io/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"WEB开发技术 知识点总结","slug":"categories/前端/WEB开发技术","date":"2021-08-26T07:00:16.000Z","updated":"2021-08-31T15:30:02.311Z","comments":true,"path":"2021/08/26/categories/前端/WEB开发技术/","link":"","permalink":"https://visen123.github.io/2021/08/26/categories/%E5%89%8D%E7%AB%AF/WEB%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/","excerpt":"","text":"WEB开发技术 知识点总结 第一章：（填空判断） 1、什么是WWW WWW是World Wide Web的缩写，中文译名“万维网”。 Web是Internet提供的一种服务，是基于Internet、采用Internet协议的一种体系结构。 2、Web三要素: 统一资源定位（URL）：解决网上资源在何处的问题。 资源访问方式（HTTP）：解决用什么方法访问资源的问题。 超链接：提供在资源之间自由访问的手段。 3、什么是URL （Universal Resource Locator）? URL中文名为“统一资源定位器”。每一个站点及站点上的每个网页都有一个唯一的地址，向浏览器输入URL，可以访问URL指出的Web网页。 URL的基本结构为： 通信协议://服务器名称[:通信端口号]/文件夹…/文件名 http://www.163.com:2100/bbs/index.htm 4、HTTP 是在Internet上传送超文本的协议，它是运行在TCP/IP集之上的应用协议。简单地说，HTTP就是专门为WWW设计的协议。 5、C/S模式(Client/Server) C/S计算模式将应用一分为二：前端是客户机，几乎所有的应用逻辑都在客户端进行和表达，客户机完成与用户的交互任务。后端是服务器，它负责后台数据的查询和管理、大规模的计算等服务。通常客户端的任务比较繁重，称作“肥”客户端，而服务器端的任务较轻，称作“瘦”服务器。 C/s模式 6、B/S模式 B/S模式是一种基于Web的协同计算模式，是一种三层架构的瘦客户机/肥服务器的计算模式。 第一层为客户端表示层，客户层只保留一个Web浏览器，不存放任何应用程序，其运行代码可以从位于第二层Web服务器下载到本地的浏览器中执行，几乎不需要任何管理工作。第二层是应用服务器层，由一台或多台服务器（Web服务器也位于这一层）组成，处理应用中的所有业务逻辑，包括对数据库的访问等工作，该层具有良好的可扩充性，可以随着应用的需要任意增加服务的数目。第三层是数据中心层，主要由数据库系统组成。B/s模式 7、Web服务器端开发技术 CGI技术 JSP(Java Server Pages)技术 ASP(Active Server Pages)与ASP.NET技术 PHP(Personal Homepage Tools)技术、ASP.NET、PHP技术 8、Web客户端开发技术 HTML、CSS、脚本、XML/XHTML/Ajax/ JSON Javascript特性主要包括： 通过JavaScript的XMLHttpRequest对象实现异步请求与调用。 通过JavaScript对XML进行解析和处理。 通过JavaScript操作DOM来实现客户端的动态显示。 第二章：（简答题） 9、在选择网站主题的时候要注意以下3点： 主题小而内容精，创新的内容很重要； 题材最好是自己擅长的内容； 题材不要太滥，目标不要过高。 10、在选择网站名称的时候要注意以下3点： 名称要端正； 名称要易记； 名称要有特色。 11、设计网站的标志 站点标志作用类似于商标，它是网站特色和内涵的集中体现。 最常用和最简单的方式是用自己网站的名称作为标志，采用不同的字体、字母的变形或组合可以很容易制作好自己的标志。 12、在配色的时候要把握以下原则： 网站要有一个主色调； 要深浅搭配； 保持整个网站颜色的统一性。 13、在选择网站栏目的时候要注意以下4点： 紧扣网站主题； 设计一个最近更新或网站指南栏目； 设计一个可以互动交流的栏目； 设计一个下载或常见问题回答栏目。 14、设计网站的目录结构 不要将网站内容全部放在一个目录中，按菜单栏目内容建立子目录。 目录的层次不要太深，尽量用英文命名目录和文件名。 目录一般不超过3层。目录路径过深，跳转的URL地址就会变长，会增加页面链接的复杂性。 15、Web站点的链接结构有三种基本方式： 1）树状链接结构：首链接指向以及页面，一级页面链接指向二级页面。用户可以一级级进入，一级级退出。 2）星状链接结构：结构中的每个页面相互之间都直接建立了连接。 3）混合结构：首页和一级页面之间用星形链接结构，一级和二级、二级和三级页面之间均采用树形结构。 16、配色原则 对于网站的色彩处理原则应该是“总体协调，局部对比”。 三原色：红、绿、蓝 （2）色彩的特征 色调：表现色彩的种类； 亮度：表现色彩的明亮程度； 饱和度：表现色彩的鲜艳程度。 （3）色彩的分类 按照色彩对人们心理的影响可以进行以下分类。 暖色系：红、橙、橙黄、黄等色彩让人感觉温馨、热情； 中性系：黄绿、绿等色彩让人觉得舒适、和谐； 冷色系：青绿、蓝绿、蓝等色彩让人觉得宁静、高雅。 第三章： 17、 什么是IIS？ Internet 信息服务（Internet Informationn Server，IIS）是一组Windows操作系统组件，此组件可以使公司很方便的创建自己的Web服务器、FTP服务器以及简单的SMTP和NNTP服务器，很方便地将信息和业务应用程序发布到 Web中。 18、 什么是 Tomcat Tomcat是当前使用最为广泛的Servlet/JSP服务器。它是由JavaSoft和Apache开发团队合作计划的产品，被Sun公司作为官方推荐的servlet和jsp容器。具有运行稳定，性能可靠，免费的特点，是学习Web开发的最佳选择。 19、 什么是Apache Apache是使用最广的Web服务器之一，它可以运行在几乎所有广泛使用的计算机平台上，以高效、稳定、安全、免费而著称，60%的Web服务器采用Apache。用户可以从Apache网站下载Apache服务器软件。 第四章： 20、HTML5中：&lt;meta charset=“gb2312”/ 21、HTML5的声明： 22、标签：1）…：定义文档标题。编写每个网页时，都应该指定一个标题，显示在浏览器标题栏上。2）...：用于在页面中加入脚本程序。语法格式：...。3）：用于为页面上所有链接规定默认地址或默认目标。语法格式：&lt;base href=”基准地址”target=”目标窗口名称”&gt;…。4）：显示该文档和其他文档之间的链接关系。例如：。5）：在标签中可以含有任意数量的标签。该标签用于在文档中嵌入样式表单，常称为内部样式。6）meta标签–head区的一个辅助性标签。提供的信息是用户不可见的，用于包含于文档相关的信息。Meta标签常见的两种属性：http-equiv属性和name属性。 23、标题文字标记：用来标示页面中的标题文字，被标示的文字将以粗体形式显示。作为标题的文字(其中n=1,2.……6） 24、段落标记：① 段落可以以段落为单位设置文字的对齐方式，形式如下：段落文字 ② 换行标记 是个空标签，用于另起一行，中间不插入空行。③ 预格式化标记HTML文档会忽略文本中的空格、换行符等，而使用标签可以保留它们，按照原样显示文本，实现“所见即所得”的效果。形式如下：这里是多行文本 25、插入水平线：有时为了较明显地划分上下各部分的内容，在文档中间加入一些水平线，使用形式如下： 26、加入图像：要在网页的某个位置放置一个图像，使用标签。 27、表格标记：要在网页中插入一个表格，需要用到一组标签，分别表示整个表格的属性、表格中一行的属性和表格中一列的属性。定义表格的有关标签如下：…：定义表格 …：定义表行 …：定义列标题，多数浏览器显示为粗体居中文字 …：定义表格数据单元 28、表格结构： 表格标题 第1列标题 第2列标题 列内容 列内容 29、表格的另一种定义方法： …定义表格的表头 …对HTML中表格中的主体内容进行分组 …定义表格的页脚（脚注或表注） 30、无序列表标记… 格式： 列表内容列表内容 … Disk:加重符号是实心圆点（默认） Circle:加重符号是空心圆点 Square:加重符号是实心方块 31、有序列表… 列表内容列表内容… 这里的li，可以有value属性，即把这一项的列表编号制定为特定值。 32、 定义列表标记… 术语术语的定义1… 术语 术语的定义2 dl有可选属性compact，使用该属性使术语和定义在同一行显示 33、超链接标记： 超链接显示内容 作用：单击“超链接显示内容”将跳转到“要连接到的URL” 处。1）链接到其他站点 新浪网 2）链接到本站内的某一页面 公司简介 3）图像链接 4）链接到电子信箱 电子信箱地址 5）在新窗口打开链接 新浪网 6）链接到本页的其他地方书签位置文字超链接显示内容 7）热点链接： 热点链接也叫图像映射，属于另一种形式的超链接。它是一个能对链接指示做出反应的图形或文本框，单击该图形或文本框的已定义区域，可跳转到与该区域相连接的目标。存在两种创建图像映射的方法：在标签中使用标签和标签① 标签负责为图像创建映射，紧跟在标签后；② 标签负责定义可单击的热点的边界形状和坐标，area 元素始终嵌套在 标签内部。在标签中使用标签 34、表单使用的一般形式为：&lt;form action=“URL” method=“get/post” autocomplete=on|off&gt;表单域的定义 1)输入标记… ① 文本框text和密码框password ② 单选框和复选框 单选框教师学生医生 复选框游泳唱歌上网 2) 列表框标记… 3) 文本输入区标记 初始文本 4)标签 姓名 35、文字移动（走马灯） 移动的文字 scroll:不断的从一边移到另一边 slide:从一边移到另一边，然后停止 alternate:来回移动 36、div&gt;标签和标签 …：块元素，用来设置字、图、表格等的摆放位置。 …：对行内元素进行分组，以便通过样式对它们进行格式化。 第六章 37、浮动窗口… 可以将一个HTML文档嵌入到另一个HTML中显示。 38、CSS的定义：1. CSS的定义是由三个部分构成： ①选择符（selector）:样式要套用的对象 ②属性（properties） ③属性的取值（value） 2. 基本格式如下： selector{property:value}（选择符{属性:值}）例如：h1{color:blue} 3. 如果属性的值是多个单词，必须在值上加引号，比如字体的名称经常是几个单词的组合：p{font-family: “sans serif”} 39、CSS中的选择符： CSS中有六种选择符：HTML标记、具有上下文关系的HTML标记、用户自定义类选择符、用户定义的ID选择符、虚类、虚元素。 1. HTML标记类选择符 格式：HTML标记 {属性:值} 如：select, textarea {font-size:13px} 2. 具有上下文关系的HTML标记类选择符 如：div p{color:blue} 3. 用户定义的类选择符 ① 格式：HTML标记.类名{属性:值} 使用类选择符能够把相同的元素分类定义不同的样式，如： p.right {text-align: right} p.center {text-align: center} 40、ID选择符 定义ID选择符要在ID名称前加上一个“#”号。 ① HTML标记#IDname{} 例：p#intro{ font-size:110%; font-weight:bold; color:#0000ff; background-color:transparent } ② #IDname{} 例： #intro { font-size:110%; font-weight:bold; color:#0000ff; background-color:transparent } 41、优先级： ID选择符 &gt; 类选择符 &gt; HTML标记选择符 如果想超越这三者之间的关系，可以用!important提升样式表的优先权。 42、样式表应用 有四种方法将样式表的功能应用到Web页面中： 1. 直接定义HTML标记中的style属性 2. 定义内部样式表 3. 嵌入外部样式表 4. 链接外部样式表 43、直接定义HTML标记中的style属性 &lt;HTML标记名称 style=“属性1：值1；属性2：值2；…”&gt; 例如： 这是一个段落 （这个段落颜色为蓝色，左边距为20象素） 44、定义内部样式表 &lt;!— hr {color: sienna} p {margin-left: 20px} body {background-image: url(“images/back40.gif”)} –&gt; 45、 嵌入外部样式表 46、 链接外部样式表 rel=“stylesheet”是指在页面中使用这个外部的样式表。 type=“text/css”是指文件的类型是样式表文本。 href=“mystyle.css”是文件所在的位置。 media表示使用样式表的网页将用什么媒体输出。 47、 48、 49、 50、文本属性① 文本修饰（text-decoration） ：在文本中添加underline（下划线）、overl（上划线）、line-through（中划线）、blink（闪烁效果）、none（不显示上述任何效果）。 基本格式：text-decoration：参数 ② 行高（line-height）: 设置文本所在行的行高。默认为normal,行间距离取值：①不带单位的数字，以1为基数，相当于比例关系的100%；②带长度单位的数字；③比例关系。 基本格式：line-height：行间距离 ③ 文本横向排列（text-align）: 可以控制文本的水平对齐。left（左对齐）、right（右对齐）、center（居中）、justify（相当于左右对齐）。 基本格式：text-align：参数 4 文本缩进（text-indent）: 设置文本块中首行的缩进。 基本格式：text-indent：length 其中，length属性值可以是百分比数字，也可以是由浮点数和单位标识符组成的长度值，允许负值。 第七章 51、数组 数组就是由一组数值按照顺序排列在一起，放在同一个变量中，而每个数值都可以利用索引（Index）来得到数组中所存储的信息。 注：JavaScript中，数组的长度都是变长的。 52、JavaScript有6种数据类型：主要的类型有Number、String、Object以及Boolean。其他两种类型为Null和Undefined。 53、String数据类型① 字符串是用单引号或双引号来说明的。 var s1=”The cow jumped over the moon.” var sColor=“blue”； var sColor=‘blue’; ② String类型是唯一没有固定大小的原始类型。可以用字符串存储零个或多个统一编码的字符。③ 转义字符。如：\\n，\\t，\\b，\\等。 54、数值数据类型1. 整数可以以十进制、八进制和十六进制来表示。 ① 八进制整数用前导“0”指明。 ② 十六进制整数用前导“0x”指明，其中“x”大小写均可。 定义浮点值，必须包括小数点和小数点后的一位数字。对于非常大或非常小的数，可用科学计数法表示。 55、Boolean类型 有true和false两个值。分别表示逻辑真和逻辑假。 56、字符串运算符 字符串运算符主要是运算符“+”和它的变形形式“+=”。 例如：var result=5+“5”–“55” var result=true +“56”–“true56” 57、JavaScript 函数 函数定义 function函数名（参数表）{ 语句块；} function 函数名（参数表）{ 语句块； return [表达式]；} return语句的功能是当调用函数时返回值。 58、JavaScript的常用函数 1. eval()函数 eval()函数可以对以字符串形式表示的任意有效的JavaScript代码求值。 2、 parseInt()函数和parseFloat()函数 parseInt()函数功能是从一个字符串中提出一个整数，如果遇到字符串中除了数字以外的字符，parseInt()就停止转换，返回已有的结果。 如果第一个字符不是数字，parseInt()就返回“NaN”值。 语法：parseInt(string, [radix]) 59、JavaScript的事件 超级链接事件主要包括： Click, 浏览器事件主要包括：各种元素 Load, Unload 等 60、单击事件 鼠标单击事件是最常见的事件，语法非常简单： οnclick=函数或是处理语句 61、onchange事件 onchange事件是当某个HTML元素的内容改变的时候发生的事件 。 οnchange= 处理函数或是处理语句 （onselect事件是当某个HTML元素的内容被选中的时候发生的事件 。 onfocus事件是当光标落在某个HTML元素，使它得到焦点时候发生的事件 。 onblur事件是某个HTML元素失去焦点的时候发生的事件。） 62、JavaScript的对象 JavaScript中的对象是由属性和方法两个基本的元素构成的。 在JavaScript中使用一个对象可采用以下三种方式： ① 引用JavaScript内置对象； ② 用户自定义对象； ③ 引用浏览器对象。 63、必考 JavaScript内置对象 时间对象（Date对象） 时间对象使用前必须先声明，如：var cur=new Date() 注意Date()的首字母必须大写。 64、Math对象 Math对象可以用来处理各种数学运算。Math对象的内置方法定义了各种数学运算和可以直接调用的Math对象的方法。特点：静态对象，不需实例化。 65、 String对象 一般利用String对象提供的函数来处理字符串。 [var] String对象实例名=字符串值 String对字符串的处理主要提供了下列方法： ① charAt(idx): 返回指定位置处的字符 ② indexOf(str): 返回指定子字符串的位置，从左到右 ④ toLowerCase( ): 将字符串中的字符全部转化成小写 ⑤ toUpperCase( ): 将字符串中的字符全部转化成大写 66、Array对象 特点：可变长。 67、 定时器必考 window对象 ⑤ alert(message)：用于弹出一个消息对话框。⑥ confirm(message)：用于弹出一个可以确认的对话框，提供了OK和Cancle两种选择。结果返回布尔值。 ⑦ prompt(message, defaultInput)：用于弹出一个可以输入文字的对话框。 ⑧ setTimeout(expression,time)：设置暂停，等待多少毫秒执行某代码。 clearTimeout(timer)：取消原来的时间控制器内的时间设置。 ⑨ setInterval(expression,time)：以指定的时间间隔重复执行某一功能。 clearInterval(timer) 68、document对象 常用属性: 1）title, lastModified, location 2）forms:数组，保存网页中所有的表单 常用方法： 1）write(string):向网页中输出文字 2）writeln(string):向网页中输出一行文字 69、知道怎样访问表单中的一个标题 form对象 主要属性： elements 元素数组，存储表单中的所有控件对象。对表单中的属性域，可以通过“表单名.elements[下标]”来访问，也可以通过“表单名.控件名”来访问，例如myform.elements[0]、myform.account 70、代码例子 例7-28：在网页中插入一张图片，使图片具有闪烁效果。if(angel.style.visibility==”visible”)angel.style.visibility=”hidden”;else angel.style.visibility=”visible”; 例7-29：在网页中插入一张图片，使图片产生水中倒影效果。例7-30：在网页中屏蔽鼠标右键，使网页内容不能被选择、拖拽、复制等。 例7-31：在网页中显示距离新年的倒计时。 例7-32 走马灯效果。 例7-33： 在标题栏动态显示时间。 例7-34：产生随即验证码。 第八章： 71、Ajax的定义 Ajax (Asynchronous JavaScript and XML)不是一个新的技术，事实上，它是一些旧有的成熟的技术以一种全新的更加强大的方式整合在一起","categories":[{"name":"前端","slug":"前端","permalink":"https://visen123.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://visen123.github.io/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"Android Jetpack架构组件Navigation管理Fragment框架","slug":"categories/Android/Android-Jetpack架构组件Navigation管理Fragment框架","date":"2021-08-21T13:26:42.000Z","updated":"2021-09-01T04:47:49.293Z","comments":true,"path":"2021/08/21/categories/Android/Android-Jetpack架构组件Navigation管理Fragment框架/","link":"","permalink":"https://visen123.github.io/2021/08/21/categories/Android/Android-Jetpack%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6Navigation%E7%AE%A1%E7%90%86Fragment%E6%A1%86%E6%9E%B6/","excerpt":"","text":"Navigation目前仅AndroidStudio 3.2以上版本支持，如果您的版本不足3.2， 下载AndroidStudio3.2以上版本。官网下载地址：https://developer.android.google.cn/studio/ 快速开发， 组件可单独使用，也可以同时工作。 消除样板 ，让代码Android 架构Jetpack管理乏味的活动事件，比如后台任务、导航和生命周期管理。这样你可以专注于让你的app更棒的东西，构建高质量、健壮的app 基于现代设计实践，Android Jetpack组件可以减少崩溃和内存泄漏，且向后兼容。接下来讲述Navigation的使用以及如何管理多个Fragment等 项目builde.gradle文件需配置： implementation “androidx.navigation:navigation-fragment-ktx:2.3.0-alpha05”implementation “androidx.navigation:navigation-ui-ktx:2.3.0-alpha05” 1.创建MainActivity和布局文件activity_navigation布局里配置: activity_navigation.xml布局配置： &lt;com.google.android.material.bottomnavigation.BottomNavigationView android:id=”@+id/bottom_nav_view” android:layout_width=”match_parent” android:layout_height=”wrap_content” app:labelVisibilityMode=”labeled” app:menu=”@menu/bottom_nav_menu” /&gt; MainActivity里配置： val host: NavHostFragment = supportFragmentManager .findFragmentById(R.id.my_nav_host_fragment) as NavHostFragment? ?: return val navController = host.navController val bottomNav = findViewById(R.id.bottom_nav_view) bottomNav?.setupWithNavController(navController) 2、新建HomeFragment、FlowStepFragment、FlowStepFragment、SettingsFragment、DeepLinkFragment在Fragment片段里跳片段方法 方法1： view.findViewById(R.id.navigate_destination_button).setOnClickListener( Navigation.createNavigateOnClickListener(R.id.next_action) ) 方法2： view.findViewById(R.id.navigate_destination_button)?.setOnClickListener { findNavController().navigate(R.id.flow_step_one_dest, null, null) } 3、在res里新建文件夹navigation 类型选择Navigation，然后在这个文件夹里创建mobile_navigation.xml 在mobile_navigation.xml里写入要跳转的各个片段Fragment及要传递的参数： startDestination默认第一个跳的片段iddestination跳到另外一个片段idaction 隐式跳转 ，argType传递参数类型，defaultValue传递参数值 &lt;!--todo destination隐式跳转到Fragement id=flow_step_one_dest --&gt; &lt;action android:id=&quot;@+id/next_action&quot; app:destination=&quot;@+id/flow_step_one_dest&quot; app:enterAnim=&quot;@anim/slide_in_right&quot; app:exitAnim=&quot;@anim/slide_out_left&quot; app:popEnterAnim=&quot;@anim/slide_in_left&quot; app:popExitAnim=&quot;@anim/slide_out_right&quot; /&gt; &lt;action android:id=&quot;@+id/next_action&quot; app:destination=&quot;@+id/flow_step_two_dest&quot;&gt; &lt;/action&gt; &lt;argument android:name=&quot;flowStepNumber&quot; app:argType=&quot;integer&quot; android:defaultValue=&quot;2&quot;/&gt; &lt;action android:id=&quot;@+id/next_action&quot; app:destination=&quot;@+id/settings_dest&quot;&gt; &lt;/action&gt; &lt;fragment android:id=&quot;@+id/deeplink_dest&quot; android:name=&quot;com.my.navigation.DeepLinkFragment&quot; android:label=&quot;@string/deeplink&quot; tools:layout=&quot;@layout/deeplink_fragment&quot;&gt; &lt;argument android:name=&quot;myarg&quot; android:defaultValue=&quot;Android!&quot;/&gt; &lt;/fragment&gt;","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"创建和运行一个应用界面","slug":"categories/HarmonyOS/创建和运行一个应用界面","date":"2021-08-09T12:26:42.000Z","updated":"2021-09-03T07:00:58.641Z","comments":true,"path":"2021/08/09/categories/HarmonyOS/创建和运行一个应用界面/","link":"","permalink":"https://visen123.github.io/2021/08/09/categories/HarmonyOS/%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E7%95%8C%E9%9D%A2/","excerpt":"","text":"DevEco Studio开发环境配置完成后，可以通过运行HelloWorld工程来验证环境设置是否正确。以Phone工程为例，在Phone的远程模拟器中运行该工程。 创建一个新工程打开DevEco Studio，在欢迎页点击Create HarmonyOS Project，创建一个新工程。根据工程创建向导，选择需要的Ability工程模板，然后点击Next。关于工程模板的介绍和支持的设备类型，请参考支持的设备模板和编程语言。 填写工程相关信息，Device Type选择Phone，其他保持默认值即可，点击Finish。关于各个参数的详细介绍，请参考创建一个新的工程。 工程创建完成后，DevEco Studio会自动进行工程的同步，同步成功如下图所示。 使用模拟器运行HelloWorldDevEco Studio提供远程模拟器和本地模拟器，本示例以远程模拟器为例进行说明。关于本地模拟器的使用请参考使用Local Emulator运行应用（即将上线、敬请期待）。 在DevEco Studio菜单栏，点击Tools &gt; Device Manager。在Remote Emulator页签中点击Login，在浏览器中弹出华为开发者联盟帐号登录界面，请输入已实名认证的华为开发者联盟帐号的用户名和密码进行登录（查看远程模拟器登录常见问题）。说明推荐使用最新版本Chrome浏览器，如果使用Safari、360等其他浏览器，要取消阻止跨站跟踪和阻止所有Cookie功能。 登录后，请点击界面的允许按钮进行授权。 在设备列表中，选择Phone设备P40，并点击按钮，运行模拟器。点击DevEco Studio工具栏中的按钮运行工程，或使用默认快捷键Shift+F10（Mac为Control+R）运行工程。 DevEco Studio会启动应用的编译构建，完成后应用即可运行在模拟器上。已成功运行了第一个HarmonyOS应用，接下来，可以通过一个简单的DEMO工程示例，来详细了解HarmonyOS应用的开发过程，具体请参见HarmonyOS应用开发快速入门。","categories":[{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"https://visen123.github.io/categories/HarmonyOS/"}],"tags":[],"keywords":[{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"https://visen123.github.io/categories/HarmonyOS/"}]},{"title":"Android9.0无法加载图片及访问不了服务器问题","slug":"categories/Android/Android9.0无法加载图片及访问不了服务器问题","date":"2021-08-09T07:30:46.000Z","updated":"2021-09-01T04:47:49.324Z","comments":true,"path":"2021/08/09/categories/Android/Android9.0无法加载图片及访问不了服务器问题/","link":"","permalink":"https://visen123.github.io/2021/08/09/categories/Android/Android9.0%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87%E5%8F%8A%E8%AE%BF%E9%97%AE%E4%B8%8D%E4%BA%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%AE%E9%A2%98/","excerpt":"","text":"当在安卓9.0加载网络请求数据时，如果抛出如下异常： Cause (1 of 1): class java.io.IOException: Cleartext HTTP traffic to xxxx.xxxx.xxxx not permitted 这是因为Android 9.0 版本系统默认支持一个网络访问协议：Https协议的网络，所以不支持网络访问：Http协议的网络面对这样的问题，解决办法： 第一种办法在AndroidMainfest.xml清单文件 Application里增加代码:： android:usesCleartextTraffic=”true” 然后重新运行，就可以解决了访问不到服务器HTTP接口和图片加载的问题 第二种方案：在rec文件夹中创建一个xml文件夹，然后创建一个network-security-config.xml。xml文件代码如下： 然后在标签内添加以下代码： android:networkSecurityConfig=”@xml/network_security_config” 如果im还是登录不上去，推送也注册失败。是因为Android 9.0版本找不到http.client的类了。解决半部分，在AndroidMainfast.xml文件清单里再加一句如下代码：","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"使用可视化开发鸿蒙","slug":"categories/HarmonyOS/使用可视化开发鸿蒙","date":"2021-08-08T09:26:42.000Z","updated":"2021-09-03T14:57:58.541Z","comments":true,"path":"2021/08/08/categories/HarmonyOS/使用可视化开发鸿蒙/","link":"","permalink":"https://visen123.github.io/2021/08/08/categories/HarmonyOS/%E4%BD%BF%E7%94%A8%E5%8F%AF%E8%A7%86%E5%8C%96%E5%BC%80%E5%8F%91%E9%B8%BF%E8%92%99/","excerpt":"","text":"创建JS工程说明请使用DevEco Studio V2.2 Beta1及更高版本。 低代码开发功能仅适用于Phone设备的JS工程，且compileSdkVersion必须为6及以上。 打开DevEco Studio，创建一个新工程，选择支持Phone的JS模板，如Empty Ability(JS):点击放大 在工程配置向导中，Device Type只能选择Phone，其他参数根据实际需要设置即可，然后点击Finish等待工程同步完成。点击放大 创建第一个页面在Project窗口，选择工程中的“entry &gt; src &gt; main &gt; js &gt; default &gt; pages.index”，单击鼠标右键，选择“New &gt; JS Visual”。点击放大 勾选“Update compileSdkVersion”（若compilesSdk版本已升级，则不会出现该选项）。创建完成后，可以看到“entry &gt; src &gt; main &gt; supervisual&gt; default &gt; pages &gt; page &gt; page.visual”的文件目录结构如下： 删除工程运行默认的入口文件夹：删除“entry &gt; src &gt; main &gt; js&gt; default &gt; pages &gt; index”文件夹。操作后的工程结构目录如下： 第一个页面内有一个文本和一个按钮，通过Text和Button组件来实现。打开“page.visual”文件，选中画布中的组件，单击鼠标右键，选择Delete删除画布原有组件。选中画布，点击右侧属性样式栏中的样式图标（Flex），设置画布的JustifyContent样式为center，使得其子组件在主轴上居中显示；设置画布的AlignItems样式为center，使得其子组件在交叉轴上居中显示。操作如下所示：点击放大 选中UI Control中的Text组件，将其拖至中央画布区域。点击右侧属性样式栏中的属性图标（Properties），设置Text组件的Content属性为“Hello World”；点击右侧属性样式栏中的样式图标（Feature），设置组件的FontSize样式为60px，使得其文字放大；设置组件的TextAlign样式为center，使得组件文字居中显示。再选中画布上的Text组件，拖动放大。操作如下所示：点击放大 选中UI Control中的Button组件，将其拖至Text组件下面。点击右侧属性样式栏中的属性图标（Properties），设置Button组件的Value属性为“Next”，点击右侧属性样式栏中的样式图标（Feature），设置组件的FontSize样式为39px，使得其文字放大；再选中画布上Button组件，拖动放大。操作如下所示：点击放大 使用预览器或模拟器运行项目，效果如下图所示：点击放大 创建另一个页面在Project窗口，选择工程中的“entry &gt; src &gt; main &gt; js &gt; default &gt; pages.page”，单击鼠标右键，选择“New &gt; JS Visual”。创建后的page2.visual文件结构如下： 第二个页面上有一个文本，通过Text组件来实现。打开“page2.visual”文件，删除画布原有组件。选中画布，设置画布的JustifyContent样式为center，设置画布的AlignItems样式为center。操作如下所示：点击放大 选中Text组件拖至画布，设置Text组件的Content属性为“Hi there”，设置组件的FontSize样式为60px，设置组件的TextAlign样式为center，再选中画布上的Text组件，拖动放大。操作如下所示：点击放大 实现页面跳转在Project窗口，打开工程中的“entry &gt; src &gt; main &gt; js &gt; default &gt; pages &gt; page &gt; page.js”,，导入router模块，页面路由router根据页面的uri来找到目标页面，从而实现跳转。示例代码如下：import router from ‘@system.router’; export default { launch() { router.push ({ uri:’pages/page2/page2’, // 指定要跳转的页面 }) }}打开“page.visual”，选中画布上的Button组件，点击右侧属性样式栏中的事件图标（Events），鼠标点击Click事件的输入框，选择launch事件，操作示例如下图：点击放大 再次使用预览器或模拟器运行项目，效果如下图所示：点击放大 想要深入了解可视化开发的更多内容，请参见低代码开发。 恭喜你，至此已成功完成HarmonyOS快速入门-使用可视化开发。","categories":[{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"https://visen123.github.io/categories/HarmonyOS/"}],"tags":[],"keywords":[{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"https://visen123.github.io/categories/HarmonyOS/"}]},{"title":"使用JS语言开发鸿蒙","slug":"categories/HarmonyOS/使用JS语言开发鸿蒙","date":"2021-08-07T12:26:42.000Z","updated":"2021-09-07T13:57:38.166Z","comments":true,"path":"2021/08/07/categories/HarmonyOS/使用JS语言开发鸿蒙/","link":"","permalink":"https://visen123.github.io/2021/08/07/categories/HarmonyOS/%E4%BD%BF%E7%94%A8JS%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E9%B8%BF%E8%92%99/","excerpt":"","text":"编写第一个页面第一个页面内有一个文本和一个按钮，通过text和button组件来实现。在Project窗口，选择“entry &gt; src &gt; main &gt; js &gt; default &gt; pages.index”，打开“index.hml”文件，添加一个文本和一个按钮，示例代码如下： Hello World 打开“index.css”文件，设置文本和按钮的样式，示例代码如下： /* index.css */ .container { flex-direction: column; /* 设置容器内的项目纵向排列 */ justify-content: center; /* 设置项目位于容器主轴的中心 */ align-items: center; /* 项目在交叉轴居中 */ } /* 对class=\"text\"的组件设置样式 */ .text{ font-size: 42px; } /* 对class=\"button\"的组件设置样式 */ .button { width: 240px; height: 60px; background-color: #007dff; font-size: 30px; text-color: white; margin-top: 20px; } 使用预览器或模拟器运行项目，效果如下图所示： 创建另一个页面在Project窗口，打开“entry &gt; src &gt; main &gt; js &gt; default”，右键点击“pages.index”文件夹，选择“New &gt; JS Page”，命名为“details”，单击回车键。创建完成后，可以看到“pages.index”文件夹下的文件目录结构如： 打开“details.hml”文件，添加一个文本，示例代码如下： Hi there 打开“details.css”文件，设置文本的样式，示例代码如下： /* details.css */ .container { flex-direction: column; justify-content: center; align-items: center; } .text { font-size: 42px; text-align: center; } 实现页面跳转 打开第一个页面的“index.js”文件，导入router模块，页面路由router根据页面的uri来找到目标页面，从而实现跳转。示例代码如下： // index.js import router from '@system.router'; export default { launch() { router.push ({ uri:’pages/index/details/details’, // 指定要跳转的页面 }) }}再次使用预览器或模拟器运行项目，效果如下图所示：点击放大 恭喜你，至此已成功完成HarmonyOS快速入门-使用JS语言开发。","categories":[{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"https://visen123.github.io/categories/HarmonyOS/"}],"tags":[],"keywords":[{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"https://visen123.github.io/categories/HarmonyOS/"}]},{"title":"鸿蒙配置开发环境","slug":"categories/HarmonyOS/配置开发环境","date":"2021-08-06T08:00:16.000Z","updated":"2021-09-03T07:00:58.648Z","comments":true,"path":"2021/08/06/categories/HarmonyOS/配置开发环境/","link":"","permalink":"https://visen123.github.io/2021/08/06/categories/HarmonyOS/%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"","text":"下载&amp;更新HarmonyOS SDKDevEco Studio提供SDK Manager统一管理SDK及工具链，下载各种编程语言的SDK包时，SDK Manager会自动下载该SDK包依赖的工具链。SDK Manager提供多种编程语言的SDK包和工具链，具体说明请参考下表。类别 包名 说明 默认是否下载 参考 SDK Native C/C++语言SDK包。 x 《Native API参考》 JS JS语言SDK包。 √ 《JS API参考》 Java Java语言SDK包。 √ 《Java API参考》 SDK Tool Toolchains SDK工具链，HarmonyOS应用开发必备工具集，包括编译、打包、签名、数据库管理等工具的集合。 √ - Previewer HarmonyOS应用预览器，在开发过程中可以动态预览Phone、TV、Wearable、LiteWearable等设备的应用效果，支持JS和Java应用预览。 √ 使用预览器查看应用效果下载HarmonyOS SDK第一次使用DevEco Studio，需要下载HarmonyOS SDK及对应工具链。如果是非首次安装DevEco Stduio，SDK下载和更新方法请参考更新HarmonyOS SDK。 说明HarmonyOS SDK与OpenHarmony SDK不兼容，下载的HarmonyOS SDK并不适用于OpenHarmony工程。加载OpenHarmony SDK和开发OpenHarmony应用，请参考OpenHarmony使用指南。 运行已安装的DevEco Studio，首次使用，请选择Do not import settings，点击OK。进入配置向导页面，设置npm registry，DevEco Studio已预置对应的仓，直接点击Start using DevEco Studio进入下一步。说明 如果配置向导界面出现的是设置Set up HTTP Proxy界面，说明网络受限，请根据参考信息配置DevEco Studio代理、NPM代理和Gradle代理后，再下载HarmonyOS SDK。通过DevEco Studio向导指引开发者下载HarmonyOS SDK，默认情况下，SDK会下载到user目录下，也可以指定对应的存储路径，SDK存储路径不支持中文字符，然后点击Next。默认会下载最新版本的Java SDK、JS SDK、Previewer和Toolchains。在弹出的License Agreement窗口，点击Accept开始下载SDK。说明下载SDK过程中，如果出现下载JS SDK失败，提示“Install js dependencies failed.”，请根据JS SDK安装失败处理指导进行处理。 等待HarmonyOS SDK及工具下载完成，点击Finish，界面会进入到DevEco Studio欢迎页。 SDK默认只会下载最新版本的Java SDK、JS SDK、Previewer和Toolchains，点击上图欢迎页中的Configure（或图标） &gt; Settings，进入HarmonyOS SDK页面，可以下载其它组件，只需要勾选对应的组件包，然后点击Apply即可。 更新HarmonyOS SDK如果已经下载过HarmonyOS SDK，当存在新版本的SDK时，可以通过SDK Manager来更新对应的SDK。进入SDK Manager的方法： 在DevEco Studio欢迎页，点击Configure（或图标） &gt; Settings &gt; HarmonyOS SDK进入SDK Manager界面（macOS系统为Configure &gt; Preferences &gt; HarmonyOS SDK）。在DevEco Studio打开工程的情况下，点击Tools &gt; SDK Manager界面进入；或者点击Files &gt; Settings &gt; HarmonyOS SDK进入（macOS系统为DevEco Studio &gt; Preferences &gt; HarmonyOS SDK）。在SDK Manager中，勾选需要更新的SDK，然后点击Apply，然后在弹出的确认更新窗口，点击OK即可开始更新。 配置HDC工具环境变量HDC是为开发者提供HarmonyOS应用的调试工具，为方便使用HDC工具，请为HDC工具的端口号设置环境变量。Windows环境变量设置方法：在此电脑 &gt; 属性 &gt; 高级系统设置 &gt; 高级 &gt; 环境变量中，添加HDC端口变量。变量名为：HDC_SERVER_PORT，变量值设置为7035。 环境变量配置完成后，关闭并重启DevEco Studio。macOS环境变量设置方法：打开终端工具，执行以下命令，打开.bash_profile文件。vi ./.bash_profile点击字母“i”，进入Insert模式。输入以下内容，添加HDC_SERVER_PORT环境变量信息。HDC_SERVER_PORT=7035launchctl setenv HDC_SERVER_PORT $HDC_SERVER_PORTexport HDC_SERVER_PORT编辑完成后，点击“Esc”键，退出编辑模式，然后输入“:wq”，点击“Enter”按钮保存。执行以下命令，使配置的环境变量生效。source .bash_profile环境变量配置完成后，关闭并重启DevEco Studio。参考信息DevEco Studio开发环境需要依赖于网络环境，需要连接上网络才能确保工具的正常使用。 一般来说，如果使用的是个人或家庭网络，是不需要设置代理信息的；只有部分企业网络受限的情况下，才需要设置代理信息。 如果是第一次打开DevEco Studio，配置向导界面出现设置Set up HTTP Proxy界面，说明网络受限，可以通过配置代理的方式来解决，需要配置DevEco Studio代理、NPM代理和Gradle代理。 配置DevEco Studio代理启动DevEco Studio，配置向导进入Set up HTTP Proxy界面，勾选Manual proxy configuration，设置DevEco Studio的HTTP Proxy。说明如果非首次设置向导进入HTTP Proxy，可以通过如下方式进入HTTP Proxy配置界面： 在欢迎页点击Configure（或图标） &gt; Settings &gt; Appearance &amp; Behavior &gt; System Settings &gt; HTTP Proxy进入HTTP Proxy设置界面（Mac系统为Configure &gt; Preferences &gt; Appearance &amp; Behavior &gt; System Settings &gt; HTTP Proxy）。在打开了工程的情况下，可以点击File &gt; Settings &gt; Appearance &amp; Behavior &gt; System Settings &gt; HTTP Proxy进入HTTP Proxy设置界面（Mac系统为DevEco Studio &gt; Preferences &gt; Appearance &amp; Behavior &gt; System Settings &gt; HTTP Proxy）HTTP配置项，设置代理服务器信息。如果不清楚代理服务器信息，可以咨询你们的网络管理人员。Host name：代理服务器主机名或IP地址。Port number：代理服务器对应的端口号。No proxy for：不需要通过代理服务器访问的URL或者IP地址（地址之间用英文逗号分隔）。Proxy authentication配置项，如果代理服务器需要通过认证鉴权才能访问，则需要设置。否则，请跳过该配置项。Login：访问代理服务器的用户名。Password：访问代理服务器的密码。Remember：勾选，记住密码。 配置完成后，点击Check connection，输入网络地址（如：https://developer.harmonyos.com），检查网络连通性。提示“Connection successful”表示代理设置成功。点击Next: Configure npm继续设置NPM代理信息，请参考配置NPM代理。配置NPM代理通过DevEco Studio的设置向导设置NPM代理信息，代理信息将写入用户“users/用户名/”目录下的.npmrc文件。说明该向导只有第一次安装DevEco Studio才会出现。如果未出现该向导，可以直接在“users/用户名/”目录下的.npmrc文件中，添加代理配置信息。 npm registry：设置npm仓的地址信息，建议勾选。HTTP proxy：代理服务器信息，默认会与DevEco Studio的HTTP proxy设置项保持一致。Enable Https Proxy：同步设置HTTPS Proxy配置信息，建议勾选。 然后点击Start using DevEco Studio继续下一步操作。如果代理服务器需要认证（需要用户名和密码），请先根据如下指导配置代理服务器的用户名和密码信息，然后再下载HarmonyOS；否则，请跳过该操作，根据向导下载HarmonyOS SDK即可。 进入用户的users目录，打开.npmrc文件。修改npm代理信息，在proxy和https-proxy中，增加user和password字段，具体取值请以实际代理信息为准。示例如下所示：proxy=http://user:password@proxy.server.com:80https-proxy=http://user:password@proxy.server.com:80说明如果password中存在特殊字符，如@、#、*等符号，可能导致配置不生效，建议将特殊字符替换为ASCII码，并在ASCII码前加百分号%。常用符号替换为ASCII码对照表如下： !：%21@：%40#：%23￥：%24&amp;：%26*：%2A代理设置完成后，打开命令行工具，执行如下命令进行验证网络是否正常。npm info express执行结果如下图所示，则说明代理设置成功。 点击放大 网络设置完成后，根据DevEco Studio向导下载HarmonyOS SDK。设置Gradle代理打开“此电脑”，在文件夹地址栏中输入%userprofile%（Mac系统请点击前往 &gt; 个人），进入个人用户界面。点击放大 创建一个文件夹，命名为.gradle。如果已有.gradle文件夹，请跳过此操作。说明macOS系统创建.gradle文件夹前，请将系统设置为“显示隐藏文件”。 进入.gradle文件夹，新建一个文本文档，命名为gradle，并修改后缀为.properties。打开gradle.properties文件中，添加如下脚本，然后保存。其中代理服务器、端口、用户名、密码和不使用代理的域名，请根据实际代理情况进行修改。其中不使用代理的“nonProxyHosts”的配置间隔符是 “|”。systemProp.http.proxyHost=proxy.server.comsystemProp.http.proxyPort=8080systemProp.http.nonProxyHosts=.company.com|10.|100.*systemProp.http.proxyUser=userIdsystemProp.http.proxyPassword=passwordsystemProp.https.proxyHost=proxy.server.comsystemProp.https.proxyPort=8080systemProp.https.nonProxyHosts=.company.com|10.|100.*systemProp.https.proxyUser=userIdsystemProp.https.proxyPassword=password","categories":[{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"https://visen123.github.io/categories/HarmonyOS/"}],"tags":[],"keywords":[{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"https://visen123.github.io/categories/HarmonyOS/"}]},{"title":"使用Java语言开发鸿蒙","slug":"categories/HarmonyOS/使用Java语言开发鸿蒙","date":"2021-08-05T11:26:42.000Z","updated":"2021-09-03T14:55:38.251Z","comments":true,"path":"2021/08/05/categories/HarmonyOS/使用Java语言开发鸿蒙/","link":"","permalink":"https://visen123.github.io/2021/08/05/categories/HarmonyOS/%E4%BD%BF%E7%94%A8Java%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E9%B8%BF%E8%92%99/","excerpt":"","text":"使用Java语言开发更新时间: 2021-08-27 16:31编写第一个页面在Java UI框架中，提供了两种编写布局的方式：在XML中声明UI布局和在代码中创建布局。这两种方式创建出的布局没有本质差别，为了熟悉两种方式，我们将通过XML的方式编写第一个页面，通过代码的方式编写第二个页面。 在Project窗口，点击“entry &gt; src &gt; main &gt; resources &gt; base &gt; layout”，打开“ability_main.xml”文件。 （可选）在Project窗口，点击“entry &gt; src &gt; main &gt; resources &gt; base &gt; element”，打开“string.json”文件，可在此文件内声明所需引用的资源内容。关于取值为string类型的文本属性，可以直接设置文本字串，也可以引用string资源（推荐使用）。string.json的示例代码如下：{ “string”:[ { “name”:”entry_MainAbility”, “value”:”entry_MainAbility” }, { “name”:”mainability_description”, “value”:”Java_Empty Ability” }, { “name”:”mainability_HelloWorld”, “value”:”Hello World” }, { “name”:”button_Next”, “value”:”Next” } ]}第一个页面内有一个文本和一个按钮，使用DependentLayout布局，通过Text和Button组件来实现，其中vp和fp分别表示虚拟像素和字体像素。本次示例展示两个组件的显示文本分别采用直接设置文本字串、引用string资源（推荐使用）的方式。“ability_main.xml”的示例代码如下： 按钮的背景是蓝色胶囊样式，可以通过graphic目录下的XML文件来设置。右键点击“graphic”文件夹，选择“New &gt; File”，命名为“background_button.xml”，单击回车键。 “background_button.xml”的示例代码如下： 在layout目录下的“ability_main.xml”文件中，使用background_element=”$graphic:background_button”的方式引用“background_button.xml”文件： &lt;DependentLayout … 在XML文件中添加组件后，需要在Java代码中加载XML布局。在Project窗口，选择“entry &gt; src &gt; main &gt; java &gt; com.example.myapplication &gt; slice” ，打开“MainAbilitySlice.java”文件，使用setUIContent方法加载“ability_main.xml”布局。此外，运行代码前需采用import（可使用Alt+Enter快捷键）引入对应类，否则会产生报错提示。说明HarmonyOS提供了Ability和AbilitySlice两个基础类，一个有界面的Ability可以由一个或多个AbilitySlice构成，AbilitySlice主要用于承载单个页面的具体逻辑实现和界面UI，是应用显示、运行和跳转的最小单元。 本文档以同一个Ability内的两个AbilitySlice之间的跳转为例，如果开发者希望实现两个Ability之间的跳转，请参考不同Page间导航。 “MainAbilitySlice.java”的示例代码如下：//请根据实际工程/包名引入package com.example.myapplication.slice; import com.example.myapplication.ResourceTable; import ohos.aafwk.ability.AbilitySlice;import ohos.aafwk.content.Intent; public class MainAbilitySlice extends AbilitySlice { @Override public void onStart(Intent intent) { super.onStart(intent); super.setUIContent(ResourceTable.Layout_ability_main); // 加载layout目录下的XML布局 }}使用预览器或模拟器运行项目，效果如下图所示： 创建另一个页面在上一节中，我们用XML的方式编写了一个包含文本和按钮的页面。为了帮助开发者熟悉在代码中创建布局的方式，接下来我们使用代码的方式编写第二个页面。 在Project窗口，打开“entry &gt; src &gt; main &gt; java &gt; com.example.myapplication”，右键点击“slice”文件夹，选择“New &gt; Java Class”，命名为“SecondAbilitySlice”，单击回车键。第二个页面上有一个文本。打开“SecondAbilitySlice”文件，添加一个Text，示例代码如下：//请根据实际工程/包名引入package com.example.myapplication.slice; import ohos.aafwk.ability.AbilitySlice;import ohos.aafwk.content.Intent;import ohos.agp.colors.RgbColor;import ohos.agp.components.DependentLayout;import ohos.agp.components.Text;import ohos.agp.components.element.ShapeElement;import ohos.agp.utils.Color;import ohos.agp.components.DependentLayout.LayoutConfig; public class SecondAbilitySlice extends AbilitySlice { @Override public void onStart(Intent intent) { super.onStart(intent); // 声明布局 DependentLayout myLayout = new DependentLayout(this); // 设置布局宽高 myLayout.setWidth(LayoutConfig.MATCH_PARENT); myLayout.setHeight(LayoutConfig.MATCH_PARENT); // 设置布局背景为白色 ShapeElement background = new ShapeElement(); background.setRgbColor(new RgbColor(255, 255, 255)); myLayout.setBackground(background); // 创建一个文本 Text text = new Text(this); text.setText(&quot;Hi there&quot;); text.setWidth(LayoutConfig.MATCH_PARENT); text.setTextSize(100); text.setTextColor(Color.BLACK); // 设置文本的布局 DependentLayout.LayoutConfig textConfig = new DependentLayout.LayoutConfig(LayoutConfig.MATCH_CONTENT, LayoutConfig.MATCH_CONTENT); textConfig.addRule(LayoutConfig.CENTER_IN_PARENT); text.setLayoutConfig(textConfig); myLayout.addComponent(text); super.setUIContent(myLayout); &#125; }实现页面跳转打开第一个页面的“MainAbilitySlice.java”文件，添加按钮的响应逻辑，实现点击按钮跳转到下一页，示例代码如下：//请根据实际工程/包名引入package com.example.myapplication.slice; import com.example.myapplication.ResourceTable; import ohos.aafwk.ability.AbilitySlice;import ohos.aafwk.content.Intent;import ohos.agp.components.Button; public class MainAbilitySlice extends AbilitySlice { @Override public void onStart(Intent intent) { super.onStart(intent); super.setUIContent(ResourceTable.Layout_ability_main); Button button = (Button) findComponentById(ResourceTable.Id_button); // 点击按钮跳转至第二个页面 button.setClickedListener(listener -&gt; present(new SecondAbilitySlice(), new Intent())); &#125; }说明setClickedListener用于注册监听相关组件的点击事件，present用于实现页面间的导航。关于页面跳转的更多详细用法，可参考AbilitySlice间导航。 再次使用预览器或模拟器运行项目，效果如下图所示：点击放大 恭喜你，至此已成功完成HarmonyOS快速入门-使用JAVA语言开发。","categories":[{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"https://visen123.github.io/categories/HarmonyOS/"}],"tags":[],"keywords":[{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"https://visen123.github.io/categories/HarmonyOS/"}]},{"title":"HarmonyOS开发工具下载安装","slug":"categories/HarmonyOS/HarmonyOS开发工具下载安装","date":"2021-08-01T11:26:42.000Z","updated":"2021-09-03T07:00:58.664Z","comments":true,"path":"2021/08/01/categories/HarmonyOS/HarmonyOS开发工具下载安装/","link":"","permalink":"https://visen123.github.io/2021/08/01/categories/HarmonyOS/HarmonyOS%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85/","excerpt":"","text":"开发准备开始前请参考下载与安装软件、配置开发环境，完成DevEco Studio的安装和开发环境配置。DevEco Studio支持Windows和macOS系统，下面将针对两种操作系统的软件安装方式进行介绍。 Windows环境 运行环境要求 为保证DevEco Studio正常运行，建议电脑配置满足如下要求： 操作系统：Windows10 64位 内存：8GB及以上 硬盘：100GB及以上 分辨率：1280*800像素及以上 下载和安装DevEco Studio DevEco Studio的编译构建依赖JDK，DevEco Studio预置了Open JDK，版本为1.8，安装过程中会自动安装JDK。 进入HUAWEI DevEco Studio产品页，点击下载列表后的按钮，下载DevEco Studio。 说明 如果下载DevEco Studio Beta版本，则需要注册并登录华为开发者帐号。 下载完成后，双击下载的“deveco-studio-xxxx.exe”，进入DevEco Studio安装向导，在如下安装选项界面勾选64-bit launcher后，点击Next，直至安装完成。 macOS环境 运行环境要求 为保证DevEco Studio正常运行，建议电脑配置满足如下要求： 操作系统：macOS 10.14/10.15/11.2.2 内存：8GB及以上 硬盘：100GB及以上 分辨率：1280*800像素及以上 下载和安装DevEco Studio DevEco Studio的编译构建依赖JDK，DevEco Studio预置了Open JDK，版本为1.8，安装过程中会自动安装JDK。 进入HUAWEI DevEco Studio产品页，点击下载列表后的按钮，下载DevEco Studio。 说明 如果下载DevEco Studio Beta版本，则需要注册并登录华为开发者帐号。 下载完成后，双击下载的“deveco-studio-xxxx.dmg”软件包。 在安装界面中，将“DevEco-Studio.app”拖拽到“Applications”中，等待安装完成。 安装完成后，接下来请根据配置开发环境，检查和配置开发环境。 开发环境配置完成后，请参考创建和运行Hello World创建工程，设备类型以“Phone”为例： 使用Java语言开发，模板选择“Empty Ability(Java)” 使用JS语言开发，模板选择“Empty Ability(JS)” 使用可视化开发，模板选择“Empty Ability(JS)” 工程创建完成后，使用预览器或Phone模拟器运行该工程。 华为鸿蒙OS开发工具下载地址：https://developer.harmonyos.com/cn/develop/deveco-studio#download","categories":[{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"https://visen123.github.io/categories/HarmonyOS/"}],"tags":[],"keywords":[{"name":"HarmonyOS","slug":"HarmonyOS","permalink":"https://visen123.github.io/categories/HarmonyOS/"}]},{"title":"Android常用传感器用法一览","slug":"categories/Android/Android常用传感器用法一览","date":"2021-07-06T07:06:08.000Z","updated":"2021-09-03T14:38:55.828Z","comments":true,"path":"2021/07/06/categories/Android/Android常用传感器用法一览/","link":"","permalink":"https://visen123.github.io/2021/07/06/categories/Android/Android%E5%B8%B8%E7%94%A8%E4%BC%A0%E6%84%9F%E5%99%A8%E7%94%A8%E6%B3%95%E4%B8%80%E8%A7%88/","excerpt":"","text":"1、传感器入门自从苹果公司在2007年发布第一代iPhone以来，以前看似和手机挨不着边的传感器也逐渐成为手机硬件的重要组成部分。如果读者使用过iPhone、HTC Dream、HTC Magic、HTC Hero以及其他的Android手机，会发现通过将手机横向或纵向放置，屏幕会随着手机位置的不同而改变方向。这种功能就需要通过重力传感器来实现，除了重力传感器，还有很多其他类型的传感器被应用到手机中，例如磁阻传感器就是最重要的一种传感器。虽然手机可以通过GPS来判断方向，但在GPS信号不好或根本没有GPS信号的情况下，GPS就形同虚设。这时通过磁阻传感器就可以很容易判断方向（东、南、西、北）。有了磁阻传感器，也使罗盘（俗称指向针）的电子化成为可能。在Android应用程序中使用传感器要依赖于android.hardware.SensorEventListener接口。通过该接口可以监听传感器的各种事件。SensorEventListener接口的代码如下：package android.hardware;public interface SensorEventListener{ public voidonSensorChanged(SensorEvent event); public voidonAccuracyChanged(Sensor sensor, int accuracy);}复制代码 在SensorEventListener接口中定义了两个方法：onSensorChanged和onAccuracyChanged。当传感器的值发生变化时，例如磁阻传感器的方向改变时会调用onSensorChanged方法。当传感器的精度变化时会调用onAccuracyChanged方法。onSensorChanged方法只有一个SensorEvent类型的参数event，其中SensorEvent类有一个values变量非常重要，该变量的类型是float[]。但该变量最多只有3个元素，而且根据传感器的不同，values变量中元素所代表的含义也不同。 在解释values变量中元素的含义之前，先来介绍一下Android的坐标系统是如何定义X、Y、Z轴的。 X轴的方向是沿着屏幕的水平方向从左向右。如果手机不是正方形的话，较短的边需要水平放置，较长的边需要垂直放置。Y轴的方向是从屏幕的左下角开始沿着屏幕的垂直方向指向屏幕的顶端。将手机平放在桌子上，Z轴的方向是从手机里指向天空。 下面是values变量的元素在主要的传感器中所代表的含义。 1.1方向传感器在方向传感器中values变量的3个值都表示度数，它们的含义如下： values[0]：该值表示方位，也就是手机绕着Z轴旋转的角度。0表示北（North）；90表示东（East）；180表示南（South）；270表示西（West）。如果values[0]的值正好是这4个值，并且手机是水平放置，表示手机的正前方就是这4个方向。可以利用这个特性来实现电子罗盘，实例76将详细介绍电子罗盘的实现过程。 values[1]：该值表示倾斜度，或手机翘起的程度。当手机绕着X轴倾斜时该值发生变化。values[1]的取值范围是-180≤values[1]≤180。假设将手机屏幕朝上水平放在桌子上，这时如果桌子是完全水平的，values[1]的值应该是0（由于很少有桌子是绝对水平的，因此，该值很可能不为0，但一般都是-5和5之间的某个值）。这时从手机顶部开始抬起，直到将手机沿X轴旋转180度（屏幕向下水平放在桌面上）。在这个旋转过程中，values[1]会在0到-180之间变化，也就是说，从手机顶部抬起时，values[1]的值会逐渐变小，直到等于-180。如果从手机底部开始抬起，直到将手机沿X轴旋转180度，这时values[1]会在0到180之间变化。也就是values[1]的值会逐渐增大，直到等于180。可以利用values[1]和下面要介绍的values[2]来测量桌子等物体的倾斜度。 values[2]：表示手机沿着Y轴的滚动角度。取值范围是-90≤values[2]≤90。假设将手机屏幕朝上水平放在桌面上，这时如果桌面是平的，values[2]的值应为0。将手机左侧逐渐抬起时，values[2]的值逐渐变小，直到手机垂直于桌面放置，这时values[2]的值是-90。将手机右侧逐渐抬起时，values[2]的值逐渐增大，直到手机垂直于桌面放置，这时values[2]的值是90。在垂直位置时继续向右或向左滚动，values[2]的值会继续在-90至90之间变化。 1.2加速传感器该传感器的values变量的3个元素值分别表示X、Y、Z轴的加速值。例如，水平放在桌面上的手机从左侧向右侧移动，values[0]为负值；从右向左移动，values[0]为正值。读者可以通过本节的例子来体会加速传感器中的值的变化。要想使用相应的传感器，仅实现SensorEventListener接口是不够的，还需要使用下面的代码来注册相应的传感器。 // 获得传感器管理器 SensorManager sm = (SensorManager) getSystemService(SENSOR_SERVICE); // 注册方向传感器 sm.registerListener(this,sm.getDefaultSensor(Sensor.TYPE_ORIENTATION), SensorManager.SENSOR_DELAY_FASTEST); 如果想注册其他的传感器，可以改变getDefaultSensor方法的第1个参数值，例如，注册加速传感器可以使用Sensor.TYPE_ACCELEROMETER。在Sensor类中还定义了很多传感器常量，但要根据手机中实际的硬件配置来注册传感器。如果手机中没有相应的传感器硬件，就算注册了相应的传感器也不起任何作用。getDefaultSensor方法的第2个参数表示获得传感器数据的速度。SensorManager.SENSOR_DELAY_ FASTEST表示尽可能快地获得传感器数据。除了该值以外，还可以设置3个获得传感器数据的速度值，这些值如下： SensorManager.SENSOR_DELAY_NORMAL：默认的获得传感器数据的速度。SensorManager.SENSOR_DELAY_GAME：如果利用传感器开发游戏，建议使用该值。SensorManager.SENSOR_DELAY_UI：如果使用传感器更新UI中的数据，建议使用该值。 1.3重力感应器加速度传感器的类型常量是Sensor.TYPE_GRAVITY。重力传感器与加速度传感器使用同一套坐标系。values数组中三个元素分别表示了X、Y、Z轴的重力大小。Android SDK定义了一些常量，用于表示星系中行星、卫星和太阳表面的重力。下面就来温习一下天文知识，将来如果在地球以外用Android手机，也许会用得上。public static final float GRAVITY_SUN= 275.0f;public static final float GRAVITY_MERCURY= 3.70f;public static final float GRAVITY_VENUS= 8.87f;public static final float GRAVITY_EARTH= 9.80665f;public static final float GRAVITY_MOON= 1.6f;public static final float GRAVITY_MARS= 3.71f;public static final float GRAVITY_JUPITER= 23.12f;public static final float GRAVITY_SATURN= 8.96f;public static final float GRAVITY_URANUS= 8.69f;public static final float GRAVITY_NEPTUNE= 11.0f;public static final float GRAVITY_PLUTO= 0.6f;public static final float GRAVITY_DEATH_STAR_I= 0.000000353036145f;public static final float GRAVITY_THE_ISLAND= 4.815162342f; 1.4 光线传感器光线传感器的类型常量是Sensor.TYPE_LIGHT。values数组只有第一个元素（values[0]）有意义。表示光线的强度。最大的值是120000.0f。Android SDK将光线强度分为不同的等级，每一个等级的最大值由一个常量表示，这些常量都定义在SensorManager类中，代码如下：public static final float LIGHT_SUNLIGHT_MAX =120000.0f;public static final float LIGHT_SUNLIGHT=110000.0f;public static final float LIGHT_SHADE=20000.0f;public static final float LIGHT_OVERCAST= 10000.0f;public static final float LIGHT_SUNRISE= 400.0f;public static final float LIGHT_CLOUDY= 100.0f;public static final float LIGHT_FULLMOON= 0.25f;public static final float LIGHT_NO_MOON= 0.001f; 上面的八个常量只是临界值。读者在实际使用光线传感器时要根据实际情况确定一个范围。例如，当太阳逐渐升起时，values[0]的值很可能会超过LIGHT_SUNRISE，当values[0]的值逐渐增大时，就会逐渐越过LIGHT_OVERCAST，而达到LIGHT_SHADE，当然，如果天特别好的话，也可能会达到LIGHT_SUNLIGHT，甚至更高。 1.5陀螺仪传感器 陀螺仪传感器的类型常量是Sensor.TYPE_GYROSCOPE。values数组的三个元素表示的含义如下：values[0]：延X轴旋转的角速度。values[1]：延Y轴旋转的角速度。values[2]：延Z轴旋转的角速度。当手机逆时针旋转时，角速度为正值，顺时针旋转时，角速度为负值。陀螺仪传感器经常被用来计算手机已转动的角度，代码如下：private static final float NS2S = 1.0f / 1000000000.0f;private float timestamp;public void onSensorChanged(SensorEvent event){ if (timestamp != 0) { // event.timesamp表示当前的时间，单位是纳秒（1百万分之一毫秒） final float dT = (event.timestamp - timestamp) * NS2S; angle[0] += event.values[0] * dT; angle[1] += event.values[1] * dT; angle[2] += event.values[2] * dT; } timestamp = event.timestamp;} 上面代码中通过陀螺仪传感器相邻两次获得数据的时间差（dT）来分别计算在这段时间内手机延X、 Y、Z轴旋转的角度，并将值分别累加到angle数组的不同元素上。 1.6其他传感器其他传感器在前面几节介绍了加速度传感器、重力传感器、光线传感器、陀螺仪传感器以及方向传感器。除了这些传感器外，Android SDK还支持如下的几种传感器。关于这些传感器的使用方法以及与这些传感器相关的常量、方法，读者可以参阅官方文档。 近程传感器（Sensor.TYPE_PROXIMITY）线性加速度传感器（Sensor.TYPE_LINEAR_ACCELERATION）旋转向量传感器（Sensor.TYPE_ROTATION_VECTOR）磁场传感器（Sensor.TYPE_MAGNETIC_FIELD）压力传感器（Sensor.TYPE_PRESSURE）温度传感器（Sensor.TYPE_TEMPERATURE） 虽然AndroidSDK定义了十多种传感器，但并不是每一部手机都完全支持这些传感器。例如，Google Nexus S支持其中的9种传感器（不支持压力和温度传感器），而HTC G7只支持其中的5种传感器。如果使用了手机不支持的传感器，一般不会抛出异常，但也无法获得传感器传回的数据。读者在使用传感器时最好先判断当前的手机是否支持所使用的传感器。","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"Python常用工具包汇总","slug":"categories/工具/Python常用工具汇总","date":"2021-06-29T13:18:28.000Z","updated":"2021-09-07T13:59:16.116Z","comments":true,"path":"2021/06/29/categories/工具/Python常用工具汇总/","link":"","permalink":"https://visen123.github.io/2021/06/29/categories/%E5%B7%A5%E5%85%B7/Python%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/","excerpt":"","text":"一、Python中常用的科学计算工具包： 我们最了解的科学计算工具可能是Matlab，它能进行集数值计算，可视化工具及交互于一身，可惜的是它是一个商业产品。开源方面除了GNU Octave在尝试做一个类似Matlab的工具包外，Python的这几个工具包集合到一起也可以替代Matlab的相应功能：NumPy+SciPy+Matplotlib+iPython。同时，这几个工具包，特别是NumPy和SciPy，也是很多Python文本处理 &amp; 机器学习 &amp; 数据挖掘工具包的基础，非常重要。 Numpy： Numpy是使用Python进行科学计算的基础库，主要提供高性能的N维数组实现以及计算能力，还提供了和其它语言如C/C++集成的能力，此外还实现了一些基础的数学算法，如线性代数相关、傅里叶变换及随机数生成等。NumPy提供了两种基本的对象：ndarray（N-dimensional array object）和 ufunc（universal function object）。ndarray是存储单一数据类型的多维数组，而ufunc则是能够对数组进行处理的函数。 官方主页：http://www.numpy.org/ SciPy：Scientific Computing Tools for Python “SciPy是一个开源的Python算法库和数学工具包，SciPy包含的模块有最优化、线性代数、积分、插值、特殊函数、快速傅里叶变换、信号处理和图像处理、常微分方程求解和其他科学与工程中常用的计算。其功能与软件MATLAB、Scilab和GNU Octave类似。 Numpy和Scipy常常结合着使用，Python大多数机器学习库都依赖于这两个模块。”—-引用自“Python机器学习库” 官方主页：http://www.scipy.org/ 3.Matplotlib Matplotlib是python数据可视化工具包。是python最著名的绘图库，它提供了一整套和matlab相似的命令API，十分适合交互式地进行制图。而且也可以方便地将它作为绘图控件，嵌入GUI应用程序中。Matplotlib可以配合ipython shell使用，提供不亚于Matlab的绘图体验，总之用过了都说好。 在IPython控制台使用Matplotlib，可以使用ipython–matplotlib命令来启动IPython控制台程序；如果要在IPython notebook里使用Matplotlib，则在notebook的开始位置插入%matplotlib inline魔术命令即可。 IPython为Matplotlib专门提供了特殊的交互模式。IPython的Matplotlib模式有两个优点，一是提供了非阻塞的画图操作，二是不需要显示地调用show（）方法来显示画出来的图片。 官方主页：http://matplotlib.org/ 二. Python 机器学习 &amp; 数据挖掘常用工具包 机器学习和数据挖掘这两个概念不太好区分，这里就放到一起了。这方面的开源Python工具包有很多，这里先从熟悉的讲起，再补充其他来源的资料，也欢迎大家补充。 2.1 scikit-learn: Machine Learning in Python 首先是scikit-learn，scikit-learn是一个基于NumPy, SciPy, Matplotlib的开源机器学习工具包，主要涵盖分类，回归和聚类算法，例如SVM， 逻辑回归，朴素贝叶斯，随机森林，k-means等算法，代码和文档都非常不错，在许多Python项目中都有应用。例如在我们熟悉的NLTK中。scikit-learn提供了一致的调用接口。它基于Numpy和scipy等Python数值计算库，提供了高效的算法实现。总结起来，scikit-learn工具包有以下几个优点。 一、文档齐全：官方文档齐全，更新及时。 二、接口易用：针对所有算法提供了一致的接口调用规则，不管是KNN、K-Means还是PCA. 三、算法全面：涵盖主流机器学习任务的算法，包括回归算法、分类算法、聚类分析、数据降维处理等。 缺点是scikit-learn不支持分布式计算，不适合用来处理超大型数据。 官方主页：http://scikit-learn.org/ 2.2 Pandas: Python Data Analysis Library Pandas是一个强大的时间序列数据处理工具包，Pandas是基于Numpy构建的，比Numpy的使用更简单。最初开发的目的是为了分析财经数据，现在已经广泛应用在Python数据分析领域中。Pandas，最基础的数据结构是Series，用它来表达一行数据，可以理解为一维的数组。另一个关键的数据结构为DataFrame，它表示的是二维数组 Pandas是基于NumPy和Matplotlib开发的，主要用于数据分析和数据可视化，它的数据结构DataFrame和R语言里的data.frame很像，特别是对于时间序列数据有自己的一套分析机制。有一本书《Python for Data Analysis》，作者是Pandas的主力开发，依次介绍了iPython, NumPy, Pandas里的相关功能，数据可视化，数据清洗和加工，时间数据处理等，案例包括金融股票数据挖掘等，相当不错。 官方主页：http://pandas.pydata.org/ 2.3 mlpy – Machine Learning Python Mlpy是基于NumPy/SciPy的Python机器学习模块，它是Cython的扩展应用。包含的机器学习算法很多，有时间单独写一篇记录 官方主页：http://mlpy.sourceforge.net/ 2.4 PyBrain “PyBrain(Python-Based Reinforcement Learning, Artificial Intelligence and Neural Network)是Python的一个机器学习模块，它的目标是为机器学习任务提供灵活、易应、强大的机器学习算法。（这名字很霸气） PyBrain正如其名，包括神经网络、强化学习(及二者结合)、无监督学习、进化算法。因为目前的许多问题需要处理连续态和行为空间，必须使用函数逼近(如神经网络)以应对高维数据。PyBrain以神经网络为核心，所有的训练方法都以神经网络为一个实例。” 2.5 Theano “Theano 是一个 Python 库，用来定义、优化和模拟数学表达式计算，用于高效的解决多维数组的计算问题。Theano的特点：紧密集成Numpy；高效的数据密集型GPU计算；高效的符号微分运算；高速和稳定的优化；动态生成c代码；广泛的单元测试和自我验证。自2007年以来，Theano已被广泛应用于科学运算。theano使得构建深度学习模型更加容易，可以快速实现多种模型。PS：Theano，一位希腊美女，Croton最有权势的Milo的女儿，后来成为了毕达哥拉斯的老婆。” 2.6 NLTK NLTK(Natural Language Toolkit)是Python的自然语言处理模块，包括一系列的字符处理和语言统计模型。NLTK 常用于学术研究和教学，应用的领域有语言学、认知科学、人工智能、信息检索、机器学习等。 NLTK提供超过50个语料库和词典资源，文本处理库包括分类、分词、词干提取、解析、语义推理。可稳定运行在Windows, Mac OS X和Linux平台上. 项目主页： http://sourceforge.net/projects/nltk/ https://pypi.python.org/pypi/nltk/ http://nltk.org/ 2.7 Pylearn2 “Pylearn2建立在theano上，部分依赖scikit-learn上，目前Pylearn2正处于开发中，将可以处理向量、图像、视频等数据，提供MLP、RBM、SDA等深度学习模型。” 官方主页：http://deeplearning.net/software/pylearn2/ 三. Python网页爬虫工具 一个真实的项目，一定是从获取数据开始的。无论文本处理，机器学习和数据挖掘，都需要数据，除了通过一些渠道购买或者下载的专业数据外，常常需要自己动手爬数据，这个时候，爬虫就显得格外重要了，幸好，Python提供了一批很不错的网页爬虫工具框架，既能爬取数据，也能获取和清洗数据，以前爬过一些火影和海贼的数据来玩： 3.1 Scrapy 鼎鼎大名的Scrapy，相信不少同学都有耳闻，课程图谱中的很多课程都是依靠Scrapy抓去的，这方面的介绍文章有很多，推荐大牛pluskid早年的一篇文章：《Scrapy 轻松定制网络爬虫》，历久弥新。 官方主页：http://scrapy.org/ Github代码页: https://github.com/scrapy/scrapy 3.2 Beautiful Soup 客观的说，Beautifu Soup不完全是一套爬虫工具，需要配合urllib使用，而是一套HTML / XML数据分析，清洗和获取工具。 官方主页：http://www.crummy.com/software/BeautifulSoup/ 3.3 Python-Goose Goose最早是用Java写得，后来用Scala重写，是一个Scala项目。Python-Goose用Python重写，依赖了Beautiful Soup。前段时间用过，感觉很不错，给定一个文章的URL, 获取文章的标题和内容很方便。 Github主页：https://github.com/grangier/python-goose 四. Python文本处理工具 获取文本数据之后，依据任务的不同，就需要进行基本的文本处理了，譬如对于英文来说，需要基本的tokenize，对于中文，则需要常见的中文分词，进一步的话，无论英文中文，还可以词性标注，句法分析，关键词提取，文本分类，情感分析等等。这个方面，特别是面向英文领域，有很多优秀的工具包，我们一一道来。 4.1 NLTK — Natural Language Toolkit 搞自然语言处理的同学应该没有人不知道NLTK吧，这里也就不多说了。不过推荐两本书籍给刚刚接触NLTK或者需要详细了解NLTK的同学: 一个是官方的《Natural Language Processing with Python》，以介绍NLTK里的功能用法为主，同时附带一些Python知识，同时国内陈涛同学友情翻译了一个中文版，这里可以看到：推荐《用Python进行自然语言处理》中文翻译-NLTK配套书；另外一本是《Python Text Processing with NLTK 2.0 Cookbook》，这本书要深入一些，会涉及到NLTK的代码结构，同时会介绍如何定制自己的语料和模型等，相当不错。 官方主页：http://www.nltk.org/ Github代码页：https://github.com/nltk/nltk 4.2 Pattern Pattern由比利时安特卫普大学CLiPS实验室出品，客观的说，Pattern不仅仅是一套文本处理工具，它更是一套web数据挖掘工具，囊括了数据抓取模块（包括Google, Twitter, 维基百科的API，以及爬虫和HTML分析器），文本处理模块（词性标注，情感分析等），机器学习模块(VSM, 聚类，SVM）以及可视化模块等，可以说，Pattern的这一整套逻辑也是这篇文章的组织逻辑，不过这里我们暂且把Pattern放到文本处理部分。我个人主要使用的是它的英文处理模块Pattern.en, 有很多很不错的文本处理功能，包括基础的tokenize, 词性标注，句子切分，语法检查，拼写纠错，情感分析，句法分析等，相当不错。 官方主页：http://www.clips.ua.ac.be/pattern 4.3 TextBlob: Simplified Text Processing TextBlob是一个很有意思的Python文本处理工具包，它其实是基于上面两个Python工具包NLKT和Pattern做了封装（TextBlob stands on the giant shoulders of NLTK and pattern, and plays nicely with both），同时提供了很多文本处理功能的接口，包括词性标注，名词短语提取，情感分析，文本分类，拼写检查等，甚至包括翻译和语言检测，不过这个是基于Google的API的，有调用次数限制。TextBlob相对比较年轻，有兴趣的同学可以关注。 官方主页：http://textblob.readthedocs.org/en/dev/ Github代码页：https://github.com/sloria/textblob 4.4 MBSP for Python MBSP与Pattern同源，同出自比利时安特卫普大学CLiPS实验室，提供了Word Tokenization, 句子切分，词性标注，Chunking, Lemmatization，句法分析等基本的文本处理功能，感兴趣的同学可以关注。 官方主页：http://www.clips.ua.ac.be/pages/MBSP 4.5 Gensim: Topic modeling for humans Gensim是一个相当专业的主题模型Python工具包，无论是代码还是文档，我们曾经用《如何计算两个文档的相似度》介绍过Gensim的安装和使用过程，这里就不多说了。 官方主页：http://radimrehurek.com/gensim/index.html github代码页：https://github.com/piskvorky/gensim 4.6 langid.py: Stand-alone language identification system 语言检测是一个很有意思的话题，不过相对比较成熟，这方面的解决方案很多，也有很多不错的开源工具包，不过对于Python来说，我使用过langid这个工具包，也非常愿意推荐它。langid目前支持97种语言的检测，提供了很多易用的功能，包括可以启动一个建议的server，通过json调用其API，可定制训练自己的语言检测模型等，可以说是“麻雀虽小，五脏俱全”。 Github主页：https://github.com/saffsd/langid.py 4.7 Jieba Jieba做最好的Python中文分词组件 “Jieba” (Chinese for “to stutter”) Chinese text segmentation: built to be the best Python Chinese word segmentation module.好了，终于可以说一个国内的Python文本处理工具包了：结巴分词，其功能包括支持三种分词模式（精确模式、全模式、搜索引擎模式），支持繁体分词，支持自定义词典等，是目前一个非常不错的Python中文分词解决方案。 Github主页：https://github.com/fxsjy/jieba","categories":[{"name":"工具","slug":"工具","permalink":"https://visen123.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[],"keywords":[{"name":"工具","slug":"工具","permalink":"https://visen123.github.io/categories/%E5%B7%A5%E5%85%B7/"}]},{"title":"Python画小猪佩奇","slug":"categories/Python/Python画小猪佩奇","date":"2021-06-26T02:26:42.000Z","updated":"2021-09-07T13:37:36.478Z","comments":true,"path":"2021/06/26/categories/Python/Python画小猪佩奇/","link":"","permalink":"https://visen123.github.io/2021/06/26/categories/Python/Python%E7%94%BB%E5%B0%8F%E7%8C%AA%E4%BD%A9%E5%A5%87/","excerpt":"","text":"小猪佩奇代码实现如下：import turtle as t t.begin_fill()t.pensize(4)t.hideturtle()t.colormode(255)t.color((255, 155, 192), “pink”)t.setup(840, 500)t.speed(10) 写字#设置字体颜色t.pencolor(“PINK”)#起笔t.penup()#设定坐标t.goto(-10,190)#设置写字内容和字体、字号t.write(“2021/06/16”, move=False, align=’center’, font=(“微软雅黑”, 26, ‘normal’)) 鼻子t.pu()t.goto(-100, 100)t.pd()t.seth(-30)#填充颜色t.begin_fill()a = 0.4for i in range(120): if 0 &lt;= i &lt; 30 or 60 &lt;= i &lt; 90: a = a + 0.08 t.lt(3) # 向左转3度 t.fd(a) # 向前走a的步长 else: a = a - 0.08 t.lt(3) t.fd(a)#结束填充t.end_fill() t.pu()t.seth(90)t.fd(25)t.seth(0)t.fd(10)t.pd()t.pencolor(255, 155, 192)t.seth(10)t.begin_fill()t.circle(5)t.color(160, 82, 45)t.end_fill() t.pu()t.seth(0)t.fd(20)t.pd()t.pencolor(255, 155, 192)t.seth(10)t.begin_fill()t.circle(5)t.color(160, 82, 45)t.end_fill() 头t.color((255, 155, 192), “pink”)t.pu()t.seth(90)t.fd(41)t.seth(0)t.fd(0)t.pd()t.begin_fill()t.seth(180)t.circle(300, -30)t.circle(100, -60)t.circle(80, -100)t.circle(150, -20)t.circle(60, -95)t.seth(161)t.circle(-300, 15)t.pu()t.goto(-100, 100)t.pd()t.seth(-30)a = 0.4for i in range(60): if 0 &lt;= i &lt; 30 or 60 &lt;= i &lt; 90: a = a + 0.08 t.lt(3) # 向左转3度 t.fd(a) # 向前走a的步长 else: a = a - 0.08 t.lt(3) t.fd(a)t.end_fill() 耳朵t.color((255, 155, 192), “pink”)t.pu()t.seth(90)t.fd(-7)t.seth(0)t.fd(70)t.pd()t.begin_fill()t.seth(100)t.circle(-50, 50)t.circle(-10, 120)t.circle(-50, 54)t.end_fill() t.pu()t.seth(90)t.fd(-12)t.seth(0)t.fd(30)t.pd()t.begin_fill()t.seth(100)t.circle(-50, 50)t.circle(-10, 120)t.circle(-50, 56)t.end_fill() 眼睛t.color((255, 155, 192), “white”)t.pu()t.seth(90)t.fd(-20)t.seth(0)t.fd(-95)t.pd()t.begin_fill()t.circle(15)t.end_fill() t.color(“black”)t.pu()t.seth(90)t.fd(12)t.seth(0)t.fd(-3)t.pd()t.begin_fill()t.circle(3)t.end_fill() t.color((255, 155, 192), “white”)t.pu()t.seth(90)t.fd(-25)t.seth(0)t.fd(40)t.pd()t.begin_fill()t.circle(15)t.end_fill() t.color(“black”)t.pu()t.seth(90)t.fd(12)t.seth(0)t.fd(-3)t.pd()t.begin_fill()t.circle(3)t.end_fill() 腮t.color((255, 155, 192))t.pu()t.seth(90)t.fd(-95)t.seth(0)t.fd(65)t.pd()t.begin_fill()t.circle(30)t.end_fill() 嘴t.color(239, 69, 19)t.pu()t.seth(90)t.fd(15)t.seth(0)t.fd(-100)t.pd()t.seth(-80)t.circle(30, 40)t.circle(40, 80) 身体t.color(“red”, (255, 99, 71))t.pu()t.seth(90)t.fd(-20)t.seth(0)t.fd(-78)t.pd()t.begin_fill()t.seth(-130)t.circle(100, 10)t.circle(300, 30)t.seth(0)t.fd(230)t.seth(90)t.circle(300, 30)t.circle(100, 3)t.color((255, 155, 192), (255, 100, 100))t.seth(-135)t.circle(-80, 63)t.circle(-150, 24)t.end_fill() 手t.color((255, 155, 192))t.pu()t.seth(90)t.fd(-40)t.seth(0)t.fd(-27)t.pd()t.seth(-160)t.circle(300, 15)t.pu()t.seth(90)t.fd(15)t.seth(0)t.fd(0)t.pd()t.seth(-10)t.circle(-20, 90) t.pu()t.seth(90)t.fd(30)t.seth(0)t.fd(237)t.pd()t.seth(-20)t.circle(-300, 15)t.pu()t.seth(90)t.fd(20)t.seth(0)t.fd(0)t.pd()t.seth(-170)t.circle(20, 90) 脚t.pensize(10)t.color((240, 128, 128))t.pu()t.seth(90)t.fd(-75)t.seth(0)t.fd(-180)t.pd()t.seth(-90)t.fd(40)t.seth(-180)t.color(“black”)t.pensize(15)t.fd(20) t.pensize(10)t.color((240, 128, 128))t.pu()t.seth(90)t.fd(40)t.seth(0)t.fd(90)t.pd()t.seth(-90)t.fd(40)t.seth(-180)t.color(“black”)t.pensize(15)t.fd(20) 尾巴t.pensize(4)t.color((255, 155, 192))#画笔抬起，不留下痕迹t.pu()t.seth(90)t.fd(70)t.seth(0)t.fd(95)#画笔落下，留下痕迹t.pd()t.seth(0)#画圆，第一个数字是半径，第二个数字是角度t.circle(70, 20)t.circle(10, 330)t.circle(70, 30)t.end_fill()#结束绘画t.done()","categories":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}],"tags":[],"keywords":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}]},{"title":"Python例子-复制文件","slug":"categories/Python/Python复制文件","date":"2021-06-24T13:26:30.000Z","updated":"2021-09-03T14:48:40.213Z","comments":true,"path":"2021/06/24/categories/Python/Python复制文件/","link":"","permalink":"https://visen123.github.io/2021/06/24/categories/Python/Python%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6/","excerpt":"","text":"代码实现如下：按照用户输入的文件文件名字，新建一个文件，在文件里面写入内容，然后复制文件1,先按照用户的输入，新建一个old_file文件，并写入内容 2，以用户输入的名字，构造一个复制文件new_file的名字 3，把old_file的内容读出来并写入到new_file里面取 old_file_name = input(‘请输入文件名:’)old_file = open(old_file_name,’w’)old_file.write(‘1,hello world\\n2,hello world\\n3,hello world’)old_file.close()file_flag_num = old_file_name.rfind(‘.’)if file_flag_num &gt; 0: file_name = old_file_name[:file_flag_num] file_flag = old_file_name[file_flag_num:] new_file_name = file_name + ‘附件’ + file_flagelse: print(‘输入的文件名有错！’) new_file_name = Nonenew_file = open(new_file_name,’w’)old_file = open(old_file_name,’r’) # 要重新打开一次，不然是读取的没有内容的文件contents = old_file.readlines()for con in contents: new_file.write(con) 关闭文件old_file.close()new_file.close()","categories":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}],"tags":[],"keywords":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}]},{"title":"Python画动漫海贼王","slug":"categories/Python/Python画动漫海贼王","date":"2021-06-23T08:26:42.000Z","updated":"2021-09-07T13:35:03.867Z","comments":true,"path":"2021/06/23/categories/Python/Python画动漫海贼王/","link":"","permalink":"https://visen123.github.io/2021/06/23/categories/Python/Python%E7%94%BB%E5%8A%A8%E6%BC%AB%E6%B5%B7%E8%B4%BC%E7%8E%8B/","excerpt":"","text":"代码实现如下：import turtle as t “”” t.hideturtle()t.bgcolor(‘white’) “”” t.setup(800,500) # 创建画布并使其位于屏幕中心t.pensize(2) # 画笔粗细t.colormode(255) # 色彩模式t.speed(10) # 绘画速度t.color(‘black’,(255,228,181)) # 画笔颜色与填充色t.shape(‘turtle’) # 画笔的形状t.speed(10) #画笔速度t.showturtle() # 使画笔显现 移动画笔def move(x, y, angle): t.pu() t.goto(x, y) t.seth(angle) t.pd() 画圆填充颜色def draw_circle(x, y, r, color): t.color(color) t.pu() t.goto(x, y) t.seth(-90) t.fd(r) t.seth(0) t.pd t.begin_fill() t.circle(r) t.end_fill() pass 画圆不填充颜色def draw_circle_normal(x, y, r): t.pu() t.goto(x, y) t.seth(-90) t.fd(r) t.seth(0) t.pd() t.circle(r) pass 画脸def draw_face(): t.color(‘black’, ‘white’) move(0, -103, 0) t.begin_fill() t.circle(103, 90) t.seth(180) t.fd(103*2) t.seth(-90) t.circle(103, 90) t.end_fill() pass 画眼睛、鼻子def draw_eyes(): t.color(‘black’) move(-40, 0, 180) t.begin_fill() t.circle(30) t.end_fill() move(40, 0, 180) t.begin_fill() t.circle(30) t.end_fill() move(0, -61, 180) t.begin_fill() t.circle(13) t.end_fill() 画帽子def draw_hat(): t.color(‘black’, ‘#fcd462’) move(0, 0, 0) t.begin_fill() t.fd(175) t.circle(15, 180) t.fd(175*2) t.circle(15, 180) t.fd(175) t.end_fill() pass move(0, 0, 17) t.color(‘#fcd462’) t.pu() t.fd(103) p1 = t.position() t.left(90) t.pd() t.begin_fill() t.circle(103, 147) t.seth(0) p2 = t.position() t.goto(p1) t.end_fill() pass t.color(‘#fe0202’) t.seth(107) t.begin_fill() t.circle(103, 15) p3 = t.position() t.pu() t.right(180) t.circle(-103, 15) t.seth(180) t.pd() t.goto(p2) t.seth(77) t.circle(-103, 15) t.goto(p3) t.end_fill() pass 画嘴巴def draw_mouth(): move(0, -90, 180) t.color(‘black’, ‘white’) t.begin_fill() t.circle(50) t.end_fill() pass draw_circle_normal(0, 0, 160) draw_circle_normal(0, 0, 130) move(0,-103,-90) t.fd(57) p4=t.position() t.seth(0) t.pu() t.circle(160,10) t.seth(100) t.pd() t.fd(57) t.pu() t.goto(p4) t.seth(180) t.pd() t.circle(-160,10) t.seth(80) t.fd(57) pass 画骨头十字架def draw_bone(): t.color(‘black’,’white’) move(-132,155,-42) t.fd(404) t.left(90) t.circle(-20,270) t.right(180) t.circle(-20,270) t.seth(138) t.fd(404) t.left(90) t.circle(-20,270) t.left(180) t.circle(-20,270) pass move(-132,-155,48) t.fd(404) t.right(90) t.circle(20,270) t.right(180) t.circle(20,270) t.seth(228) t.fd(404) t.right(90) t.circle(20,270) t.left(180) t.circle(20,270) pass t.pensize(5)draw_bone()t.pensize(2)draw_circle(0,0,160,’black’)draw_mouth()draw_face()draw_eyes()draw_hat()t.done()","categories":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}],"tags":[],"keywords":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}]},{"title":"Python例子-九九乘法表","slug":"categories/Python/Python九九乘法表","date":"2021-06-23T08:26:30.000Z","updated":"2021-09-03T14:46:53.479Z","comments":true,"path":"2021/06/23/categories/Python/Python九九乘法表/","link":"","permalink":"https://visen123.github.io/2021/06/23/categories/Python/Python%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E8%A1%A8/","excerpt":"","text":"代码实现如下：Python例子-用python语言实现九九乘法表 Python例子-用python语言实现九九乘法表i = 1while i &lt;= 9: j = 1 while j &lt;= i: print(‘%d*%d=%d’ % (j, i, ij) ,end=’ ‘) j += 1 print() i += 1‘’’输出结果11=112=2 22=413=3 23=6 33=914=4 24=8 34=12 44=1615=5 25=10 35=15 45=20 55=2516=6 26=12 36=18 46=24 56=30 66=3617=7 27=14 37=21 47=28 57=35 67=42 77=4918=8 28=16 38=24 48=32 58=40 68=48 78=56 88=6419=9 29=18 39=27 49=36 59=45 69=54 79=63 89=72 99=81‘’’","categories":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}],"tags":[],"keywords":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}]},{"title":"Python画哆啦A梦","slug":"categories/Python/Python画哆啦A梦","date":"2021-06-21T12:26:42.000Z","updated":"2021-09-07T13:31:32.107Z","comments":true,"path":"2021/06/21/categories/Python/Python画哆啦A梦/","link":"","permalink":"https://visen123.github.io/2021/06/21/categories/Python/Python%E7%94%BB%E5%93%86%E5%95%A6A%E6%A2%A6/","excerpt":"","text":"实现代码如下：import turtle def flyTo(x, y): turtle.penup() turtle.goto(x, y) turtle.pendown() def drawEye(): turtle.tracer(False) a = 2.5 for i in range(120): if 0 &lt;= i &lt; 30 or 60 &lt;= i &lt; 90: a -= 0.05 else: a += 0.05 turtle.left(3) turtle.fd(a) turtle.tracer(True) def beard(): “”” 画胡子， 一共六根 “”” # 左边第一根胡子 flyTo(-37, 135) turtle.seth(165) turtle.fd(60) # 左边第二根胡子 flyTo(-37, 125) turtle.seth(180) turtle.fd(60) # 左边第三根胡子 flyTo(-37, 115) turtle.seth(193) turtle.fd(60) # 右边第一根胡子 flyTo(37, 135) turtle.seth(15) turtle.fd(60) # 右边第二根胡子 flyTo(37, 125) turtle.seth(0) turtle.fd(60) # 右边第三根胡子 flyTo(37, 115) turtle.seth(-13) turtle.fd(60) def drawRedScarf(): “”” 画围巾 “”” turtle.fillcolor(“red”) # 填充颜色 turtle.begin_fill() turtle.seth(0) # 朝向右 turtle.fd(200) # 前进10个单位 turtle.circle(-5, 90) turtle.fd(10) turtle.circle(-5, 90) turtle.fd(207) turtle.circle(-5, 90) turtle.fd(10) turtle.circle(-5, 90) turtle.end_fill() def drawMouse(): flyTo(5, 148) turtle.seth(270) turtle.fd(100) turtle.seth(0) turtle.circle(120, 50) turtle.seth(230) turtle.circle(-120, 100) def drawRedNose(): flyTo(-10, 158) turtle.fillcolor(“red”) # 填充颜色 turtle.begin_fill() turtle.circle(20) turtle.end_fill() def drawBlackdrawEye(): turtle.seth(0) flyTo(-20, 195) turtle.fillcolor(“#000000”) # 填充颜色 turtle.begin_fill() turtle.circle(13) turtle.end_fill() turtle.pensize(6) flyTo(20, 205) turtle.seth(75) turtle.circle(-10, 150) turtle.pensize(3) flyTo(-17, 200) turtle.seth(0) turtle.fillcolor(“#ffffff”) turtle.begin_fill() turtle.circle(5) turtle.end_fill() flyTo(0, 0) def drawFace(): “”” “”” turtle.forward(183) # 前行183个单位 turtle.fillcolor(“white”) # 填充颜色为白色 turtle.begin_fill() # 开始填充 turtle.left(45) # 左转45度 turtle.circle(120, 100) # 右边那半边脸 turtle.seth(90) # 朝向向上 drawEye() # 画右眼睛 turtle.seth(180) # 朝向左 turtle.penup() # 抬笔 turtle.fd(60) # 前行60 turtle.pendown() # 落笔 turtle.seth(90) # 朝向上 drawEye() # 画左眼睛 turtle.penup() # 抬笔 turtle.seth(180) # 朝向左 turtle.fd(64) # 前进64 turtle.pendown() # 落笔 turtle.seth(215) # 修改朝向 turtle.circle(120, 100) # 左边那半边脸 turtle.end_fill() # def drawHead(): “”” 画了一个被切掉下半部分的圆 “”” turtle.penup() # 抬笔 turtle.circle(150, 40) # 画圆, 半径150，圆周角40 turtle.pendown() # 落笔 turtle.fillcolor(“#00a0de”) # 填充色 turtle.begin_fill() # 开始填充 turtle.circle(150, 280) # 画圆，半径150, 圆周角280 turtle.end_fill() def drawAll(): drawHead() drawRedScarf() drawFace() drawRedNose() drawMouse() beard() flyTo(0, 0) turtle.seth(0) turtle.penup() turtle.circle(150, 50) turtle.pendown() turtle.seth(30) turtle.fd(40) turtle.seth(70) turtle.circle(-30, 270) turtle.fillcolor(“#00a0de”) turtle.begin_fill() turtle.seth(230) turtle.fd(80) turtle.seth(90) turtle.circle(1000, 1) turtle.seth(-89) turtle.circle(-1000, 10) turtle.seth(180) turtle.fd(70) turtle.seth(90) turtle.circle(30, 180) turtle.seth(180) turtle.fd(70) turtle.seth(100) turtle.circle(-1000, 9) turtle.seth(-86) turtle.circle(1000, 2) turtle.seth(230) turtle.fd(40) turtle.circle(-30, 230) turtle.seth(45) turtle.fd(81) turtle.seth(0) turtle.fd(203) turtle.circle(5, 90) turtle.fd(10) turtle.circle(5, 90) turtle.fd(7) turtle.seth(40) turtle.circle(150, 10) turtle.seth(30) turtle.fd(40) turtle.end_fill() # 左手 turtle.seth(70) turtle.fillcolor(&quot;#FFFFFF&quot;) turtle.begin_fill() turtle.circle(-30) turtle.end_fill() # 脚 flyTo(103.74, -182.59) turtle.seth(0) turtle.fillcolor(&quot;#FFFFFF&quot;) turtle.begin_fill() turtle.fd(15) turtle.circle(-15, 180) turtle.fd(90) turtle.circle(-15, 180) turtle.fd(10) turtle.end_fill() flyTo(-96.26, -182.59) turtle.seth(180) turtle.fillcolor(&quot;#FFFFFF&quot;) turtle.begin_fill() turtle.fd(15) turtle.circle(15, 180) turtle.fd(90) turtle.circle(15, 180) turtle.fd(10) turtle.end_fill() # 右手 flyTo(-133.97, -91.81) turtle.seth(50) turtle.fillcolor(&quot;#FFFFFF&quot;) turtle.begin_fill() turtle.circle(30) turtle.end_fill() # 口袋 flyTo(-103.42, 15.09) turtle.seth(0) turtle.fd(38) turtle.seth(230) turtle.begin_fill() turtle.circle(90, 260) turtle.end_fill() flyTo(5, -40) turtle.seth(0) turtle.fd(70) turtle.seth(-90) turtle.circle(-70, 180) turtle.seth(0) turtle.fd(70) # 铃铛 flyTo(-103.42, 15.09) turtle.fd(90) turtle.seth(70) turtle.fillcolor(&quot;#ffd200&quot;) turtle.begin_fill() turtle.circle(-20) turtle.end_fill() turtle.seth(170) turtle.fillcolor(&quot;#ffd200&quot;) turtle.begin_fill() turtle.circle(-2, 180) turtle.seth(10) turtle.circle(-100, 22) turtle.circle(-2, 180) turtle.seth(180 - 10) turtle.circle(100, 22) turtle.end_fill() flyTo(-13.42, 15.09) turtle.seth(250) turtle.circle(20, 110) turtle.seth(90) turtle.fd(15) turtle.dot(10) flyTo(0, -150) drawBlackdrawEye() def main(): turtle.screensize(800, 6000, “#F0F0F0”) turtle.pensize(3) turtle.speed(9) drawAll() if name == “main“: main() turtle.mainloop()","categories":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}],"tags":[],"keywords":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}]},{"title":"教你如何使用Bugly修复线上安卓APP存在的bug","slug":"categories/Android/教你如何使用Bugly修复线上安卓APP存在的bug","date":"2021-06-21T09:33:40.000Z","updated":"2021-09-01T04:56:09.967Z","comments":true,"path":"2021/06/21/categories/Android/教你如何使用Bugly修复线上安卓APP存在的bug/","link":"","permalink":"https://visen123.github.io/2021/06/21/categories/Android/%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Bugly%E4%BF%AE%E5%A4%8D%E7%BA%BF%E4%B8%8A%E5%AE%89%E5%8D%93APP%E5%AD%98%E5%9C%A8%E7%9A%84bug/","excerpt":"","text":"热更新能力是Bugly为解决开发者紧急修复线上bug，而无需重新发版让用户无感知就能把问题修复的一项能力。 Bugly目前采用微信Tinker的开源方案，开发者只需要集成腾讯官网提供的Bugly SDK就可以实现自动下载补丁包、合成、并应用补丁的功能，而且可以通过管理后台让开发者对每个版本补丁进行管理。 教你如何使用Bugly修复线上安卓APP存在的bug_bugly 为什么使用Bugly热更新呢？因为Bugly热更新有如下好处1、无需关注Tinker是如何合成补丁的2、无需自己搭建补丁管理后台3、无需考虑后台下发补丁策略的任何事情4、无需考虑补丁下载合成的时机，处理后台下发的策略5、提供了更加方便集成Tinker的方式6、通过HTTPS及签名校验等机制保障补丁下发的安全性7、丰富的下发维度控制，有效控制补丁影响范围8、提供了应用升级一站式解决方案 接下来教你如何使用Bugly热更新，具体操作如下 第一步：添加插件依赖工程根目录下“build.gradle”文件中添加： buildscript { repositories { jcenter() } dependencies { // tinkersupport插件, 其中lastest.release指拉取最新版本，也可以指定明确版本号，例如1.0.4 classpath “com.tencent.bugly:tinker-support:latest.release” }} 第二步：集成SDKgradle配置 在app module的“build.gradle”文件中添加（示例配置）： android { defaultConfig { ndk { //设置支持的SO库架构 abiFilters ‘armeabi’ //, ‘x86’, ‘armeabi-v7a’, ‘x86_64’, ‘arm64-v8a’ } } } dependencies { compile “com.android.support:multidex:1.0.1” // 多dex配置 //注释掉原有bugly的仓库 //compile ‘com.tencent.bugly:crashreport:latest.release’//其中latest.release指代最新版本号，也可以指定明确的版本号，例如2.3.2 compile ‘com.tencent.bugly:crashreport_upgrade:latest.release’//其中latest.release指代最新版本号，也可以指定明确的版本号，例如1.2.0 compile ‘com.tencent.bugly:nativecrashreport:latest.release’ //其中latest.release指代最新版本号，也可以指定明确的版本号，例如2.2.0 } 在app module的“build.gradle”文件中添加： // 依赖插件脚本apply from: ‘tinker-support.gradle’tinker-support.gradle内容如下所示（示例配置）： apply plugin: ‘com.tencent.bugly.tinker-support’ def bakPath = file(“${buildDir}/bakApk/“)/*在本类中需要修改： 1.baseApkDir 2-4名称的修改 2.baseApk 3.baseApkProguardMapping 4.baseApkResourceMapping 5.tinkerId 编号必须一致 //* 此处填写每次构建生成的基准包目录 app/build/bakApk/app-0621-21-10-33 /def baseApkDir = “app-0621-21-10-33” /** 对于插件各参数的详细解析请参考 /tinkerSupport { // 开启tinker-support插件，默认值true enable = true // 指定归档目录，默认值当前module的子目录tinker autoBackupApkDir = “${bakPath}” // 是否启用覆盖tinkerPatch配置功能，默认值false // 开启后tinkerPatch配置不生效，即无需添加tinkerPatch overrideTinkerPatchConfiguration = true // 编译补丁包时，必需指定基线版本的apk，默认值为空 // 如果为空，则表示不是进行补丁包的编译 // @{link tinkerPatch.oldApk } baseApk = “${bakPath}/${baseApkDir}/app-release.apk” // 对应tinker插件applyMapping baseApkProguardMapping = “${bakPath}/${baseApkDir}/app-release-mapping.txt” // 对应tinker插件applyResourceMapping baseApkResourceMapping = “${bakPath}/${baseApkDir}/app-release-R.txt” // 构建基准包和补丁包都要指定不同的tinkerId，并且必须保证唯一性 base patch tinkerId = “base-1.0.3” //base-1.0.3 错误版本 patch-1.0.3 补丁版本 （1.0.3基准包和补丁包版本要一致） // 构建多渠道补丁时使用 // buildAllFlavorsDir = “${bakPath}/${baseApkDir}” // 是否开启反射Application模式 enableProxyApplication = false//使用SampleApplication和SampleApplicationLike //enableProxyApplication = true//使用MyApplication } /** 一般来说,无需对下面的参数做任何的修改 对于各参数的详细介绍请参考: https://github.com/Tencent/tinker/wiki/Tinker-%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97 /tinkerPatch { //oldApk =”${bakPath}/${appName}/app-release.apk” ignoreWarning = false useSign = true dex { dexMode = &quot;jar&quot; pattern = [&quot;classes*.dex&quot;] loader = [] } lib { pattern = [&quot;lib/*/*.so&quot;] } res { pattern = [&quot;res/*&quot;, &quot;r/*&quot;, &quot;assets/*&quot;, &quot;resources.arsc&quot;, &quot;AndroidManifest.xml&quot;] ignoreChange = [] largeModSize = 100 } packageConfig { } sevenZip { zipArtifact = &quot;com.tencent.mm:SevenZip:1.1.10&quot; // path = “/usr/local/bin/7za” } buildConfig { keepDexApply = false //tinkerId = &quot;1.0.1-base&quot; //applyMapping = &quot;$&#123;bakPath&#125;/$&#123;appName&#125;/app-release-mapping.txt&quot; // 可选，设置mapping文件，建议保持旧apk的proguard混淆方式 //applyResourceMapping = &quot;$&#123;bakPath&#125;/$&#123;appName&#125;/app-release-R.txt&quot; // 可选，设置R.txt文件，通过旧apk文件保持ResId的分配 }} 第三步：初始化SDKenableProxyApplication = false 的情况这是Tinker推荐的接入方式，一定程度上会增加接入成本，但具有更好的兼容性。 集成Bugly升级SDK之后，需要按照以下方式自定义ApplicationLike来实现Application的代码（以下是示例）： 自定义Application public class SampleApplication extends TinkerApplication { public SampleApplication() { super(ShareConstants.TINKER_ENABLE_ALL, “xxx.xxx.SampleApplicationLike”, “com.tencent.tinker.loader.TinkerLoader”, false); }} 注意：这个类集成TinkerApplication类，这里面不做任何操作，所有Application的代码都会放到ApplicationLike继承类当中参数解析参数1：tinkerFlags 表示Tinker支持的类型 dex only、library only or all suuport，default: TINKER_ENABLE_ALL参数2：delegateClassName Application代理类 这里填写你自定义的ApplicationLike参数3：loaderClassName Tinker的加载器，使用默认即可参数4：tinkerLoadVerifyFlag 加载dex或者lib是否验证md5，默认为false———————————————— 需要您将以前的Applicaton配置为继承TinkerApplication的类： 教你如何使用Bugly修复线上安卓APP存在的bug_Bugly使用_02 自定义ApplicationLike public class SampleApplicationLike extends DefaultApplicationLike { public static final String TAG = &quot;Tinker.SampleApplicationLike&quot;; public SampleApplicationLike(Application application, int tinkerFlags, boolean tinkerLoadVerifyFlag, long applicationStartElapsedTime, long applicationStartMillisTime, Intent tinkerResultIntent) &#123; super(application, tinkerFlags, tinkerLoadVerifyFlag, applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent); &#125; @Override public void onCreate() &#123; super.onCreate(); // 这里实现SDK初始化，appId替换成你的在Bugly平台申请的appId // 调试时，将第三个参数改为true Bugly.init(getApplication(), &quot;900029763&quot;, false); &#125; @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) @Override public void onBaseContextAttached(Context base) &#123; super.onBaseContextAttached(base); // you must install multiDex whatever tinker is installed! MultiDex.install(base); // 安装tinker // TinkerManager.installTinker(this); 替换成下面Bugly提供的方法 Beta.installTinker(this); &#125; @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) public void registerActivityLifecycleCallback(Application.ActivityLifecycleCallbacks callbacks) &#123; getApplication().registerActivityLifecycleCallbacks(callbacks); &#125; } 注意：tinker需要你开启MultiDex,你需要在dependencies中进行配置compile “com.android.support:multidex:1.0.1”才可以使用MultiDex.install方法； SampleApplicationLike这个类是Application的代理类，以前所有在Application的实现必须要全部拷贝到这里，在onCreate方法调用SDK的初始化方法，在onBaseContextAttached中调用Beta.installTinker(this);。 enableProxyApplication = true 的情况 public class MyApplication extends Application { @Override public void onCreate() &#123; super.onCreate(); // 这里实现SDK初始化，appId替换成你的在Bugly平台申请的appId // 调试时，将第三个参数改为true 900029763自己申请的ID Bugly.init(this, &quot;900029763&quot;, false); &#125; @Override protected void attachBaseContext(Context base) &#123; super.attachBaseContext(base); // you must install multiDex whatever tinker is installed! MultiDex.install(base); // 安装tinker Beta.installTinker(); &#125; } 第四步：AndroidManifest.xml配置 权限配置 第五步：混淆配置为了避免混淆SDK，在Proguard混淆文件中增加以下配置： -dontwarn com.tencent.bugly.**-keep public class com.tencent.bugly.**{*;} 如果你使用了support-v4包，你还需要配置以下混淆规则： -keep class android.support.**{*;} bugly地址：https://bugly.qq.com/docs/user-guide/instruction-manual-android-hotfix/?v=20170322165254Github Demohttps://github.com/BuglyDevTeam/Bugly-Android-Demo ##普通打包##1、编译基准包配置基准包的tinkerId 教你如何使用Bugly修复线上安卓APP存在的bug_热更新_03 inkerId最好是一个唯一标识，例如git版本号、versionName等等。 如果你要测试热更新，你需要对基线版本进行联网上报。 这里强调一下，基线版本配置一个唯一的tinkerId，而这个基线版本能够应用补丁的前提是集成过热更新SDK，并启动上报过联网，这样后台会将这个tinkerId对应到一个目标版本，例如tinkerId= “bugly_1.0.0” 对应了一个目标版本是1.0.0，基于这个版本打的补丁包就能匹配到目标版本。 执行assembleRelease编译生成基准包： 教你如何使用Bugly修复线上安卓APP存在的bug_Bugly使用_04 这个会在build/outputs/bakApk路径下生成每次编译的基准包、混淆配置文件、资源Id文件，如下图所示： 教你如何使用Bugly修复线上安卓APP存在的bug_bugly_05 实际应用中，请注意保存线上发布版本的基准apk包、mapping文件、R.txt文件，如果线上版本有bug，就可以借助tinker-support插件进行补丁包的生成。 启动apk，上报联网数据 每次冷启动都会请求补丁策略，会上报当前版本号和tinkerId，这样后台就能将这个唯一的tinkerId对应到一个版本，大家测试的时候可以打开logcat查看的日志，如下图所示： 教你如何使用Bugly修复线上安卓APP存在的bug_bugly_06 如果看不到log，您需要将bugly初始化的第三个参数设置为true才能看到。##2、对基线版本的bug修复未修复前 教你如何使用Bugly修复线上安卓APP存在的bug_bugly_07 这个类有一个会造成空指针的方法。 修复后 教你如何使用Bugly修复线上安卓APP存在的bug_bugly_08 对产生bug的类进行修复，作为补丁下次覆盖基线版本的类。 ##3、根据基线版本生成补丁包修改待修复apk路径、mapping文件路径、resId文件路径 教你如何使用Bugly修复线上安卓APP存在的bug_安卓开发_09 执行构建补丁包的task 教你如何使用Bugly修复线上安卓APP存在的bug_Bugly使用_10 如果你要生成不同编译环境的补丁包，只需要执行TinkerSupport插件生成的task，比如buildTinkerPatchRelease就能生成release编译环境的补丁包。 注：TinkerSupport插件版本低于1.0.4的，需要使用tinkerPatchRelease来生成补丁包 。 生成的补丁包在build/outputs/patch目录下： 教你如何使用Bugly修复线上安卓APP存在的bug_bugly_11 大家这里可能会有一个疑问，补丁版本是怎么匹配到目标版本的，可以双击patch包，提供的插件会在tinker生成的patch包基础上插入一个MF文件： 教你如何使用Bugly修复线上安卓APP存在的bug_线上修复bug_12 教你如何使用Bugly修复线上安卓APP存在的bug_线上修复bug_13 ##4、上传补丁包到平台上传补丁包到平台并下发编辑规则 教你如何使用Bugly修复线上安卓APP存在的bug_线上修复bug_14 教你如何使用Bugly修复线上安卓APP存在的bug_线上修复bug_15 教你如何使用Bugly修复线上安卓APP存在的bug_热更新_16 点击发布新补丁，上传前面生成的patch包，平台会自动为你匹配到目标版本，你可以选择下发范围（开发设备、全量设备、自定义），填写完备注之后，点击立即下发让补丁生效，这样你就可以在客户端当中收到的策略，SDK会自动帮你把补丁包下到本地。 ##5、测试补丁应用效果启动app应用patch 教你如何使用Bugly修复线上安卓APP存在的bug_安卓开发_17 如果匹配到目标版本，后台就会下发补丁策略，可以在logcat看到如下日志： 教你如何使用Bugly修复线上安卓APP存在的bug_热更新_18 下载成功之后，会立即去合成补丁，可以看到patch合成的日志： 教你如何使用Bugly修复线上安卓APP存在的bug_bugly_19 ##重启app查看效果 教你如何使用Bugly修复线上安卓APP存在的bug_线上修复bug_20 注：方案是基于Tinker方案的实现，需要下次启动才能让补丁生效 ##多渠道打包 tinker是支持打多渠道的，建议大家按照以下步骤进行最佳实践： ##1. 配置productFlavors android { … // 多渠道打包（示例配置） productFlavors &#123; xiaomi &#123; applicationId &#39;com.tencent.bugly.hotfix.xiaomi&#39; &#125; yyb &#123; applicationId &#39;com.tencent.bugly.hotfix.yyb&#39; &#125; &#125; … } ##2. 执行assembleRelease生成基线apk按照普通打包方式正常配置基线版本的tinkerId，然后执行assembleRelease生成不同渠道的apk，会在工程中build/bakApk/生成如下图所示文件： 教你如何使用Bugly修复线上安卓APP存在的bug_bugly_21 ##3. 打渠道补丁包配置 教你如何使用Bugly修复线上安卓APP存在的bug_安卓开发_22 4.执行buildAllFlavorsTinkerPatchRelease生成所有渠道补丁包如下图所示： 教你如何使用Bugly修复线上安卓APP存在的bug_热更新_23 5.测试应用补丁包与普通打包一致。 加固打包（仅支持tinker 1.7.5及以下） tinker的一般模式需要Dex的合成，它并不支持加固，一定要使用加固的app可以使用usePreGeneratedPatchDex模式。由于加固会改变apk的dex结构，所以生成补丁包时务必要使用加固前的apk。但是需要注意的是，某些加固工具会将非exported的四大组件的类名替换，对于这部分类即使使用usePreGeneratedPatchDex也无法修改。对于360加固，MainActivity由于被提前加载，也无法修复。大家对于加固的情况，请仔细测试，能否支持与加固的方式有关联。 1.提前生成dex配置tinker是支持加固模式的，但需要你回退到Qzone方案 ，将usePreGeneratedPatchDex设置为true。 教你如何使用Bugly修复线上安卓APP存在的bug_安卓开发_24 是否提前生成dex，而非合成的方式。这套方案即回退成Qzone的方案，对于需要使用加固或者多flavor打包(建议使用其他方式生成渠道包)的用户可使用。但是这套方案需要插桩，会造成Dalvik下性能损耗以及Art补丁包可能过大的问题，务必谨慎使用。另外一方面，这种方案在AndroidN之后可能会产生问题，建议过滤N之后的用户。 2.将基准包进行加固如果你的app需要进行加固，你需要将你打出的基准包上传到具体的加固平台进行加固，例如乐固，加固完成之后需要对apk进行重签名： jarsigner -verbose -keystore -signedjar 以上命令说明：-verbose：指定生成详细输出-keystore：指定证书存储路径-signedjar：改选项的三个参数分别为签名后的apk包、未签名的apk包、数字证书别名 3.根据加固的基准包生成补丁包打patch包的操作跟普通打包方式一致。 buglySDK下载地址：https://bugly.qq.com/v2/sdkDownload bugly热更新使用指南文档：https://bugly.qq.com/docs/user-guide/api-hotfix/?v=20200622202242","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"Android Studio中代码做混淆方法","slug":"categories/Android/Android Studio中代码做混淆方法","date":"2021-06-20T07:33:40.000Z","updated":"2021-09-01T04:47:49.308Z","comments":true,"path":"2021/06/20/categories/Android/Android Studio中代码做混淆方法/","link":"","permalink":"https://visen123.github.io/2021/06/20/categories/Android/Android%20Studio%E4%B8%AD%E4%BB%A3%E7%A0%81%E5%81%9A%E6%B7%B7%E6%B7%86%E6%96%B9%E6%B3%95/","excerpt":"","text":"##在bulid.gradle文件中： ###设置如下 buildTypes { release &#123; minifyEnabled true proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39; &#125; &#125; 在proguard-rules.pro文件中加入以下代码： ##使用butterknife注入会导致ProGuard 认为变量未被使用，因此，需要在ProGuard 中加入如下字段 -dontwarn butterknife.internal.** -keep class **$$ViewInjector { *; } -keepnames class * { @butterknife.InjectView *;} ##==================gson========================== -dontwarn com.google.** -keep class com.google.gson.**{*;} ##==================protobuf======================- -dontwarn com.google.** -keep class com.google.protobuf.** {*;} ##集成百度地图SDK的应用，在打包混淆的时候，需要注意与地图SDK相关的方法不可被混淆，否则会出现网络不可用等运行时异常。混淆方法如下： -keep class com.baidu.** {*;} -keep class vi.com.** {*;} -dontwarn com.baidu.** -dontwarn com.baidu.mapapi.** -keep class com.baidu.mapapi.** {*; } -keep class assets.** {*; } -keep class vi.com.gdi.bgl.** {*; } ##下面是常见的proguard.cfg配置项 ##指定代码的压缩级别 -optimizationpasses 5 ##包名不混合大小写 -dontusemixedcaseclassnames ##不去忽略非公共的库类 -dontskipnonpubliclibraryclasses ##优化 不优化输入的类文件 -dontoptimize ##预校验 -dontpreverify ##混淆时是否记录日志 -verbose ##混淆时所采用的算法 -optimizations !code/simplification/arithmetic,!field/,!class/merging/ ##保护注解 -keepattributes Annotation 保持哪些类不被混淆-keep public class * extends android.app.Fragment -keep public class * extends android.app.Activity -keep public class * extends android.app.Application -keep public class * extends android.app.Service -keep public class * extends android.content.BroadcastReceiver -keep public class * extends android.content.ContentProvider -keep public class * extends android.app.backup.BackupAgentHelper -keep public class * extends android.preference.Preference -keep public class * extends android.support.v4.** -keep public class com.android.vending.licensing.ILicensingService ##如果有引用v4包可以添加下面这行 -keep public class * extends android.support.v4.app.Fragment ##########JS接口类不混淆，否则执行不了 -dontwarn com.android.JsInterface.** -keep class com.android.JsInterface.** {*; } ##极光推送和百度lbs android sdk一起使用proguard 混淆的问题#http的类被混淆后，导致apk定位失败，保持apache 的http类不被混淆就好了 -dontwarn org.apache.** -keep class org.apache.**{ *; } ##忽略警告 -ignorewarning ##记录生成的日志数据,gradle build时在本项目根目录输出## ##apk 包内所有 class 的内部结构 -dump class_files.txt ##未混淆的类和成员-printseeds seeds.txt ##列出从 apk 中删除的代码 -printusage unused.txt ##混淆前后的映射-printmapping mapping.txt ########记录生成的日志数据，gradle build时 在本项目根目录输出-end##### ######混淆保护自己项目的部分代码以及引用的第三方jar包library######## ##如果引用了v4或者v7包 -dontwarn android.support.** ####混淆保护自己项目的部分代码以及引用的第三方jar包library-end#### -keep public class * extends android.view.View { public (android.content.Context); public (android.content.Context, android.util.AttributeSet); public (android.content.Context, android.util.AttributeSet, int); public void set*(…); } #保持 native 方法不被混淆 -keepclasseswithmembernames class * { native ; } #保持自定义控件类不被混淆 -keepclasseswithmembers class * { public (android.content.Context, android.util.AttributeSet); } #保持自定义控件类不被混淆 -keepclassmembers class * extends android.app.Activity { public void *(android.view.View); } #保持 Parcelable 不被混淆 -keep class * implements android.os.Parcelable { public static final android.os.Parcelable$Creator *; } #保持 Serializable 不被混淆 -keepnames class * implements java.io.Serializable #保持 Serializable 不被混淆并且enum 类也不被混淆 -keepclassmembers class * implements java.io.Serializable { static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; !static !transient &lt;fields&gt;; !private &lt;fields&gt;; !private &lt;methods&gt;; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve(); } #保持枚举 enum 类不被混淆 如果混淆报错，建议直接使用上面的 -keepclassmembers class * implements java.io.Serializable即可 -keepclassmembers enum * { public static **[] values(); public static ** valueOf(java.lang.String); } -keepclassmembers class * { public void *ButtonClicked(android.view.View); } #不混淆资源类 -keepclassmembers class **.R$* { public static &lt;fields&gt;; } #避免混淆泛型 如果混淆报错建议关掉 #–keepattributes Signature #如果用到Gson解析包的，直接添加下面这几行就能成功混淆，不然会报错 #gson #-libraryjars libs/gson-2.2.2.jar -keepattributes Signature Gson specific classes-keep class sun.misc.Unsafe { *; } Application classes that will be serialized/deserialized over Gson-keep class com.google.gson.examples.android.model.** { *; } #客户端代码中的JavaBean(实体类)的类名与其字段名称全部变成了a、b、c、d等等字符串，这与服务端返回的json字符串中的不一致，导致解析失败。所以，解决的办法是：在进行混淆编译进行打包apk的时候，过滤掉存放所有JavaBean（实体类)的包不进行混淆编译 -keep class com.android.model.** {*;}","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"Python年份是否是闰年","slug":"categories/Python/Python年份是否是闰年","date":"2021-06-19T13:26:42.000Z","updated":"2021-09-03T14:45:25.964Z","comments":true,"path":"2021/06/19/categories/Python/Python年份是否是闰年/","link":"","permalink":"https://visen123.github.io/2021/06/19/categories/Python/Python%E5%B9%B4%E4%BB%BD%E6%98%AF%E5%90%A6%E6%98%AF%E9%97%B0%E5%B9%B4/","excerpt":"","text":"代码实现如下：请用Python语言实现一个判断用户输入的年份是否是闰年的程序 提示： 1.能被400整除的年份 2.能被4整除，同时不能被100整除的年份 以上2种方法满足一种即为闰年 ‘’’请用Python语言实现一个判断用户输入的年份是否是闰年的程序提示：1.能被400整除的年份2.能被4整除，同时不能被100整除的年份以上2种方法满足一种即为闰年‘’’while True: year = int(input(‘请输入一个年份:’)) if (year % 400 == 0) or ((year % 4 == 0) and (year % 100 != 0)): print(‘%d是闰年’ % year) else: print(‘%d不是闰年’ % year)","categories":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}],"tags":[],"keywords":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}]},{"title":"Python例子-urllib模拟游览器","slug":"categories/Python/Python例子urllib模拟游览器","date":"2021-06-19T09:26:26.000Z","updated":"2021-09-03T14:42:19.148Z","comments":true,"path":"2021/06/19/categories/Python/Python例子urllib模拟游览器/","link":"","permalink":"https://visen123.github.io/2021/06/19/categories/Python/Python%E4%BE%8B%E5%AD%90urllib%E6%A8%A1%E6%8B%9F%E6%B8%B8%E8%A7%88%E5%99%A8/","excerpt":"","text":"代码实现如下： import urllib.requestimport randomurl = ‘http://www.baidu.com&#39; 方法1，模拟请求头,字典常见请求头https://blog.csdn.net/mouday/article/details/80182397 https://www.cnblogs.com/zrmw/p/9332801.htmlheaders = { ‘Accept’:’application/json,application/javascript,/;q=0.01’, ‘X-Requested-With’:’XMLHttpRequest’, ‘User-Agent’:’Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36’, ‘Content-Type’:’application/x-www-form-urlencoded;charset=utf-8’} 设置一个请求体req = urllib.request.Request(url,headers=headers) 发起请求response = urllib.request.urlopen(req)data = response.read().decode(‘utf-8’) print(type(data)) # &lt;class ‘str’&gt;print(data) # 打印出来的就是百度首页的内容方法2agentList = [ “Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50”, “Mozilla/5.0 (Windows; U; Windows NT 6.1; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50”, “Mozilla/5.0 (Windows NT 10.0; WOW64; rv:38.0) Gecko/20100101 Firefox/38.0”, ]agentStr = random.choice(agentList) # 随机拿一个 print(agentStr)req = urllib.request.Request(url)req.add_header(‘User-Agent’,agentStr) # 逗号，不是冒号response = urllib.request.urlopen(req)data = response.read().decode(‘utf-8’)print(type(data))print(data)","categories":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}],"tags":[],"keywords":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}]},{"title":"Python乱码解码为中文","slug":"categories/Python/Python上公交车并且可以有座位坐下","date":"2021-06-17T11:26:42.000Z","updated":"2021-09-03T07:10:47.976Z","comments":true,"path":"2021/06/17/categories/Python/Python上公交车并且可以有座位坐下/","link":"","permalink":"https://visen123.github.io/2021/06/17/categories/Python/Python%E4%B8%8A%E5%85%AC%E4%BA%A4%E8%BD%A6%E5%B9%B6%E4%B8%94%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%BA%A7%E4%BD%8D%E5%9D%90%E4%B8%8B/","excerpt":"","text":"情节描述：上公交车，并且可以有座位坐下 业务逻辑：输入公交卡当前的余额，只要不低于2元，就可以上公交车；如果车上有空座位，就可以坐下 代码实现如下：while True: CardCash = int(input(‘请输入您的公交卡余额：’)) if CardCash &gt;= 2: print(‘余额足够，您可以上车了’) IsSeat = input(‘车上是否有空座位(有/没有)？’) if IsSeat == ‘有’: print(‘您可以坐下’) else: print(‘没有座位，只能站着’) else: print(‘余额不够，您不能上车’)","categories":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}],"tags":[],"keywords":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}]},{"title":"Python画爱心","slug":"categories/Python/Python画爱心","date":"2021-06-16T11:26:42.000Z","updated":"2021-09-03T07:30:23.516Z","comments":true,"path":"2021/06/16/categories/Python/Python画爱心/","link":"","permalink":"https://visen123.github.io/2021/06/16/categories/Python/Python%E7%94%BB%E7%88%B1%E5%BF%83/","excerpt":"","text":"python 编程画爱心代码实现如下： import time words = input(&#39;Please input the words you want to say!:&#39;) # 例子：words = &quot;Dear lili, Happy Valentine&#39;s Day! Lyon Will Always Love You Till The End! ♥ Forever! ♥&quot; for item in words.split(): # 要想实现打印出字符间的空格效果，此处添加：item = item+&#39; &#39; letterlist = [] # letterlist是所有打印字符的总list，里面包含y条子列表list_X for y in range(12, -12, -1): list_X = [] # list_X是X轴上的打印字符列表，里面装着一个String类的letters letters = &#39;&#39; # letters即为list_X内的字符串，实际是本行要打印的所有字符 for x in range(-40, 40): # *是乘法，**是幂次方 expression = ((x*0.04)**2+(y*0.1)**2-1)**3-(x*0.04)**2*(y*0.1)**3 if expression &lt;= 0: letters += item[(x-y) % len(item)] else: letters += &#39; &#39; list_X.append(letters) letterlist += list_X print(&#39;\\n&#39;.join(letterlist)) time.sleep(1.5) 执行打印爱心结果如下所示： ♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥♥♥♥♥♥♥ ♥♥♥♥♥ ♥","categories":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}],"tags":[],"keywords":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}]},{"title":"Python乱码解码为中文","slug":"categories/Python/乱码解码为中文","date":"2021-06-13T11:26:42.000Z","updated":"2021-09-03T07:02:16.178Z","comments":true,"path":"2021/06/13/categories/Python/乱码解码为中文/","link":"","permalink":"https://visen123.github.io/2021/06/13/categories/Python/%E4%B9%B1%E7%A0%81%E8%A7%A3%E7%A0%81%E4%B8%BA%E4%B8%AD%E6%96%87/","excerpt":"","text":"requests.get(url,headers = headers).text解码为中文今天在使用python3爬虫时，遇到一个关于字符编码的问题，经过网上查找，终于解决了问题，下面记录下来。 1,用requests.get(url)爬取的到数据，中文显示则是乱码，如： æä¾çåå®¹ä»ç¨äºå­¦ä¹ ï¼æµè¯åå¹è®­ãå®ä¾å¯è½ä¸ºäºæ´å®¹æçè§£èç®åãæä»¬ä¸ç´å¯¹æç¨ï¼åèæåï¼å¨çº¿å®ä¾ä¿æä¿®è®¢ï¼ä½æ¯æä»¬ä¸è½ä¿è¯ææåå®¹å¨é¨æ­£ç¡®ãéè¿ä½¿ç¨æ¬ç«è¿è¡å­¦ä¹ éä¹èæ¥çé£é©ä¸æ¬ç«æ å³ãå½ä½¿ç¨æ¬ç«æ¶ï¼ä»£è¡¨æ¨å·²æ¥åäºæ¬ç«çä½¿ç¨æ¡æ¬¾åé，那么，使用content.encode(‘raw_unicode_escape’).decode()就可以用print查看汉字了。 import requestsurl = ‘http://www.python-china.com/&#39;headers = { ‘User-Agent’: ‘Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36’ }contents = requests.get(url,headers = headers).textcn_contents = contents.encode(‘raw_unicode_escape’).decode()print(cn_contents) # 输出了正常的中文文字2,爬到的数据通常是bytes类型，如requests.get的content属性。这时候，我们使用str(content, ‘utf8’)就可以把\\xb7\\xaf\\xe5\\xb8\\xa6\\xe9\\xa3\\x8e这样的内容转化成汉字了。","categories":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}],"tags":[],"keywords":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}]},{"title":"Python例子-图片验证码","slug":"categories/Python/Python例子图片验证码","date":"2021-06-12T12:26:42.000Z","updated":"2021-09-03T07:07:22.830Z","comments":true,"path":"2021/06/12/categories/Python/Python例子图片验证码/","link":"","permalink":"https://visen123.github.io/2021/06/12/categories/Python/Python%E4%BE%8B%E5%AD%90%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81/","excerpt":"","text":"代码实现如下：class ImageCodeView(View): def get(self,request): im = Image.new(&#39;RGB&#39;, (125, 50)) # 图片大小 draw = ImageDraw.Draw(im) font = ImageFont.truetype(settings.BASE_DIR+&#39;/html/static/simhei.ttf&#39;, 55) # 字体位置，字体大小 def random_color1(): &quot;&quot;&quot;随机颜色1（用于填充字体）&quot;&quot;&quot; return random.randint(10, 80), random.randint(10, 80), random.randint(10, 80) def random_color2(): &quot;&quot;&quot;随即颜色2（用于填充背景）&quot;&quot;&quot; return random.randint(100, 255), random.randint(100, 255), random.randint(100, 255) for x in range(125): for y in range(50): draw.point((x, y), fill=random_color2()) # 对每个像素点进行填充 draw.text((10, -2), &#39;ABCD&#39;, font=font,fill=random_color1()) # 10左偏移位置，0上偏移位置 out = BytesIO() im.save(out, format=&#39;png&#39;) # 保存为PNG图片 # out.getvalue()图片的二进制，返回前端游览器 return HttpResponse(out.getvalue(),content_type=&#39;image/png&#39;)","categories":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}],"tags":[],"keywords":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}]},{"title":"Python例子-读取远程页面并写入本地页面","slug":"categories/Python/Python读取远程页面并写入本地页面","date":"2021-06-06T06:26:42.000Z","updated":"2021-09-03T14:44:23.471Z","comments":true,"path":"2021/06/06/categories/Python/Python读取远程页面并写入本地页面/","link":"","permalink":"https://visen123.github.io/2021/06/06/categories/Python/Python%E8%AF%BB%E5%8F%96%E8%BF%9C%E7%A8%8B%E9%A1%B5%E9%9D%A2%E5%B9%B6%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E9%A1%B5%E9%9D%A2/","excerpt":"","text":"import urllib.requestresponse = urllib.request.urlopen(‘http://www.baidu.com&#39;)‘’’ 方法1 读取文件的全部内容，把读取到的数据赋值给一个字符串变量data = response.read() print(type(data)) # &lt;class ‘bytes’&gt;print(data)with open(‘baidu.html’,’wb’) as f: f.write(data)‘’’ 读取文件的全部内容，每行的内容作为列表的一个元素方法2data = response.readlines() #if response.getcode() == 200 or response.getcode() == 304: # 判断是否请求成功 # print(type(data)) # &lt;class ‘list’&gt; # print(type(data[100])) # &lt;class ‘bytes’&gt; 列表每个元素的类型 # print(data) # print(len(data)) with open(‘baidu.html’,’wb’) as f: for con in data: f.write(con)else: print(‘请求失败’) 方法3，一句话就搞定了urllib.request.urlretrieve(‘http://www.baidu.com&#39;,filename=&#39;file2.html&#39;)","categories":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}],"tags":[],"keywords":[{"name":"Python","slug":"Python","permalink":"https://visen123.github.io/categories/Python/"}]},{"title":"微信小程序开发工具常用快捷键","slug":"categories/小程序/微信小程序开发常用快捷键","date":"2021-05-18T07:16:42.000Z","updated":"2021-09-03T15:14:26.743Z","comments":true,"path":"2021/05/18/categories/小程序/微信小程序开发常用快捷键/","link":"","permalink":"https://visen123.github.io/2021/05/18/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"格式调整 Ctrl+S：保存文件 Ctrl+[， Ctrl+]：代码行缩进 Ctrl+Shift+[， Ctrl+Shift+]：折叠打开代码块 Ctrl+C Ctrl+V：复制粘贴，如果没有选中任何文字则复制粘贴一行 Shift+Alt+F：代码格式化 Alt+Up，Alt+Down：上下移动一行 Shift+Alt+Up，Shift+Alt+Down：向上向下复制一行 Ctrl+Shift+Enter：在当前行上方插入一行 光标相关 Ctrl+End：移动到文件结尾 Ctrl+Home：移动到文件开头 Ctrl+i：选中当前行 Shift+End：选择从光标到行尾 Shift+Home：选择从行首到光标处 Ctrl+Shift+L：选中所有匹配 Ctrl+D：选中匹配 Ctrl+U：光标回退","categories":[{"name":"小程序","slug":"小程序","permalink":"https://visen123.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[],"keywords":[{"name":"小程序","slug":"小程序","permalink":"https://visen123.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"导航栏navigation-bar","slug":"categories/小程序/导航栏navigation-bar","date":"2021-05-17T07:26:42.000Z","updated":"2021-09-03T15:07:37.804Z","comments":true,"path":"2021/05/17/categories/小程序/导航栏navigation-bar/","link":"","permalink":"https://visen123.github.io/2021/05/17/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%AF%BC%E8%88%AA%E6%A0%8Fnavigation-bar/","excerpt":"","text":"navigation-bar基础库 2.9.0 开始支持，低版本需做兼容处理。 页面导航条配置节点，用于指定导航栏的一些属性。只能是 page-meta 组件内的第一个节点，需要配合它一同使用。 通过这个节点可以获得类似于调用 wx.setNavigationBarTitle wx.setNavigationBarColor 等接口调用的效果。 属性 类型 默认值 必填 说明 最低版本title string 否 导航条标题 2.9.0loading boolean false 否 是否在导航条显示 loading 加载提示 2.9.0front-color string 否 导航条前景颜色值，包括按钮、标题、状态栏的颜色，仅支持 #ffffff 和 #000000 2.9.0background-color string 否 导航条背景颜色值，有效值为十六进制颜色 2.9.0color-animation-duration number 0 否 改变导航栏颜色时的动画时长，默认为 0 （即没有动画效果） 2.9.0color-animation-timing-func string “linear” 否 改变导航栏颜色时的动画方式，支持 linear 、 easeIn 、 easeOut 和 easeInOut 2.9.0示例代码 Page({ data: { nbFrontColor: ‘#000000’, nbBackgroundColor: ‘#ffffff’, }, onLoad() { this.setData({ nbTitle: ‘新标题’, nbLoading: true, nbFrontColor: ‘#ffffff’, nbBackgroundColor: ‘#000000’, }) }})","categories":[{"name":"小程序","slug":"小程序","permalink":"https://visen123.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[],"keywords":[{"name":"小程序","slug":"小程序","permalink":"https://visen123.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"媒体组件image","slug":"categories/小程序/媒体组件image","date":"2021-05-15T09:26:42.000Z","updated":"2021-09-03T15:07:13.167Z","comments":true,"path":"2021/05/15/categories/小程序/媒体组件image/","link":"","permalink":"https://visen123.github.io/2021/05/15/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%AA%92%E4%BD%93%E7%BB%84%E4%BB%B6image/","excerpt":"","text":"image基础库 1.0.0 开始支持，低版本需做兼容处理。 图片。支持 JPG、PNG、SVG、WEBP、GIF 等格式，2.3.0 起支持云文件ID。 属性 类型 默认值 必填 说明 最低版本src string 否 图片资源地址 1.0.0mode string scaleToFill 否 图片裁剪、缩放的模式 1.0.0webp boolean false 否 默认不解析 webP 格式，只支持网络资源 2.9.0lazy-load boolean false 否 图片懒加载，在即将进入一定范围（上下三屏）时才开始加载 1.5.0show-menu-by-longpress boolean false 否 长按图片显示发送给朋友、收藏、保存图片、搜一搜、打开名片/前往群聊/打开小程序（若图片中包含对应二维码或小程序码）的菜单 2.7.0binderror eventhandle 否 当错误发生时触发，event.detail = {errMsg} 1.0.0bindload eventhandle 否 当图片载入完毕时触发，event.detail = {height, width} 1.0.0mode 的合法值 值 说明 最低版本scaleToFill 缩放模式，不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素aspectFit 缩放模式，保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。aspectFill 缩放模式，保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方向是完整的，另一个方向将会发生截取。widthFix 缩放模式，宽度不变，高度自动变化，保持原图宽高比不变heightFix 缩放模式，高度不变，宽度自动变化，保持原图宽高比不变 2.10.3top 裁剪模式，不缩放图片，只显示图片的顶部区域bottom 裁剪模式，不缩放图片，只显示图片的底部区域center 裁剪模式，不缩放图片，只显示图片的中间区域left 裁剪模式，不缩放图片，只显示图片的左边区域right 裁剪模式，不缩放图片，只显示图片的右边区域top left 裁剪模式，不缩放图片，只显示图片的左上边区域top right 裁剪模式，不缩放图片，只显示图片的右上边区域bottom left 裁剪模式，不缩放图片，只显示图片的左下边区域bottom right 裁剪模式，不缩放图片，只显示图片的右下边区域Bug &amp; Tiptip：image组件默认宽度320px、高度240pxtip：image组件中二维码/小程序码图片不支持长按识别。仅在wx.previewImage中支持长按识别","categories":[{"name":"小程序","slug":"小程序","permalink":"https://visen123.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[],"keywords":[{"name":"小程序","slug":"小程序","permalink":"https://visen123.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"视图容器cover-view","slug":"categories/小程序/视图容器cover-view","date":"2021-05-14T07:32:42.000Z","updated":"2021-09-03T15:03:09.884Z","comments":true,"path":"2021/05/14/categories/小程序/视图容器cover-view/","link":"","permalink":"https://visen123.github.io/2021/05/14/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E8%A7%86%E5%9B%BE%E5%AE%B9%E5%99%A8cover-view/","excerpt":"","text":"cover-view基础库 1.4.0 开始支持，低版本需做兼容处理。 覆盖在原生组件之上的文本视图。 目前原生组件均已支持同层渲染，建议使用 view 替代。可覆盖的原生组件包括 map、video、canvas、camera、live-player、live-pusher 只支持嵌套 cover-view、cover-image，可在 cover-view 中使用 button。组件属性的长度单位默认为px，2.4.0起支持传入单位(rpx/px)。 属性 类型 默认值 必填 说明 最低版本scroll-top number/string 否 设置顶部滚动偏移量，仅在设置了 overflow-y: scroll 成为滚动元素后生效 2.1.0Bug &amp; Tiptip: cover-view和cover-image的aria-role仅可设置为button，读屏模式下才可以点击，并朗读出“按钮”；为空时可以聚焦，但不可点击tip: 基础库 2.2.4 起支持 touch 相关事件，也可使用 hover-class 设置点击态tip: 基础库 2.1.0 起支持设置 scale rotate 的 css 样式，包括 transition 动画tip: 基础库 1.9.90 起 cover-view 支持 overflow: scroll，但不支持动态更新 overflowtip: 基础库 1.9.90 起最外层 cover-view 支持 position: fixedtip: 基础库 1.9.0 起支持插在 view 等标签下。在此之前只可嵌套在原生组件map、video、canvas、camera内，避免嵌套在其他组件内。tip: 基础库 1.6.0 起支持css transition动画，transition-property只支持transform (translateX, translateY)与opacity。tip: 基础库 1.6.0 起支持css opacity。tip: 事件模型遵循冒泡模型，但不会冒泡到原生组件。tip: 文本建议都套上cover-view标签，避免排版错误。tip: 只支持基本的定位、布局、文本样式。不支持设置单边的border、background-image、shadow、overflow: visible等。tip: 建议子节点不要溢出父节点tip: 支持使用 z-index 控制层级tip: 默认设置的样式有：white-space: nowrap; line-height: 1.2; display: block;bug: 自定义组件嵌套 cover-view 时，自定义组件的 slot 及其父节点暂不支持通过 wx:if 控制显隐，否则会导致 cover-view 不显示","categories":[{"name":"小程序","slug":"小程序","permalink":"https://visen123.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[],"keywords":[{"name":"小程序","slug":"小程序","permalink":"https://visen123.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"微信小程序项目设置","slug":"categories/小程序/微信小程序项目设置","date":"2021-05-10T02:00:16.000Z","updated":"2021-09-03T15:02:36.525Z","comments":true,"path":"2021/05/10/categories/小程序/微信小程序项目设置/","link":"","permalink":"https://visen123.github.io/2021/05/10/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"项目页卡主要有三大功能基本信息包括图标、AppID、第三方平台名（只有第三方平台的开发小程序才会显示）、目录信息、上次提交代码的时间以及代码包大小。 基础库版本切换开发者可以在此选择任意基础库版本，用于开发和调试旧版本兼容问题。 clientlib 显示基础库支持的客户端版本工具1.02.2002252或以上版本，开发者可以在此查看任意基础库支持的微信客户端版本范围 clientlibversion 显示灰度中的基础库正式版本的基础库全量发布前，会有一个灰度的过程。 工具1.02.2002252或以上版本，开发者可以在此查看正在灰度中的基础库版本 canaryclientlib 下发测试基础库注意：该功能只能下发到登录开发者工具的微信号的客户端，并会影响到该客户端所有小程序 工具1.02.2003112或以上版本，开发者可以在此选择任意基础库版本并下发到客户端 pushcommonlib 微信客户端对开发版小程序打开调试，可以查看下发测试基础库的生效时间以及版本 pushcommonlibtime pushcommonlibversion 本地设置上传代码时样式自动补全在预览、真机调试、上传时使用 autoprefixer 对 wxss 文件中的样式类自动补全前缀，以对不同的浏览器内核的真机做样式兼容性适配 autoprefixer 的 browsers 参数为 [ ‘iOS &gt;= 8’, ‘Chrome &gt;= 37’, ]，勾选此项会增大代码包体积。 上传代码时自动压缩样式在预览、真机调试、上传时使用 cssnano 对 wxss 文件进行压缩 上传代码时自动压缩混淆在预览、真机调试、上传时使用 UglifyJS 或者 Terser 对 js 文件进行压缩混淆 上传时进行代码保护开启此选项，开发者工具会尝试对项目代码进行保护，主要是对文件进行扁平化处理并替换 require 引用的文件名，以下情况不适合使用此功能 对于小程序只有简单页面的情况下，开启此功能效果不佳有文件超过 500kb，且其中有使用 require 引用项目中的文件的情况，在运行时可能会报文件没有找到动态引用的情况，如 var a = ‘somefile.js’; require(a);将 require 函数赋值给其他变量的情况，如 var a = require; a(‘somefile.js’);将 require 作为二元运算符的参数的情况，如 require + 1;使用 … 运算符且未开启 ES6 转 ES5 的情况自动运行体验评分开启后，模拟器运行时，调试器-Audit 面板将自动运行体验评分检测 auto audit 不校验合法域名、web-view(业务域名)、TLS 版本以及 HTTPS 证书正式发布的小程序的网络请求是需要校验网络请求（wx.request, wx.connectSocket、wx.downloadFile, wx.uploadFile）、 组件允许加载的业务域名是否已经配置成为合法域名，以及域名的 TLS 版本、HTTPS 证书有效性， 其中服务器域名和 业务域名可以在 mp 管理后台 开发-开发管理-开发设置 中进行配置。 在开发过程中可以开启此选项，开发工具将不会校验安全域名、 业务域名，以及 TLS 版本、HTTPS 证书，帮助在开发过程中更方便的完成调试工作。 启用数据预拉取开启后模拟器每次编译都会先同步预拉取数据，详见数据预拉取 启用代码自动热重载开启后，修改代码文件，模拟器可以在不刷新的情况下生效变更。 进入热重载模式后，会在模拟器区域有个显示的提示，该功能在 2.12.0 及以上的基础库生效 注意: App.onLaunch 因没有触发场景无法生效热重载，需要重新点击编译；Page.onLoad 需要重新进入页面热重载的变更才能生效 启用多核心编译开启后开发者工具将使用 node cluster 多核能力进行本地代码编译， 注意：对于双核四线程 CPU 的机器不建议开启该功能 启用自定义处理命令开启后，工具在编译前、预览前、上传前这三个时机调用开发者自定义的命令， 开发者可以去对代码进行一些预处理或者上报的逻辑 项目设置域名信息将显示小程序的安全域名信息，合法域名可在 mp 管理后台 开发-开发管理-开发设置 中进行设置。 host 高级设置将显示小程序代码包允许的大小等其他配置信息","categories":[{"name":"小程序","slug":"小程序","permalink":"https://visen123.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[],"keywords":[{"name":"小程序","slug":"小程序","permalink":"https://visen123.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"微信小程序开发工具下载安装","slug":"categories/小程序/微信小程序开发工具下载安装","date":"2021-05-06T11:26:42.000Z","updated":"2021-09-03T15:02:36.553Z","comments":true,"path":"2021/05/06/categories/小程序/微信小程序开发工具下载安装/","link":"","permalink":"https://visen123.github.io/2021/05/06/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85/","excerpt":"","text":"微信小程序开发工具下载地址如下：https://developers.weixin.qq.com/miniprogram/dev/devtools/stable.html 界面启动页 https://developers.weixin.qq.com/miniprogram/dev/devtools/page.html#独立窗口 登录页在登录页，可以使用微信扫码登录开发者工具，开发者工具将使用这个微信帐号的信息进行小程序的开发和调试。 登录 项目列表登录成功后，会看到已经存在的项目列表和代码片段列表， 在项目列表可以选择公众号网页调试，进入到公众号网页调试模式 项目列表 新建项目当符合以下条件时，可以在本地创建一个小程序项目 需要一个小程序的 AppID；如没有 AppID，可以选择申请使用测试号。登录的微信号需要是该 AppID 的开发者；需要选择一个空目录，或者选择的非空目录下存在 app.json 或者 project.config.json。当选择空目录时，可以选择是否在该目录下生成一个简单的项目。新建项目 多开项目工具支持同时打开多个项目，每次打开项目时会从新窗口打开，入口有以下几种： 从项目选择页打开项目，处于项目窗口时可以从菜单栏的项目 -&gt; 查看所有项目打开项目选择页从菜单栏的最近打开项目列表中打开的项目会从新窗口打开新建项目命令行或 HTTP 调用工具打开项目管理项目对本地项目进行删除和批量删除 管理项目 主界面开发者工具主界面，从上到下，从左到右，分别为：菜单栏、工具栏、模拟器、目录树、编辑区、调试器 六大部分。 菜单栏微信web开发者工具 切换帐号：快速切换登录用户 关于：关于开发者工具 检查更新：检查版本更新 开发者论坛：前往开发者论坛 开发者文档：前往开发者文档 调试：调试开发者工具、调试编辑器；如果遇到疑似开发者工具或者编辑器的 bug，可以打开调试工具查看是否有出错日志，欢迎在论坛上反馈相关问题 更换开发模式：快速切换公众号网页调试和小程序调试 退出：退出开发者工具 项目 新建项目：快速新建项目 打开最近：可以查看最近打开的项目列表，并选择是否进入对应项目 查看所有项目：新窗口打开启动页的项目列表页 关闭当前项目：关闭当前项目，回到启动页的项目列表页 文件 新建文件 保存 保存所有 关闭文件 编辑：可以查看编辑相关的操作和快捷键 工具 编译：编译当前小程序项目 刷新：与编译的功能一致，由于历史原因保留对应的快捷键 ctrl(⌘) + R 编译配置：可以选择普通编译或自定义编译条件 前后台切换：模拟客户端小程序进入后台运行和返回前台的操作 清除缓存：清除文件缓存、数据缓存、以及授权数据 界面：控制主界面窗口模块的显示与隐藏 设置： 外观设置：控制编辑器的配色主题、字体、字号、行距 编辑设置：控制文件保存的行为，编辑器的表现 代理设置：选择直连网络、系统代理和手动设置代理 通知设置：设置是否接受某种类型的通知 工具栏点击用户头像可以打开个人中心，在这里可以便捷的切换用户和查看开发者工具收到的消息。 用户头像右侧是控制主界面模块显示/隐藏的按钮。至少需要有一个模块显示。 工具栏中间，可以选择普通编译，也可以新建并选择自定义条件进行编译和预览。 通过切后台按钮，可以模拟小程序进入后台的情况 工具栏上提供了清缓存的快速入口。可以便捷的清除工具上的文件缓存、数据缓存、还有后台的授权数据，方便开发者调试。 工具栏右侧是开发辅助功能的区域，在这里可以上传代码、版本管理、查看项目详情 工具栏管理在工具栏上点击鼠标右键，可以打开工具栏管理 模拟器模拟器可以模拟小程序在微信客户端的表现。小程序的代码通过编译后可以在模拟器上直接运行。 开发者可以选择不同的设备，也可以添加自定义设备来调试小程序在不同尺寸机型上的适配问题。 在模拟器底部的状态栏，可以直观地看到当前运行小程序的场景值，页面路径及页面参数 独立窗口点击 模拟器/调试器 右上角的按钮可以使用独立窗口显示 模拟器/调试器","categories":[{"name":"小程序","slug":"小程序","permalink":"https://visen123.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[],"keywords":[{"name":"小程序","slug":"小程序","permalink":"https://visen123.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"Java后端开发常用的一些开源工具包","slug":"categories/工具/Java后端开发常用的一些开源工具包","date":"2021-04-28T07:26:42.000Z","updated":"2021-09-07T13:59:16.116Z","comments":true,"path":"2021/04/28/categories/工具/Java后端开发常用的一些开源工具包/","link":"","permalink":"https://visen123.github.io/2021/04/28/categories/%E5%B7%A5%E5%85%B7/Java%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7%E5%8C%85/","excerpt":"","text":"Redis（Remote Dictionary Server )，是一个内存数据库，可持久存储在磁盘上。 数据模型是键值，但支持许多不同类型的值：字符串，列表，集合，排序集合，哈希。 用于数据缓存（比如用于验证短信验证存储），主要用于处理大量数据的高访问负载。异常快 - Redis非常快，每秒可执行大约110000次的设置(SET)操作，每秒大约可执行81000次的读取/获取(GET)操作。支持丰富的数据类型 - Redis支持开发人员常用的大多数数据类型，例如列表，集合，排序集和散列等等。可用于多种用例，如：缓存，消息队列(Redis本地支持发布/订阅)，应用程序中的任何短期数据，例如，web应用程序中的会话，网页命中计数等。启动命令：redis-server.exe redis.windows.conf Minio Server：对象存储服务器，用于存储非结构化数据。对于中小型企业，不存储到云（比如阿里云OSS），可以创建bucket，上传文件。 Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。 *Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的机器上，也可以实现虚拟化。 Elasticsearch是一个基于Lucene的搜索引擎。它提供了一个开源、分布式多用户能力的全文搜索引擎。 RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。 微服务：一种软件开发技术—— 面向服务的体系结构（SOA）架构样式的一种变体，将应用程序构造为一组松散耦合的服务。 AXURE RP9:原型设计，用于设计人员和开发人员交接。 项目搭建步骤： 功能需求-&gt;原型构建-&gt;建表-&gt;根据前端需要展现的功能进行接口编写 Spring+Mybatis-plus搭建骨架：Mybaitis-plus（MyBatis升级版），可以直接生成实体类等代码。","categories":[{"name":"工具","slug":"工具","permalink":"https://visen123.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[],"keywords":[{"name":"工具","slug":"工具","permalink":"https://visen123.github.io/categories/%E5%B7%A5%E5%85%B7/"}]},{"title":"Android机子屏幕适配最简单最全面方案","slug":"categories/Android/Android机子屏幕适配最简单最全面方案","date":"2020-08-25T06:38:49.000Z","updated":"2021-09-01T04:22:01.484Z","comments":true,"path":"2020/08/25/categories/Android/Android机子屏幕适配最简单最全面方案/","link":"","permalink":"https://visen123.github.io/2020/08/25/categories/Android/Android%E6%9C%BA%E5%AD%90%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E6%9C%80%E7%AE%80%E5%8D%95%E6%9C%80%E5%85%A8%E9%9D%A2%E6%96%B9%E6%A1%88/","excerpt":"","text":"调试布局会发现，每款手机显示的布局效果有时候不尽人意，这是因为我们在写代码时，只针对了调试机型屏幕做了设计，而没有考虑到每个手机适配的问题，虽然大家都知道使用dp，但是并没能完全解决问题，而且在美工小伙伴也不会设计dp的图出来给你作为参考。今天就给大家介绍一款适配，来自鸿洋大神之手的工具AutoLayout：https://github.com/hongyangAndroid/AndroidAutoLayout 相信很多同学是知道这个库的，就是不知道怎么使用，什么导入module，什么注明之类的，今天写给大家的方法，绝对最简单，最方便！ 在build.gradle添加依赖 compile ‘com.zhy:autolayout:1.4.5’ 在AndroidManifest清单文件中注明你要设计的初始屏幕尺寸 也就是在你的项目的中注明你的设计稿（美工给你的）的尺寸。 最后使用让你的Activity继承AutoLayoutActivity 现在你就可以安心的使用UI设计图了！可以在布局中直接写px，而不用再担心去换算dp的问题了！","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"分享Android短视频制作","slug":"categories/Android/分享Android短视频制作","date":"2020-08-21T08:38:34.000Z","updated":"2020-08-22T16:01:31.628Z","comments":true,"path":"2020/08/21/categories/Android/分享Android短视频制作/","link":"","permalink":"https://visen123.github.io/2020/08/21/categories/Android/%E5%88%86%E4%BA%ABAndroid%E7%9F%AD%E8%A7%86%E9%A2%91%E5%88%B6%E4%BD%9C/","excerpt":"","text":"如何制作短视频APP，具体做法如下介绍： 准备材料并配置项目工程： 1、去下载七牛云播放器SDK 2、然后把pldroid-player-2.1.6.jar包拷贝到你项目lib文件里，详情如下图所示： 3、把整个jniLibs文件夹里面的所有内容都拷贝到你项目src/main/里，详情如下图所示： 4、然后在你项目build.gradle进行关联 android { sourceSets { main { jniLibs.srcDirs = [‘src/main/jniLibs’] } } } dependencies { implementation files(‘libs/pldroid-player-2.1.6.jar’) implementation ‘com.bugsnag:bugsnag-android-ndk:1.1.2’ implementation ‘com.android.support:appcompat-v7:27.1.0’ implementation ‘com.journeyapps:zxing-android-embedded:3.0.2@aar’ implementation ‘com.google.zxing:core:3.2.0’ } 5、然后在你项目xml布局里添加如下代码，PLVideoView控件： 6、最后去在你Activity里找到这个控件并配置播放器代码： mVideoView = findViewById(R.id.VideoView);AVOptionsoptions = newAVOptions(); options.setInteger(AVOptions.KEY_PREPARE_TIMEOUT,10*1000); options.setInteger(AVOptions.KEY_MEDIACODEC,AVOptions.MEDIA_CODEC_SW_DECODE); options.setInteger(AVOptions.KEY_LIVE_STREAMING,1); options.setInteger(AVOptions.KEY_LOG_LEVEL,0); mVideoView.setAVOptions(options);// Set some listenersmVideoView.setOnInfoListener(mOnInfoListener); mVideoView.setOnVideoSizeChangedListener(mOnVideoSizeChangedListener); mVideoView.setOnBufferingUpdateListener(mOnBufferingUpdateListener); mVideoView.setOnCompletionListener(mOnCompletionListener); mVideoView.setOnErrorListener(mOnErrorListener); mVideoView.setOnVideoFrameListener(mOnVideoFrameListener); mVideoView.setOnAudioFrameListener(mOnAudioFrameListener); mVideoView.setVideoPath(videoPath); mVideoView.setDisplayAspectRatio(mDisplayAspectRatio); mVideoView.setLooping(true);// You can also use a custom MediaController widgetmMediaController = new MediaController(this, !mIsLiveStreaming, mIsLiveStreaming); mMediaController.setOnClickSpeedAdjustListener(mOnClickSpeedAdjustListener); mVideoView.setMediaController(mMediaController); 最后展示一下效果： 最后附上代码下载地址：https://github.com/Visen123/ShortVideo如果觉得使用方便，请给我的github 点个赞，谢谢！","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"Android 高效的SQLite型数据库greenDAO使用","slug":"categories/Android/Android-高效的SQLite型数据库greenDAO使用","date":"2020-08-20T13:30:04.000Z","updated":"2020-08-21T07:10:18.174Z","comments":true,"path":"2020/08/20/categories/Android/Android-高效的SQLite型数据库greenDAO使用/","link":"","permalink":"https://visen123.github.io/2020/08/20/categories/Android/Android-%E9%AB%98%E6%95%88%E7%9A%84SQLite%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93greenDAO%E4%BD%BF%E7%94%A8/","excerpt":"","text":"使用：在你project项目的build.gradle配置如下：buildscript {repositories {mavenCentral()}dependencies {classpath ‘org.greenrobot:greendao-gradle-plugin:3.2.2’}} // 使用数据库升级辅助GreenDaoUpgradeHelper时添加allprojects {repositories {maven { url “https://jitpack.io&quot; }}} 在你的modules 里app/build.gradle里配置如下： apply plugin: ‘org.greenrobot.greendao’ dependencies {compile ‘org.greenrobot:greendao:3.2.2’ // 使用数据库加密时添加compile ‘net.zetetic:android-database-sqlcipher:3.5.6’ // 使用数据库升级辅助GreenDaoUpgradeHelper时添加compile ‘com.github.yuweiguocn:GreenDaoUpgradeHelper:v2.0.1’ } greendao {schemaVersion 1daoPackage ‘com.greendao.dbtargetGenDir ‘src/main/java’} 首先，新建datamodel包，用以包含DaoMaster、DaoSession、bean和beanDao等。br/&gt; 然后新建Area实体类，代码如下： @Entitypublic class Area {br/&gt;@Idprivate String AreaCode;private String AreaName;} 最后，Build-&gt;Make Module ‘app’，即可自动生成DaoMaster、DaoSession、Area和AreaDao。此时Area实体类的代码如下：br/&gt;@Entitypublic class Area {br/&gt;@Idprivate String AreaCode;private String AreaName;@Generated(hash = 262290694)public Area(String AreaCode, String AreaName) {this.AreaCode = AreaCode;this.AreaName = AreaName;}@Generated(hash = 179626505)public Area() {}public String getAreaCode() {return this.AreaCode;}public void setAreaCode(String AreaCode) {this.AreaCode = AreaCode;}public String getAreaName() {return this.AreaName;}public void setAreaName(String AreaName) {this.AreaName = AreaName;}} 添加其他实体类的方法与Area一样。需要注意的是，不要手动修改DaoMaster、DaoSession、bean和beanDao的代码，因为每一次编译项目，都会重新生成一次DaoMaster、DaoSession、bean和beanDao。如果修改的话，就会被覆盖掉。 为了便于数据的读取和添加，新建GreenDaoHelper辅助类，代码如下：public class GreenDaoHelper extends Application {private GreenDaoHelper Instance;private static DaoMaster daoMaster;private static DaoSession daoSession; public GreenDaoHelper getInstance() { if (Instance == null) { Instance = this; } return Instance;} /** 获取DaoMaster @param context @return /public static DaoMaster getDaoMaster(Context context) { if (daoMaster == null) { try&#123; DaoMaster.OpenHelper helper = new DaoMaster.DevOpenHelper(context,&quot;test.db&quot;,null); daoMaster = new DaoMaster(helper.getWritableDatabase()); //获取未加密的数据库 &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; } return daoMaster;} /** 获取DaoSession对象 @param context @return /public static DaoSession getDaoSession(Context context) { if (daoSession == null) { if (daoMaster == null) &#123; getDaoMaster(context); &#125; daoSession = daoMaster.newSession(); } return daoSession;} } 在读写数据库之前，要添加读写权限： 在MainActivity.java中添加读写代码：public class MainActivity extends AppCompatActivity { private TextView textview;private DaoSession session; @Overrideprotected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textview=(TextView)findViewById(R.id.textview); session = GreenDaoHelper.getDaoSession(this); session.getAreaDao().deleteAll();//清空所有记录 //添加记录 Area area = new Area(&quot;01&quot;,&quot;北京&quot;); Area area1 = new Area(&quot;02&quot;,&quot;天津&quot;); session.getAreaDao().insert(area); session.getAreaDao().insert(area1); //查询记录 StringBuilder stringBuilder = new StringBuilder(); List&lt;Area&gt; areas = session.getAreaDao().loadAll(); for (int i = 0,n = areas.size();i&lt;n;++i)&#123; stringBuilder.append(&quot;地区编码：&quot;).append(areas.get(i).getAreaCode()) .append(&quot;，地区名称：&quot;).append(areas.get(i).getAreaName()).append(&quot;\\n&quot;); &#125; textview.setText(stringBuilder); } } 运行结果如下图所示： 修改数据库文件路径： 默认情况下，新创建的数据存储在data的包名目录下，设备如果不root的话，是无法查看SQLite数据库文件的。而实际应用中，我们往往需要copy数据库，或借用第三方工具查阅或编辑数据库内容。此时我们可以通过重写Context的getDatabasePath(String name)、openOrCreateDatabase(String name, int mode, CursorFactory factory)、openOrCreateDatabase(String name, int mode, CursorFactory factory, DatabaseErrorHandler errorHandler)等三个方法来修改SQLite文件的存储路径。 public class GreenDaoHelper extends Application {private GreenDaoHelper Instance;private static DaoMaster daoMaster;private static DaoSession daoSession; public GreenDaoHelper getInstance() { if (Instance == null) { Instance = this; } return Instance;} /** 获取DaoMaster @param context @return /public static DaoMaster getDaoMaster(Context context) { if (daoMaster == null) { try&#123; ContextWrapper wrapper = new ContextWrapper(context) &#123; /** * 获得数据库路径，如果不存在，则创建对象对象 * * @param name */ @Override public File getDatabasePath(String name) &#123; // 判断是否存在sd卡 boolean sdExist = android.os.Environment.MEDIA_MOUNTED.equals(android.os.Environment.getExternalStorageState()); if (!sdExist) &#123;// 如果不存在, Log.e(&quot;SD卡管理：&quot;, &quot;SD卡不存在，请加载SD卡&quot;); return null; &#125; else &#123;// 如果存在 // 获取sd卡路径 String dbDir = android.os.Environment.getExternalStorageDirectory().getAbsolutePath(); dbDir += &quot;/Android&quot;;// 数据库所在目录 String dbPath = dbDir + &quot;/&quot; + name;// 数据库路径 // 判断目录是否存在，不存在则创建该目录 File dirFile = new File(dbDir); if (!dirFile.exists()) dirFile.mkdirs(); // 数据库文件是否创建成功 boolean isFileCreateSuccess = false; // 判断文件是否存在，不存在则创建该文件 File dbFile = new File(dbPath); if (!dbFile.exists()) &#123; try &#123; isFileCreateSuccess = dbFile.createNewFile();// 创建文件 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; else isFileCreateSuccess = true; // 返回数据库文件对象 if (isFileCreateSuccess) return dbFile; else return super.getDatabasePath(name); &#125; &#125; /** * 重载这个方法，是用来打开SD卡上的数据库的，android 2.3及以下会调用这个方法。 * * @param name * @param mode * @param factory */ @Override public SQLiteDatabase openOrCreateDatabase(String name, int mode, SQLiteDatabase.CursorFactory factory) &#123; return SQLiteDatabase.openOrCreateDatabase(getDatabasePath(name), null); &#125; /** * Android 4.0会调用此方法获取数据库。 * * @see android.content.ContextWrapper#openOrCreateDatabase(java.lang.String, * int, * android.database.sqlite.SQLiteDatabase.CursorFactory, * android.database.DatabaseErrorHandler) * @param name * @param mode * @param factory * @param errorHandler */ @Override public SQLiteDatabase openOrCreateDatabase(String name, int mode, SQLiteDatabase.CursorFactory factory, DatabaseErrorHandler errorHandler) &#123; return SQLiteDatabase.openOrCreateDatabase(getDatabasePath(name), null); &#125; &#125;; DaoMaster.OpenHelper helper = new DaoMaster.DevOpenHelper(wrapper,&quot;test.db&quot;,null); daoMaster = new DaoMaster(helper.getWritableDatabase()); //获取未加密的数据库 &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; } return daoMaster;} /** 获取DaoSession对象 @param context @return /public static DaoSession getDaoSession(Context context) { if (daoSession == null) { if (daoMaster == null) &#123; getDaoMaster(context); &#125; daoSession = daoMaster.newSession(); } return daoSession;} } 版本升级更新比如需要在实体类加一个字段 或者 改变字段属性等 就需要版本更新来保存以前的数据了； public class Helper extends DaoMaster.OpenHelper{ private static DaoMaster daoMaster;private static DaoSession daoSession; public static final String DBNAME = “greendao.db”; public Helper(Context context){ super(context,DBNAME,null);} @Overridepublic void onUpgrade(Database db, int oldVersion, int newVersion) { super.onUpgrade(db, oldVersion, newVersion); Log.i(“version”, oldVersion + “—先前和更新之后的版本—“ + newVersion); if (oldVersion &lt; newVersion) { Log.i(“version”, oldVersion + “—先前和更新之后的版本—“ + newVersion); MigrationHelper.getInstance().migrate(db, UserDao.class); //更改过的实体类(新增的不用加) 更新UserDao文件 可以添加多个 XXDao.class 文件 // MigrationHelper.getInstance().migrate(db, UserDao.class,XXDao.class);}} /** 取得DaoMaster @param context @return /public static DaoMaster getDaoMaster(Context context) { if (daoMaster == null) { DaoMaster.OpenHelper helper = new DaoMaster.DevOpenHelper(context, DBNAME, null); daoMaster = new DaoMaster(helper.getWritableDatabase()); } return daoMaster;} /** 取得DaoSession @param context @return /public static DaoSession getDaoSession(Context context) { if (daoSession == null) { if (daoMaster == null) &#123; daoMaster = getDaoMaster(context); &#125; daoSession = daoMaster.newSession(); } return daoSession;} } public class GreenApplication extends Application {private DaoMaster.DevOpenHelper mHelper;//private Helper mHelper;private SQLiteDatabase db;private DaoMaster mDaoMaster;private DaoSession mDaoSession;public static GreenApplication instances;@Override public void onCreate() {super.onCreate();instances = this;setDatabase();}public static GreenApplication getInstances(){return instances;} /**•设置greenDao*/private void setDatabase() {// 通过 DaoMaster 的内部类 DevOpenHelper，你可以得到一个便利的 SQLiteOpenHelper 对象。// 可能你已经注意到了，你并不需要去编写「CREATE TABLE」这样的 SQL 语句，因为 greenDAO 已经帮你做了。// 注意：默认的 DaoMaster.DevOpenHelper 会在数据库升级时，删除所有的表，意味着这将导致数据的丢失。// 所以，在正式的项目中，你还应该做一层封装，来实现数据库的安全升级。 mHelper = new Helper(new GreenDaoUtils(this)); //mHelper = new DaoMaster.DevOpenHelper(this, “notes-db”, null);db = mHelper.getWritableDatabase();// 注意：该数据库连接属于 DaoMaster，所以多个 Session 指的是相同的数据库连接。mDaoMaster = new DaoMaster(db);mDaoSession = mDaoMaster.newSession();}public DaoSession getDaoSession() {return mDaoSession;}public SQLiteDatabase getDb() {return db;}}","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"android自定义优雅日历","slug":"categories/Android/android自定义优雅日历","date":"2020-08-20T07:56:55.000Z","updated":"2020-08-21T07:10:18.017Z","comments":true,"path":"2020/08/20/categories/Android/android自定义优雅日历/","link":"","permalink":"https://visen123.github.io/2020/08/20/categories/Android/android%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BC%98%E9%9B%85%E6%97%A5%E5%8E%86/","excerpt":"","text":"Adroid自定义优雅、性能高效的日历控件，完美支持周视图，支持标记、自定义颜色、农历等，任意控制月视图显示、任意日期拦截条件、自定义周起始等。Canvas绘制，极速性能、占用内存低，，支持简单定制即可实现任意自定义布局、自定义UI，支持收缩展开、性能非常高效， 这个控件内存和效率优势相当明显，而且真正做到收缩+展开，适配多种场景，支持同时多种颜色标记日历事务，支持多点触控，你真的想不到日历还可以如此优雅！更多参考用法请移步Demo，Demo实现了4个精美的自定义效果。 dependencies { implementation ‘com.github.Visen123:CalendarView:V1.0’ } 混淆proguard-rules-keepclasseswithmembers class * {public (android.content.Context);}或者针对性的使用混淆-keep class your project path.MonthView {public (android.content.Context);}-keep class your project path.WeekBar {public (android.content.Context);}-keep class your project path.WeekView {public (android.content.Context);} 特别的，请注意不要复制这三个路径，自行替换您自己的自定义路径 app:month_view=”com.yanyiyun.calendarviewproject.simple.SimpleCalendarCardView”app:week_view=”com.yanyiyun.calendarviewproject.simple.SimpleWeekView”app:week_bar_view=”com.yanyiyun.calendarviewproject.EnglishWeekBar”使用方法 &lt;com.yanyiyun.calendarview.CalendarLayout android:layout_width=”match_parent” android:layout_height=”match_parent” android:orientation=”vertical” app:default_status=”shrink” app:calendar_show_mode=”only_week_view” app:calendar_content_view_id=”@+id/recyclerView”&gt; &lt;com.yanyiyun.calendarview.CalendarView android:id=&quot;@+id/calendarView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#fff&quot; app:month_view=&quot;com.yanyiyun.calendarviewproject.simple.SimpleCalendarCardView&quot; app:week_view=&quot;com.yanyiyun.calendarviewproject.simple.SimpleWeekView&quot; app:week_bar_view=&quot;com.yanyiyun.calendarviewproject.EnglishWeekBar&quot; app:calendar_height=&quot;50dp&quot; app:current_month_text_color=&quot;#333333&quot; app:current_month_lunar_text_color=&quot;#CFCFCF&quot; app:min_year=&quot;2004&quot; app:other_month_text_color=&quot;#e1e1e1&quot; app:scheme_text=&quot;假&quot; app:scheme_text_color=&quot;#333&quot; app:scheme_theme_color=&quot;#333&quot; app:selected_text_color=&quot;#fff&quot; app:selected_theme_color=&quot;#333&quot; app:week_start_with=&quot;mon&quot; app:week_background=&quot;#fff&quot; app:month_view_show_mode=&quot;mode_only_current&quot; app:week_text_color=&quot;#111&quot; /&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/recyclerView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#d4d4d4&quot; /&gt; &lt;/com.yanyiyun.calendarview.CalendarLayout&gt; CalendarView attrs &lt;attr name=&quot;calendar_padding&quot; format=&quot;dimension&quot; /&gt;&lt;!--日历内部左右padding--&gt; &lt;attr name=&quot;month_view&quot; format=&quot;color&quot; /&gt; &lt;!--自定义类日历月视图路径--&gt; &lt;attr name=&quot;week_view&quot; format=&quot;string&quot; /&gt; &lt;!--自定义类周视图路径--&gt; &lt;attr name=&quot;week_bar_height&quot; format=&quot;dimension&quot; /&gt; &lt;!--星期栏的高度--&gt; &lt;attr name=&quot;week_bar_view&quot; format=&quot;color&quot; /&gt; &lt;!--自定义类周栏路径，通过自定义则 week_text_color week_background xml设置无效，当仍可java api设置--&gt; &lt;attr name=&quot;week_line_margin&quot; format=&quot;dimension&quot; /&gt;&lt;!--线条margin--&gt; &lt;attr name=&quot;week_line_background&quot; format=&quot;color&quot; /&gt;&lt;!--线条颜色--&gt; &lt;attr name=&quot;week_background&quot; format=&quot;color&quot; /&gt; &lt;!--星期栏的背景--&gt; &lt;attr name=&quot;week_text_color&quot; format=&quot;color&quot; /&gt; &lt;!--星期栏文本颜色--&gt; &lt;attr name=&quot;week_text_size&quot; format=&quot;dimension&quot; /&gt;&lt;!--星期栏文本大小--&gt; &lt;attr name=&quot;current_day_text_color&quot; format=&quot;color&quot; /&gt; &lt;!--今天的文本颜色--&gt; &lt;attr name=&quot;current_day_lunar_text_color&quot; format=&quot;color&quot; /&gt;&lt;!--今天的农历文本颜色--&gt; &lt;attr name=&quot;calendar_height&quot; format=&quot;string&quot; /&gt; &lt;!--日历每项的高度，56dp--&gt; &lt;attr name=&quot;day_text_size&quot; format=&quot;string&quot; /&gt; &lt;!--天数文本大小--&gt; &lt;attr name=&quot;lunar_text_size&quot; format=&quot;string&quot; /&gt; &lt;!--农历文本大小--&gt; &lt;attr name=&quot;scheme_text&quot; format=&quot;string&quot; /&gt; &lt;!--标记文本--&gt; &lt;attr name=&quot;scheme_text_color&quot; format=&quot;color&quot; /&gt; &lt;!--标记文本颜色--&gt; &lt;attr name=&quot;scheme_month_text_color&quot; format=&quot;color&quot; /&gt; &lt;!--标记天数文本颜色--&gt; &lt;attr name=&quot;scheme_lunar_text_color&quot; format=&quot;color&quot; /&gt; &lt;!--标记农历文本颜色--&gt; &lt;attr name=&quot;scheme_theme_color&quot; format=&quot;color&quot; /&gt; &lt;!--标记的颜色--&gt; &lt;attr name=&quot;selected_theme_color&quot; format=&quot;color&quot; /&gt; &lt;!--选中颜色--&gt; &lt;attr name=&quot;selected_text_color&quot; format=&quot;color&quot; /&gt; &lt;!--选中文本颜色--&gt; &lt;attr name=&quot;selected_lunar_text_color&quot; format=&quot;color&quot; /&gt; &lt;!--选中农历文本颜色--&gt; &lt;attr name=&quot;current_month_text_color&quot; format=&quot;color&quot; /&gt; &lt;!--当前月份的字体颜色--&gt; &lt;attr name=&quot;other_month_text_color&quot; format=&quot;color&quot; /&gt; &lt;!--其它月份的字体颜色--&gt; &lt;attr name=&quot;current_month_lunar_text_color&quot; format=&quot;color&quot; /&gt; &lt;!--当前月份农历节假日颜色--&gt; &lt;attr name=&quot;other_month_lunar_text_color&quot; format=&quot;color&quot; /&gt; &lt;!--其它月份农历节假日颜色--&gt; &lt;!-- 年视图相关 --&gt; &lt;attr name=&quot;year_view_month_text_size&quot; format=&quot;dimension&quot; /&gt; &lt;!-- 年视图月份字体大小 --&gt; &lt;attr name=&quot;year_view_day_text_size&quot; format=&quot;dimension&quot; /&gt; &lt;!-- 年视图月份日期字体大小 --&gt; &lt;attr name=&quot;year_view_month_text_color&quot; format=&quot;color&quot; /&gt; &lt;!-- 年视图月份字体颜色 --&gt; &lt;attr name=&quot;year_view_day_text_color&quot; format=&quot;color&quot; /&gt; &lt;!-- 年视图日期字体颜色 --&gt; &lt;attr name=&quot;year_view_scheme_color&quot; format=&quot;color&quot; /&gt; &lt;!-- 年视图标记颜色 --&gt; &lt;attr name=&quot;min_year&quot; format=&quot;integer&quot; /&gt; &lt;!--最小年份1900--&gt; &lt;attr name=&quot;max_year&quot; format=&quot;integer&quot; /&gt; &lt;!--最大年份2099--&gt; &lt;attr name=&quot;min_year_month&quot; format=&quot;integer&quot; /&gt; &lt;!--最小年份对应月份--&gt; &lt;attr name=&quot;max_year_month&quot; format=&quot;integer&quot; /&gt; &lt;!--最大年份对应月份--&gt; &lt;!--月视图是否可滚动--&gt; &lt;attr name=&quot;month_view_scrollable&quot; format=&quot;boolean&quot; /&gt; &lt;!--周视图是否可滚动--&gt; &lt;attr name=&quot;week_view_scrollable&quot; format=&quot;boolean&quot; /&gt; &lt;!--年视图是否可滚动--&gt; &lt;attr name=&quot;year_view_scrollable&quot; format=&quot;boolean&quot; /&gt; &lt;!--配置你喜欢的月视图显示模式模式--&gt; &lt;attr name=&quot;month_view_show_mode&quot;&gt; &lt;enum name=&quot;mode_all&quot; value=&quot;0&quot; /&gt; &lt;!--全部显示--&gt; &lt;enum name=&quot;mode_only_current&quot; value=&quot;1&quot; /&gt; &lt;!--仅显示当前月份--&gt; &lt;enum name=&quot;mode_fix&quot; value=&quot;2&quot; /&gt; &lt;!--自适应显示，不会多出一行，但是会自动填充--&gt; &lt;/attr&gt; &lt;!-- 自定义周起始 --&gt; &lt;attr name=&quot;week_start_with&quot;&gt; &lt;enum name=&quot;sun&quot; value=&quot;1&quot; /&gt; &lt;enum name=&quot;mon&quot; value=&quot;2&quot; /&gt; &lt;enum name=&quot;sat&quot; value=&quot;7&quot; /&gt; &lt;/attr&gt; &lt;!-- 自定义选择模式 --&gt; &lt;attr name=&quot;select_mode&quot;&gt; &lt;enum name=&quot;default_mode&quot; value=&quot;0&quot; /&gt; &lt;enum name=&quot;single_mode&quot; value=&quot;1&quot; /&gt; &lt;enum name=&quot;range_mode&quot; value=&quot;2&quot; /&gt; &lt;/attr&gt; &lt;!-- 当 select_mode=range_mode --&gt; &lt;attr name=&quot;min_select_range&quot; format=&quot;integer&quot; /&gt; &lt;attr name=&quot;max_select_range&quot; format=&quot;integer&quot; /&gt; CalendarView api public void setRange(int minYear, int minYearMonth, int minYearDay, int maxYear, int maxYearMonth, int maxYearDay) ;//置日期范围 public int getCurDay(); //今天public int getCurMonth(); //当前的月份public int getCurYear(); //今年 public boolean isYearSelectLayoutVisible();//年月份选择视图是否打开public void closeYearSelectLayout();//关闭年月视图选择布局public void showYearSelectLayout(final int year); //快速弹出年份选择月份 public void setOnMonthChangeListener(OnMonthChangeListener listener);//月份改变事件 public void setOnYearChangeListener(OnYearChangeListener listener);//年份切换事件 public void setOnCalendarSelectListener(OnCalendarSelectListener listener)//日期选择事件 public void setOnCalendarLongClickListener(OnCalendarLongClickListener listener);//日期长按事件 public void setOnCalendarLongClickListener(OnCalendarLongClickListener listener, boolean preventLongPressedSelect);//日期长按事件 public void setOnCalendarInterceptListener(OnCalendarInterceptListener listener);//日期拦截和日期有效性绘制 public void setSchemeDate(Map&lt;String, Calendar&gt; mSchemeDates);//标记日期 public void update();//动态更新 public Calendar getSelectedCalendar(); //获取选择的日期 /** 特别的，如果你需要自定义或者使用其它选择器，可以用以下方法进行和日历联动 /public void scrollToCurrent();//滚动到当前日期 public void scrollToCurrent(boolean smoothScroll);//滚动到当前日期 public void scrollToYear(int year);//滚动到某一年 public void scrollToPre();//滚动到上一个月 public void scrollToNext();//滚动到下一个月 public void scrollToCalendar(int year, int month, int day);//滚动到指定日期 public Calendar getMinRangeCalendar();//获得最小范围日期 public Calendar getMaxRangeCalendar();//获得最大范围日期 /** 设置背景色 @param monthLayoutBackground 月份卡片的背景色 @param weekBackground 星期栏背景色 @param lineBg 线的颜色 /public void setBackground(int monthLayoutBackground, int weekBackground, int lineBg) /** 设置文本颜色 @param curMonthTextColor 当前月份字体颜色 @param otherMonthColor 其它月份字体颜色 @param lunarTextColor 农历字体颜色 /public void setTextColor(int curMonthTextColor,int otherMonthColor,int lunarTextColor) /** 设置选择的效果 @param style 选中的style CalendarCardView.STYLE_FILL or CalendarCardView.STYLE_STROKE @param selectedThemeColor 选中的标记颜色 @param selectedTextColor 选中的字体颜色 /public void setSelectedColor(int style, int selectedThemeColor, int selectedTextColor) /** 设置标记的色 @param style 标记的style CalendarCardView.STYLE_FILL or CalendarCardView.STYLE_STROKE @param schemeColor 标记背景色 @param schemeTextColor 标记字体颜色 /public void setSchemeColor(int style, int schemeColor, int schemeTextColor) /** 设置星期栏的背景和字体颜色 @param weekBackground 背景色 @param weekTextColor 字体颜色 /public void setWeeColor(int weekBackground, int weekTextColor)CalendarLayout apipublic void expand(); //展开 public void shrink(); //收缩 public boolean isExpand();//是否展开了CalendarLayout attrs &lt;项目地址：https://github.com/Visen123/CalendarView&gt;","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"编写使用Android 系统自带的文字转语音代码","slug":"categories/Android/编写使用Android-系统自带的文字转语音代码","date":"2020-08-20T07:56:55.000Z","updated":"2020-08-21T07:10:18.127Z","comments":true,"path":"2020/08/20/categories/Android/编写使用Android-系统自带的文字转语音代码/","link":"","permalink":"https://visen123.github.io/2020/08/20/categories/Android/%E7%BC%96%E5%86%99%E4%BD%BF%E7%94%A8Android-%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%B8%A6%E7%9A%84%E6%96%87%E5%AD%97%E8%BD%AC%E8%AF%AD%E9%9F%B3%E4%BB%A3%E7%A0%81/","excerpt":"","text":"调用Android系统语音TextToSpeech实例对象 具体代码写法如下： TextToSpeech mTextToSpeech = new TextToSpeech(this, new TextToSpeech.OnInitListener() { @Override public void onInit(int status) { if (status==TextToSpeech.SUCCESS) { //设置语言朗读 int supported= mTextToSpeech.setLanguage(Locale.US); if ((supported!=TextToSpeech.LANG_AVAILABLE)&amp;&amp; (supported!=TextToSpeech.LANG_COUNTRY_AVAILABLE)) { Toast.makeText(this, &quot;不支持当前语言！&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; &#125; &#125;); mTextToSpeech.speak(“这里填入想要转成语音的文字”, TextToSpeech.QUEUE_FLUSH, null);","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"Hello World","slug":"categories/前端/hello-world","date":"2020-08-02T12:26:42.000Z","updated":"2021-09-01T04:04:08.587Z","comments":true,"path":"2020/08/02/categories/前端/hello-world/","link":"","permalink":"https://visen123.github.io/2020/08/02/categories/%E5%89%8D%E7%AB%AF/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"前端","slug":"前端","permalink":"https://visen123.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"keywords":[{"name":"前端","slug":"前端","permalink":"https://visen123.github.io/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"Android开发图片开源框架","slug":"categories/Android/Android开发图片开源框架","date":"2020-07-27T06:20:40.000Z","updated":"2021-09-01T04:24:53.809Z","comments":true,"path":"2020/07/27/categories/Android/Android开发图片开源框架/","link":"","permalink":"https://visen123.github.io/2020/07/27/categories/Android/Android%E5%BC%80%E5%8F%91%E5%9B%BE%E7%89%87%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/","excerpt":"","text":"1、图片加载，缓存，处理 框架名称 ：Android Universal Image Loader 一个强大的加载，缓存，展示图片的库，已过时Picasso 一个强大的图片下载与缓存的库Fresco 一个用于管理图像和他们使用的内存的库Glide 一个图片加载和缓存的库，使用的App有：网易新闻GlidePalette Android Lollipop Palette is now easy to use with GlidePicassoPalette Android Lollipop Palette is now easy to use with Picasso !Picasso-transformations 一个为Picasso提供多种图片变换的库Glide-transformations 一个为Glide提供多种图片变换的库 2、图片裁剪 框架名称 ：uCrop Image Cropping Library for Android，使用的App有：薄荷，哔哩哔哩android-crop 图片裁剪，使用的App有：网易新闻，芒果TVcropper 图片裁剪开源框架Android-Image-Cropper Image Cropping Library for Android, optimized for Camera / GalleryPhotoCropper Android 大图片裁剪终极解决方案android-cropimage CropImage Activity from Gallery.apk packaged as a reusable Android libraryPhotoCrop A Library which can be used to crop images in Android similar to Facebook and Telegram，使用的App有：快手 3、图片选择框架名称 ：MultiImageSelector 图片选择，使用的App有：薄荷BGAPhotoPicker-Android Android 图片选择、预览、九宫格图片控件、拖拽排序九宫格图片控件TakePhoto 轻量级Android照片处理框架RxGalleryFinal Android图片单选/多选、拍照、裁剪、压缩。视频选择和录制。GalleryFinalboxing 一个多媒体选择器库，B站出品。可以选择一张或者多张图片，提供预览和裁剪功能。同样支持gif图，选择视频和图像压缩功能。 4、图片转换，压缩，滤镜 框架名称 ：Android-gpuimage 一个开源的基于GPU的图像处理库，提供各种各样的图像处理滤镜，并且支持照相机和摄像机的实时滤镜，使用的App有：快手photoview 使用的App有：薄荷,网易新闻circleimageview 圆形图片，使用的App有：薄荷RoundedImageView 圆形图片，使用的App有：薄荷SelectableRoundedImageView Android ImageView that supports different radii on each cornerandroid-gif-drawable gif图片，使用的App有：网易新闻，快手Luban 可能是最接近微信朋友圈的图片压缩算法Compressor Compressor is a lightweight and powerful android image compression library 5、高斯模糊，毛玻璃，图片模糊 框架名称 ：android-stackblur Android StackBlur is a library that can perform a blurry effect on a Bitmap based on a gradient or radius, and return the result. The library is based on the code of Mario Klingemann.Blurry Blurry is an easy blur library for Androidblurkit-android The missing Android blurring library. Fast blur-behind layout that parallels iOS.BlurView Dynamic iOS-like blur of underlying Views for AndroidImageBlurring Android blurring image(bitmap) by java and jni","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"解决在安卓8.0以上应用升级安装失败权限问题","slug":"categories/Android/解决在安卓8.0以上应用升级安装失败权限问题","date":"2020-07-12T11:36:40.000Z","updated":"2021-09-01T04:19:19.484Z","comments":true,"path":"2020/07/12/categories/Android/解决在安卓8.0以上应用升级安装失败权限问题/","link":"","permalink":"https://visen123.github.io/2020/07/12/categories/Android/%E8%A7%A3%E5%86%B3%E5%9C%A8%E5%AE%89%E5%8D%938.0%E4%BB%A5%E4%B8%8A%E5%BA%94%E7%94%A8%E5%8D%87%E7%BA%A7%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/","excerpt":"","text":"解决在安卓8.0、9.0机子上内部应用升级安装失败权限问题： 1、在AndroidManifest.xml 里配置安装权限 如下代码： 2、 在Application 配置如下代码//适配安卓8.0、9.0升级安装应用权限 ，请求权限允许安装未知应用权限public void allowUnKnowSrc(Context context){try {// todo 0代表禁止安装未知应用，1代表允许安装未知应用android.provider.Settings.Global.putInt(context.getContentResolver(),Settings.Secure.INSTALL_NON_MARKET_APPS, 1);}catch(SecurityException se){Log.e(“SecurityException==”,”安装未知应用权限问题”);}}","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"APP适配安卓手机刘海屏","slug":"categories/Android/APP适配安卓手机刘海屏","date":"2020-06-20T07:33:40.000Z","updated":"2021-09-01T04:20:26.633Z","comments":true,"path":"2020/06/20/categories/Android/APP适配安卓手机刘海屏/","link":"","permalink":"https://visen123.github.io/2020/06/20/categories/Android/APP%E9%80%82%E9%85%8D%E5%AE%89%E5%8D%93%E6%89%8B%E6%9C%BA%E5%88%98%E6%B5%B7%E5%B1%8F/","excerpt":"","text":"如果你想允许全屏界面内容显示到刘海区域 ，只要在AndroidManifest.xml文件里配置如下代码即可： &lt;!--适配华为（huawei）刘海屏--&gt; &lt;meta-data android:name=&quot;android.notch_support&quot; android:value=&quot;true&quot;/&gt; &lt;!--适配小米（xiaomi）刘海屏--&gt; &lt;meta-data android:name=&quot;notch.config&quot; android:value=&quot;portrait|landscape&quot; /&gt;","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"判断隐式intent跳转是否有判断有匹配的activity","slug":"categories/Android/判断隐式intent跳转是否有判断有匹配的activity","date":"2020-06-20T07:33:40.000Z","updated":"2021-09-01T04:45:35.355Z","comments":true,"path":"2020/06/20/categories/Android/判断隐式intent跳转是否有判断有匹配的activity/","link":"","permalink":"https://visen123.github.io/2020/06/20/categories/Android/%E5%88%A4%E6%96%AD%E9%9A%90%E5%BC%8Fintent%E8%B7%B3%E8%BD%AC%E6%98%AF%E5%90%A6%E6%9C%89%E5%88%A4%E6%96%AD%E6%9C%89%E5%8C%B9%E9%85%8D%E7%9A%84activity/","excerpt":"","text":"由于隐式intent并不会明确告知要打开哪些activity，有可能设备上就不会有合适的应用。这时候应用就会崩溃。为此我们在使用隐式intent之前，应该先进行安全检查，判断是否有合适的activity。 Intent intentpic = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); PackageManager pm=getPackageManager(); List activities=pm.queryIntentActivities(intentpic,0); if(activities.size()&lt;=0) { //不存在匹配跳转隐式intent的Activity ToastUtil.toastShow(PeopleDataActivity.this,”设备不支持拍照”); &#125; else&#123; //存在匹配跳转隐式intent的Activity ToastUtil.toastShow(PeopleDataActivity.this,&quot;设备支持拍照&quot;); &#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"RadioGroup结合RadioButton使用切换Fragment片段","slug":"categories/Android/RadioGroup结合RadioButton使用切换Fragment片段","date":"2020-05-22T06:33:40.000Z","updated":"2021-09-01T04:41:24.550Z","comments":true,"path":"2020/05/22/categories/Android/RadioGroup结合RadioButton使用切换Fragment片段/","link":"","permalink":"https://visen123.github.io/2020/05/22/categories/Android/RadioGroup%E7%BB%93%E5%90%88RadioButton%E4%BD%BF%E7%94%A8%E5%88%87%E6%8D%A2Fragment%E7%89%87%E6%AE%B5/","excerpt":"","text":"##界面布局activity_lan_qiu，代码xml设置如下： &lt;LinearLayout xmlns:android=”http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;include layout=&quot;@layout/tool_bar&quot;/&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@color/white&quot; android:orientation=&quot;vertical&quot;&gt; &lt;FrameLayout android:id=&quot;@+id/fragment_container&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot; android:background=&quot;@color/white&quot;&gt; &lt;/FrameLayout&gt; &lt;RadioGroup android:id=&quot;@+id/radioGroup&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;40dp&quot; android:orientation=&quot;horizontal&quot; android:background=&quot;@color/colorPrimary&quot; &gt; &lt;RadioButton android:text=&quot;首页&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:id=&quot;@+id/btn_homepage&quot; android:layout_weight=&quot;1&quot; android:button=&quot;@null&quot; android:gravity=&quot;center&quot; android:textColor=&quot;@color/selector_font_color&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;RadioButton android:text=&quot;社区&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:id=&quot;@+id/btn_message&quot; android:layout_weight=&quot;1&quot; android:button=&quot;@null&quot; android:gravity=&quot;center&quot; android:textColor=&quot;@color/selector_font_color&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;RadioButton android:text=&quot;运动&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:id=&quot;@+id/btn_service&quot; android:layout_weight=&quot;1&quot; android:button=&quot;@null&quot; android:gravity=&quot;center&quot; android:textColor=&quot;@color/selector_font_color&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;RadioButton android:text=&quot;个人&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:id=&quot;@+id/btn_my&quot; android:layout_weight=&quot;1&quot; android:button=&quot;@null&quot; android:gravity=&quot;center&quot; android:textColor=&quot;@color/selector_font_color&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;/RadioGroup&gt; &lt;/LinearLayout&gt; ##android java 类LanQiuActivity 代码如下： public class LanQiuActivity extends FragmentActivity implements RadioGroup.OnCheckedChangeListener { private RadioGroup radioGroup; private RadioButton btn_homepage, btn_message, btn_service, btn_my; public static final String fragment1Tag = &quot;fragment1&quot;; public static final String fragment2Tag = &quot;fragment2&quot;; public static final String fragment3Tag = &quot;fragment3&quot;; public static final String fragment4Tag = &quot;fragment4&quot;; private AMapLocationClient locationClient = null; private AMapLocationClientOption locationOption = null; private TextView tvshare; private TextView iv_back; String city; public static boolean aa = true; private Toolbar toolbar; /** * 定位监听 */ AMapLocationListener locationListener = new AMapLocationListener() &#123; @Override public void onLocationChanged(AMapLocation location) &#123; if (null != location) &#123; StringBuffer sb = new StringBuffer(); if (location.getErrorCode() == 0) &#123; //解析定位结果， city = location.getLatitude() + &quot;:&quot; + location.getLongitude(); &#125; else &#123; sb.append(&quot;定位失败&quot; + &quot;\\n&quot;); sb.append(&quot;错误码:&quot; + location.getErrorCode() + &quot;\\n&quot;); &#125; Log.e(&quot;解析定位结果&quot;, city); iv_back.setText(location.getCity()); &#125; else &#123; iv_back.setText(&quot;定位失败&quot;); &#125; if (aa) &#123; XinzhiTianqiData(); aa = false; &#125; &#125; &#125;; /** * 开始定位 * * @author hongming.wang * @since 2.8.0 */ private void startLocation() &#123; //根据控件的选择，重新设置定位参数 // resetOption(); // 设置定位参数 locationClient.setLocationOption(locationOption); // 启动定位 locationClient.startLocation(); &#125; /** * 默认的定位参数 * * @author hongming.wang * @since 2.8.0 */ private AMapLocationClientOption getDefaultOption() &#123; AMapLocationClientOption mOption = new AMapLocationClientOption(); mOption.setLocationMode(AMapLocationClientOption.AMapLocationMode.Hight_Accuracy);//可选，设置定位模式，可选的模式有高精度、仅设备、仅网络。默认为高精度模式 mOption.setGpsFirst(false);//可选，设置是否gps优先，只在高精度模式下有效。默认关闭 mOption.setHttpTimeOut(30000);//可选，设置网络请求超时时间。默认为30秒。在仅设备模式下无效 mOption.setInterval(2000);//可选，设置定位间隔。默认为2秒 mOption.setNeedAddress(true);//可选，设置是否返回逆地理地址信息。默认是true mOption.setOnceLocation(false);//可选，设置是否单次定位。默认是false mOption.setOnceLocationLatest(false);//可选，设置是否等待wifi刷新，默认为false.如果设置为true,会自动变为单次定位，持续定位时不要使用 AMapLocationClientOption.setLocationProtocol(AMapLocationClientOption.AMapLocationProtocol.HTTP);//可选， 设置网络请求的协议。可选HTTP或者HTTPS。默认为HTTP mOption.setSensorEnable(false);//可选，设置是否使用传感器。默认是false mOption.setWifiScan(true); //可选，设置是否开启wifi扫描。默认为true，如果设置为false会同时停止主动刷新，停止以后完全依赖于系统刷新，定位位置可能存在误差 mOption.setLocationCacheEnable(true); //可选，设置是否使用缓存定位，默认为true return mOption; &#125; /** * 初始化定位 * * @author hongming.wang * @since 2.8.0 */ private void initLocation() &#123; //初始化client locationClient = new AMapLocationClient(getApplicationContext()); locationOption = getDefaultOption(); //设置定位参数 locationClient.setLocationOption(locationOption); // 设置定位监听 locationClient.setLocationListener(locationListener); // XinzhiTianqiData(); &#125; private void XinzhiTianqiData() &#123; RequestParams params = new RequestParams(); params.put(&quot;location&quot;, city); Log.e(&quot;天气XinzhiTianqiData&quot;, &quot;天气XinzhiTianqiData&quot;); AsyncHttpClientUtil.getInstance().get(Constants.XinzhiTianqi, params, new AsyncHttpResponseHandler() &#123; @Override public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) &#123; String s = new String(responseBody); // Log.e(“天气”, “”+s); XinzhiModle xinzhiModle = GsonUtils.parseJSON(s, XinzhiModle.class); List&lt;XinzhiModle.ResultsBean&gt; results = xinzhiModle.getResults(); String text = results.get(0).getNow().getText(); tvshare.setText(&quot;天气: &quot; + text); &#125; @Override public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) &#123; &#125; &#125;); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); if (savedInstanceState == null) &#123; FragmentManager fragmentManager = getSupportFragmentManager(); Fragment fragment = new HomeFragment(); fragmentManager.beginTransaction().replace(R.id.fragment_container, fragment, fragment1Tag).commit(); &#125; setContentView(R.layout.activity_lan_qiu); toolbar = (Toolbar) findViewById(R.id.tool_bar); TextView tool_bar_title = (TextView)findViewById(R.id.tool_bar_title); tool_bar_title.setVisibility(View.GONE); tvshare = (TextView)findViewById(R.id.tv_share1); iv_back = (TextView)findViewById(R.id.iv_back1); iv_back.setVisibility(View.VISIBLE); tvshare.setVisibility(View.VISIBLE); iv_back.setTextSize(22); tvshare.setTextSize(22); radioGroup = (RadioGroup) this.findViewById(R.id.radioGroup); btn_homepage = (RadioButton) this.findViewById(R.id.btn_homepage); btn_homepage.setSelected(true); btn_message = (RadioButton) this.findViewById(R.id.btn_message); btn_service = (RadioButton) this.findViewById(R.id.btn_service); btn_my = (RadioButton) this.findViewById(R.id.btn_my); initLocation(); startLocation(); radioGroup.setOnCheckedChangeListener(this); &#125; public static void start(Context context, SzBean szBean) &#123; Intent starter = new Intent(context, MainActivity.class); starter.putExtra(ParamsKey.EXTRA_SZBEAN, szBean); context.startActivity(starter); &#125; //选中首页界面RadioButton处理事件 private void HomePageSelect() &#123; btn_homepage.setSelected(true); btn_message.setSelected(false); btn_service.setSelected(false); btn_my.setSelected(false); &#125; //选中信息界面RadioButton处理事件 private void MessageSelect() &#123; btn_homepage.setSelected(false); btn_message.setSelected(true); btn_service.setSelected(false); btn_my.setSelected(false); &#125; ##//选中记录RadioButton处理事件 private void RecordSelect() &#123; btn_homepage.setSelected(false); btn_message.setSelected(false); btn_service.setSelected(true); btn_my.setSelected(false); &#125; ##//选中我的界面RadioButton处理事件 private void MySelect() &#123; btn_homepage.setSelected(false); btn_message.setSelected(false); btn_service.setSelected(false); btn_my.setSelected(true); &#125; ##//在RadioGroup中切换改变选中RadioButton事件，处理跳转到相应界面 @Override public void onCheckedChanged(RadioGroup radioGroup, int i) &#123; FragmentManager fm = getSupportFragmentManager(); FragmentTransaction ft = fm.beginTransaction(); Fragment fragment1 = fm.findFragmentByTag(fragment1Tag); Fragment fragment2 = fm.findFragmentByTag(fragment2Tag); Fragment fragment3 = fm.findFragmentByTag(fragment3Tag); Fragment fragment4 = fm.findFragmentByTag(fragment4Tag); if (fragment1 != null) &#123; ft.hide(fragment1); &#125; if (fragment2 != null) &#123; ft.hide(fragment2); &#125; if (fragment3 != null) &#123; ft.hide(fragment3); &#125; if (fragment4 != null) &#123; ft.hide(fragment4); &#125; switch (i) &#123; case R.id.btn_homepage: toolbar.setVisibility(View.VISIBLE); if (fragment1 == null) &#123; fragment1 = new HomeFragment(); ft.add(R.id.fragment_container, fragment1, fragment1Tag); &#125; else &#123; ft.show(fragment1); &#125; HomePageSelect(); break; case R.id.btn_message: toolbar.setVisibility(View.VISIBLE); if (fragment2 == null) &#123; fragment2 = new BBsFragment(); ft.add(R.id.fragment_container, fragment2, fragment2Tag); &#125; else &#123; ft.show(fragment2); &#125; MessageSelect(); break; case R.id.btn_service: toolbar.setVisibility(View.VISIBLE); if (fragment3 == null) &#123; fragment3 = new SportFragment(); ft.add(R.id.fragment_container, fragment3, fragment3Tag); &#125; else &#123; ft.show(fragment3); &#125; RecordSelect(); break; case R.id.btn_my: toolbar.setVisibility(View.GONE); if (fragment4 == null) &#123; fragment4 = new PersonalCenteFragment(); ft.add(R.id.fragment_container, fragment4, fragment4Tag); &#125; else &#123; ft.show(fragment4); &#125; MySelect(); break; &#125; ft.commit(); &#125; ##//app退到后台，我们去玩其他的app，过一段时间回来，这个时候我们的app已经被销毁，我们按多任务键切换回来，发现界面上多个Fragment出现了重叠的情况，这是因为多个Fragment同时显示了，出现了重叠的情况，解决的办法如下：重写Activity的onRestoreInstanceState方法 @Override protected void onRestoreInstanceState(Bundle savedInstanceState) &#123; super.onRestoreInstanceState(savedInstanceState); for (int i = 0; i &lt; radioGroup.getChildCount(); i++) &#123; RadioButton mTab = (RadioButton) radioGroup.getChildAt(i); FragmentManager fm = getSupportFragmentManager(); Fragment fragment = fm.findFragmentByTag((String) mTab.getTag()); FragmentTransaction ft = fm.beginTransaction(); if (fragment != null) &#123; if (!mTab.isChecked()) &#123; ft.hide(fragment); &#125; &#125; ft.commit(); &#125; &#125; private long mExitTime; ##//按back提示再按一次退出 public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_BACK) &#123; if ((System.currentTimeMillis() - mExitTime) &gt; 2000) &#123; Toast.makeText(getApplicationContext(), &quot;再按一次退出&quot;, Toast.LENGTH_SHORT).show(); mExitTime = System.currentTimeMillis(); &#125; else &#123; finish(); System.exit(0); &#125; return true; &#125; return super.onKeyDown(keyCode, event); &#125; }","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"APP适配安卓手机刘海屏","slug":"categories/Android/更新ui常用方法","date":"2020-05-20T07:33:40.000Z","updated":"2021-09-01T04:56:09.967Z","comments":true,"path":"2020/05/20/categories/Android/更新ui常用方法/","link":"","permalink":"https://visen123.github.io/2020/05/20/categories/Android/%E6%9B%B4%E6%96%B0ui%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"更新ui代码段在Main线程执行常用方法 1.runOnUiThread 2.view.post view.postDelay() 3.handler.post handler.postDelay()","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"拼图APP 隐私声明","slug":"categories/Android/拼图APP","date":"2019-10-28T15:20:17.000Z","updated":"2021-09-01T05:10:30.295Z","comments":true,"path":"2019/10/28/categories/Android/拼图APP/","link":"","permalink":"https://visen123.github.io/2019/10/28/categories/Android/%E6%8B%BC%E5%9B%BEAPP/","excerpt":"","text":"尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，”拼图”会按照本隐私权政策的规定使用和披露您的个人信息。但”拼图”将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，”拼图”不会将这些信息对外披露或向第三方提供。”拼图”会不时更新本隐私权政策。您在同意”拼图”服务使用协议之时，即视为您已经同意本隐私权政策全部内容。本隐私权政策属于”拼图”服务使用协议不可分割的一部分。 1.适用范围 (1)在您使用本应用网络服务，或访问本应用平台网页时，本应用自动接收并记录的您的浏览器； (2)本应用通过合法途径从商业伙伴处取得的用户个人数据。 您了解并同意，以下信息不适用本隐私权政策： (3)您在使用本应用平台提供的搜索服务时输入的关键字信息； (4)本应用收集到的您在本应用发布的有关信息数据，包括但不限于参与活动、成交信息及评价详情； (5)违反法律规定或违反本应用规则行为及本应用已对您采取的措施。 2.信息使用 (a)本应用不会向任何无关第三方提供、出售、出租、分享或交易您的个人信息，除非事先得到您的许可，或该第三方和本应用（含本应用关联公司）单独或共同为您提供服务，且在该服务结束后，其将被禁止访问包括其以前能够访问的所有这些资料。 (b)本应用亦不允许任何第三方以任何手段收集、编辑、出售或者无偿传播您的个人信息。任何本应用平台用户如从事上述活动，一经发现，本应用有权立即终止与该用户的服务协议。 (c)为服务用户的目的，本应用可能通过使用您的个人信息，向您提供您感兴趣的信息，包括但不限于向您发出产品和服务信息，或者与本应用合作伙伴共享信息以便他们向您发送有关其产品和服务的信息（后者需要您的事先同意）。 3.信息披露 在如下情况下，本应用将依据您的个人意愿或法律的规定全部或部分的披露您的个人信息： (a)经您事先同意，向第三方披露； (b)为提供您所要求的产品和服务，而必须和第三方分享您的个人信息； (c)根据法律的有关规定，或者行政或司法机构的要求，向第三方或者行政、司法机构披露； (d)如您出现违反中国有关法律、法规或者本应用服务协议或相关规则的情况，需要向4.第三方披露； (e)如您是适格的知识产权投诉人并已提起投诉，应被投诉人要求，向被投诉人披露，以便双方处理可能的权利纠纷； (f)在本应用平台上创建的某一交易中，如交易任何一方履行或部分履行了交易义务并提出信息披露请求的，本应用有权决定向该用户提供其交易对方的联络方式等必要信息，以促成交易的完成或纠纷的解决。 (g)其它本应用根据法律、法规或者网站政策认为合适的披露。 5.信息存储和交换 本应用收集的有关您的信息和资料将保存在本应用及（或）其关联公司的服务器上，这些信息和资料可能传送至您所在国家、地区或本应用收集信息和资料所在地的境外并在境外被访问、存储和展示。 6.Cookie的使用 (a)在您未拒绝接受cookies的情况下，本应用会在您的计算机上设定或取用cookies ，以便您能登录或使用依赖于cookies的本应用平台服务或功能。本应用使用cookies可为您提供更加周到的个性化服务，包括推广服务。 (b)您有权选择接受或拒绝接受cookies。您可以通过修改浏览器设置的方式拒绝接受cookies。但如果您选择拒绝接受cookies，则您可能无法登录或使用依赖于cookies的本应用网络服务或功能。 (c)通过本应用所设cookies所取得的有关信息，将适用本政策。 7.信息安全 (a)本应用帐号均有安全保护功能，请妥善保管您的用户名及密码信息。本应用将通过对用户密码进行加密等安全措施确保您的信息不丢失，不被滥用和变造。尽管有前述安全措施，但同时也请您注意在信息网络上不存在“完善的安全措施”。","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"送祝福语APP 隐私声明","slug":"categories/Android/送祝福语APP","date":"2019-09-10T14:22:22.000Z","updated":"2021-09-01T05:10:06.387Z","comments":true,"path":"2019/09/10/categories/Android/送祝福语APP/","link":"","permalink":"https://visen123.github.io/2019/09/10/categories/Android/%E9%80%81%E7%A5%9D%E7%A6%8F%E8%AF%ADAPP/","excerpt":"","text":"尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，”送祝福语”会按照本隐私权政策的规定使用和披露您的个人信息。但”送祝福语”将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，”送祝福语”不会将这些信息对外披露或向第三方提供。”送祝福语”会不时更新本隐私权政策。您在同意”送祝福语”服务使用协议之时，即视为您已经同意本隐私权政策全部内容。本隐私权政策属于”送祝福语”服务使用协议不可分割的一部分。 1.适用范围 (1)在您使用本应用网络服务，或访问本应用平台网页时，本应用自动接收并记录的您的浏览器； (2)本应用通过合法途径从商业伙伴处取得的用户个人数据。 您了解并同意，以下信息不适用本隐私权政策： (3)您在使用本应用平台提供的搜索服务时输入的关键字信息； (4)本应用收集到的您在本应用发布的有关信息数据，包括但不限于参与活动、成交信息及评价详情； (5)违反法律规定或违反本应用规则行为及本应用已对您采取的措施。 2.信息使用 (a)本应用不会向任何无关第三方提供、出售、出租、分享或交易您的个人信息，除非事先得到您的许可，或该第三方和本应用（含本应用关联公司）单独或共同为您提供服务，且在该服务结束后，其将被禁止访问包括其以前能够访问的所有这些资料。 (b)本应用亦不允许任何第三方以任何手段收集、编辑、出售或者无偿传播您的个人信息。任何本应用平台用户如从事上述活动，一经发现，本应用有权立即终止与该用户的服务协议。 (c)为服务用户的目的，本应用可能通过使用您的个人信息，向您提供您感兴趣的信息，包括但不限于向您发出产品和服务信息，或者与本应用合作伙伴共享信息以便他们向您发送有关其产品和服务的信息（后者需要您的事先同意）。 3.信息披露 在如下情况下，本应用将依据您的个人意愿或法律的规定全部或部分的披露您的个人信息： (a)经您事先同意，向第三方披露； (b)为提供您所要求的产品和服务，而必须和第三方分享您的个人信息； (c)根据法律的有关规定，或者行政或司法机构的要求，向第三方或者行政、司法机构披露； (d)如您出现违反中国有关法律、法规或者本应用服务协议或相关规则的情况，需要向4.第三方披露； (e)如您是适格的知识产权投诉人并已提起投诉，应被投诉人要求，向被投诉人披露，以便双方处理可能的权利纠纷； (f)在本应用平台上创建的某一交易中，如交易任何一方履行或部分履行了交易义务并提出信息披露请求的，本应用有权决定向该用户提供其交易对方的联络方式等必要信息，以促成交易的完成或纠纷的解决。 (g)其它本应用根据法律、法规或者网站政策认为合适的披露。 5.信息存储和交换 本应用收集的有关您的信息和资料将保存在本应用及（或）其关联公司的服务器上，这些信息和资料可能传送至您所在国家、地区或本应用收集信息和资料所在地的境外并在境外被访问、存储和展示。 6.Cookie的使用 (a)在您未拒绝接受cookies的情况下，本应用会在您的计算机上设定或取用cookies ，以便您能登录或使用依赖于cookies的本应用平台服务或功能。本应用使用cookies可为您提供更加周到的个性化服务，包括推广服务。 (b)您有权选择接受或拒绝接受cookies。您可以通过修改浏览器设置的方式拒绝接受cookies。但如果您选择拒绝接受cookies，则您可能无法登录或使用依赖于cookies的本应用网络服务或功能。 (c)通过本应用所设cookies所取得的有关信息，将适用本政策。 7.信息安全 (a)本应用帐号均有安全保护功能，请妥善保管您的用户名及密码信息。本应用将通过对用户密码进行加密等安全措施确保您的信息不丢失，不被滥用和变造。尽管有前述安全措施，但同时也请您注意在信息网络上不存在“完善的安全措施”。","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]},{"title":"猜歌APP 隐私声明","slug":"categories/Android/猜歌APP","date":"2019-09-10T14:22:22.000Z","updated":"2023-12-06T10:51:11.935Z","comments":true,"path":"2019/09/10/categories/Android/猜歌APP/","link":"","permalink":"https://visen123.github.io/2019/09/10/categories/Android/%E7%8C%9C%E6%AD%8CAPP/","excerpt":"","text":"尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，”猜歌”会按照本隐私权政策的规定使用和披露您的个人信息。但”猜歌”将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，”猜歌”不会将这些信息对外披露或向第三方提供。”猜歌”会不时更新本隐私权政策。您在同意”猜歌”服务使用协议之时，即视为您已经同意本隐私权政策全部内容。本隐私权政策属于”猜歌”服务使用协议不可分割的一部分。 1.适用范围 (1)在您使用本应用网络服务，或访问本应用平台网页时，本应用自动接收并记录的您的浏览器； (2)本应用通过合法途径从商业伙伴处取得的用户个人数据。 您了解并同意，以下信息不适用本隐私权政策： (3)您在使用本应用平台提供的搜索服务时输入的关键字信息； (4)本应用收集到的您在本应用发布的有关信息数据，包括但不限于参与活动、成交信息及评价详情； (5)违反法律规定或违反本应用规则行为及本应用已对您采取的措施。 2.信息使用 (a)本应用不会向任何无关第三方提供、出售、出租、分享或交易您的个人信息，除非事先得到您的许可，或该第三方和本应用（含本应用关联公司）单独或共同为您提供服务，且在该服务结束后，其将被禁止访问包括其以前能够访问的所有这些资料。 (b)本应用亦不允许任何第三方以任何手段收集、编辑、出售或者无偿传播您的个人信息。任何本应用平台用户如从事上述活动，一经发现，本应用有权立即终止与该用户的服务协议。 (c)为服务用户的目的，本应用可能通过使用您的个人信息，向您提供您感兴趣的信息，包括但不限于向您发出产品和服务信息，或者与本应用合作伙伴共享信息以便他们向您发送有关其产品和服务的信息（后者需要您的事先同意）。 3.信息披露 在如下情况下，本应用将依据您的个人意愿或法律的规定全部或部分的披露您的个人信息： (a)经您事先同意，向第三方披露； (b)为提供您所要求的产品和服务，而必须和第三方分享您的个人信息； (c)根据法律的有关规定，或者行政或司法机构的要求，向第三方或者行政、司法机构披露； (d)如您出现违反中国有关法律、法规或者本应用服务协议或相关规则的情况，需要向4.第三方披露； (e)如您是适格的知识产权投诉人并已提起投诉，应被投诉人要求，向被投诉人披露，以便双方处理可能的权利纠纷； (f)在本应用平台上创建的某一交易中，如交易任何一方履行或部分履行了交易义务并提出信息披露请求的，本应用有权决定向该用户提供其交易对方的联络方式等必要信息，以促成交易的完成或纠纷的解决。 (g)其它本应用根据法律、法规或者网站政策认为合适的披露。 5.信息存储和交换 本应用收集的有关您的信息和资料将保存在本应用及（或）其关联公司的服务器上，这些信息和资料可能传送至您所在国家、地区或本应用收集信息和资料所在地的境外并在境外被访问、存储和展示。 6.Cookie的使用 (a)在您未拒绝接受cookies的情况下，本应用会在您的计算机上设定或取用cookies ，以便您能登录或使用依赖于cookies的本应用平台服务或功能。本应用使用cookies可为您提供更加周到的个性化服务，包括推广服务。 (b)您有权选择接受或拒绝接受cookies。您可以通过修改浏览器设置的方式拒绝接受cookies。但如果您选择拒绝接受cookies，则您可能无法登录或使用依赖于cookies的本应用网络服务或功能。 (c)通过本应用所设cookies所取得的有关信息，将适用本政策。 7.信息安全 (a)本应用帐号均有安全保护功能，请妥善保管您的用户名及密码信息。本应用将通过对用户密码进行加密等安全措施确保您的信息不丢失，不被滥用和变造。尽管有前述安全措施，但同时也请您注意在信息网络上不存在“完善的安全措施”。","categories":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"https://visen123.github.io/categories/Android/"}]}]}